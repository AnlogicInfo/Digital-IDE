
const Base_linter = require('./base_linter');

class Xilinx extends Base_linter {
    constructor(language) {
        super();
        // SystemVerilog
        if (language !== undefined && language === 'systemverilog') {
            this.PARAMETERS = {
                'SYNT': "xvlog --sv --nolog",
                'SYNT_WINDOWS': "xvlog --sv --nolog"
            };
        }
        // Verilog
        else if (language !== undefined && language === 'verilog') {
            this.PARAMETERS = {
                'SYNT': "xvlog -nolog",
                'SYNT_WINDOWS': "xvlog -nolog"
            };
        }
        // VHDL
        else {
            this.PARAMETERS = {
                'SYNT': "xvhdl -nolog",
                'SYNT_WINDOWS': "xvhdl -nolog"
            };
        }
    }

    // options = {custom_bin:"", custom_arguments:""}
    async lint_from_file(file, options) {
        let normalized_file = file.replace(' ', '\\ ');
        let errors = await this._lint(normalized_file, options);
        return errors;
    }

    async lint_from_code(file, code, options) {
        let temp_file = await this._create_temp_file_of_code(code);
        let errors = await this._lint(temp_file, options);
        return errors;
    }

    async _lint(file, options) {
        let result = await this._exec_linter(file, this.PARAMETERS.SYNT,
            this.PARAMETERS.SYNT_WINDOWS, options);
        file = file.replace('\\ ', ' ');
        let errors_str = result.stdout;
        let errors_str_lines = errors_str.split(/\r?\n/g);
        let errors = [];
        console.log(`[colibri][info] Linting xvlog, result: ${errors_str}`);
        errors_str_lines.forEach((line) => {
            let tokens = line.split(/:?\s*(?:\[|\])\s*/).filter(Boolean);
            if (tokens.length < 4
                || tokens[0] !== "ERROR"
                || !tokens[1].startsWith("VRFC")) {
                return;
            }

            // Get filename and line number
            // eslint-disable-next-line no-unused-vars
            let [filename, lineno_str] = tokens[3].split(/:(\d+)/);
            let lineno = parseInt(lineno_str) - 1;

            // if (filename != doc.fileName) // Check that filename matches
            //     return;

            let error = {
                'severity': "error",
                'description': "[" + tokens[1] + "] " + tokens[2],
                'code': tokens[1],
                'location': {
                    'file': file,
                    'position': [lineno, 0]
                }
            };
            errors.push(error);
        });

        return errors;
    }
}

module.exports = {
    Xilinx: Xilinx
};
