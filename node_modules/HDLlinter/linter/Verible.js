
const Base_linter = require('./base_linter');

class Verible extends Base_linter {
    constructor(type) {
        super();
        this.VLOGPARAMETERS = {
            'SYNT': "verilog_syntax ",
            'SYNT_WINDOWS': "verilog_syntax "
        };
        // if (type !== "syntax") {
        //     this.PARAMETERS = {
        //         'SYNT': "verilog_lint ",
        //         'SYNT_WINDOWS': "verilog_lint "
        //     };
        // } else {
        //     this.PARAMETERS = {
        //         'SYNT': "verilog_syntax ",
        //         'SYNT_WINDOWS': "verilog_syntax "
        //     };
        // }
    }

    // options = {custom_bin:"", custom_arguments:""}
    async lint_from_file(file, options, parameter) {
        let normalized_file = file.replace(' ', '\\ ');
        let errors = await this._lint(normalized_file, options, parameter);
        return errors;
    }

    async lint_from_code(file, code, options, parameter) {
        let temp_file = await this._create_temp_file_of_code(code);
        let errors = await this._lint(temp_file, options, parameter);
        return errors;
    }

    async _lint(file, options, parameter) {
        let result = await this._exec_linter(file, parameter.SYNT,
            parameter.SYNT_WINDOWS, options);
        try {
            file = file.replace('\\ ', ' ');
            let errors_str = result.stdout;
            let errors_str_lines = errors_str.split(/\r?\n/g);
            let errors = [];
            errors_str_lines.forEach((line) => {
                if (line.startsWith(file)) {
                    line = line.replace(file, '');
                    let terms = line.split(':');
                    let line_num = parseInt(terms[1].trim());
                    let column_num = parseInt(terms[2].trim());
                    if (terms.length === 3) {
                        let error = {
                            'severity': "warning",
                            'description': terms[3].trim(),
                            'location': {
                                'file': file,
                                'position': [line_num - 1, column_num - 1]
                            }
                        };
                        errors.push(error);
                    }
                    else if (terms.length > 3) {
                        let message = "";
                        for (let x = 3; x < terms.length - 1; ++x) {
                            message += terms[x].trim() + ":";
                        }
                        message += terms[terms.length - 1].trim();
                        let error = {
                            'severity': 'warning',
                            'description': message,
                            'location': {
                                'file': "file",
                                'position': [line_num - 1, column_num - 1]
                            }
                        };
                        errors.push(error);
                    }
                }
            });
            return errors;
        } catch (error) {
            // eslint-disable-next-line no-console
            console.log(error);
            return [];
        }
    }
}

module.exports = {
    Verible: Verible
};
