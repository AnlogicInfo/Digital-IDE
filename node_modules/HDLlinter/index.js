"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const vscode    = require("vscode");

const Vsg       = require('./linter/Vsg');

// Verilog or SystemVerilog only
const Icarus    = require('./linter/Icarus');
const Verilator = require('./linter/Verilator');
const Verible   = require('./linter/Verible');

// VHDL only
const Ghdl      = require('./linter/Ghdl');

// HDL linter
const Vivado    = require('./linter/Vivado');
const Modelsim  = require('./linter/Modelsim');

function registerLinterServer() {
    let linter = new Linter();
    vscode.workspace.onDidOpenTextDocument(linter.lint, linter, linter.subscriptions);
    vscode.workspace.onDidSaveTextDocument(linter.lint, linter, linter.subscriptions);
    vscode.workspace.onDidCloseTextDocument(linter.remove_file_diagnostics, linter, linter.subscriptions);
    vscode.workspace.onDidChangeConfiguration(linter.config_linter, linter, linter.subscriptions);
}
exports.registerLinterServer = registerLinterServer;

class Linter {
    constructor() {
        var _a;
        this.uri_collections = [];
        //Configuration
        this.vlog_linter_name = "default";
        this.vhdl_linter_name = "default";
        this.vlog_linter_path = "";
        this.vhdl_linter_path = "";
        this.vlog_linter_arguments = "";
        this.vhdl_linter_arguments = "";

        this.vlog_linter = null;
        this.vhdl_linter = null;

        this.diagnostic_collection = vscode.languages.createDiagnosticCollection();
        this.config_linter();
        this.lint((_a = vscode.window.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document);
    }

    config_linter() {
        //todo: use doc!! .git error
        this.vlog_linter_name = vscode.workspace.getConfiguration("HDL.linting.vlog").get("linter");
        this.vhdl_linter_name = vscode.workspace.getConfiguration("HDL.linting.vhdl").get("linter");
        //Custom linter path
        this.vlog_linter_path   = vscode.workspace.getConfiguration("TOOL." + this.vlog_linter_name + ".install").get("path");
        this.vhdl_linter_path   = vscode.workspace.getConfiguration("TOOL." + this.vhdl_linter_name + ".install").get("path");
        //Custom arguments
        this.vlog_linter_arguments = vscode.workspace.getConfiguration("HDL.linting." + this.vlog_linter_name).get("arguments");
        this.vhdl_linter_arguments = vscode.workspace.getConfiguration("HDL.linting." + this.vhdl_linter_name).get("arguments");

        this.linter_enable = true;
        if (this.vlog_linter_name === 'default' || this.vlog_linter_name === "") {
            this.linter_enable = false;
            this.remove_all();
        } else {
            switch (this.vlog_linter_name) {
                case "vivado"   : this.vlog_linter = new Vivado.Vivado(); break;
                case "modelsim" : this.vlog_linter = new Modelsim.Modelsim(); break;
                case "iverilog" : this.vlog_linter = new Icarus.Icarus(); break;
                case "verible"  : this.vlog_linter = new Verible.Verible(); break;
                case "verilator": this.vlog_linter = new Verilator.Verilator(); break;
                // case "vsg"      : this.vlog_linter = new Vsg.Vsg(); break;
                default: this.vlog_linter = null; break;
            }
        }
        if (this.vhdl_linter_name === 'default' || this.vhdl_linter_name === "") {
            this.linter_enable = false;
            this.remove_all();
        } else {
            switch (this.vhdl_linter_name) {
                case "vivado"   : this.vhdl_linter = new Vivado.Vivado(); break;
                case "modelsim" : this.vhdl_linter = new Modelsim.Modelsim(); break;
                case "ghdl"     : this.vhdl_linter = new Ghdl.Ghdl(); break;
                default: this.vhdl_linter = null; break;
            }
        }
        if (this.linter_enable === true) {
            this.refresh_lint();
        } else {
            this.vlog_linter = null;
            this.vhdl_linter = null;
            return;
        }
    }
    get_vhdl_config() {
        let options;
        if (this.vhdl_linter_path !== "") {
            options = {
                'custom_path': this.vhdl_linter_path,
                'custom_arguments': this.vhdl_linter_arguments
            };
        }
        else {
            options = { 
                'custom_arguments': this.vhdl_linter_arguments 
            };
        }
        return options;
    }
    get_vlog_config() {
        let options;
        if (this.vlog_linter_path !== "") {
            options = {
                'custom_path': this.vlog_linter_path,
                'custom_arguments': this.vlog_linter_arguments
            };
        }
        else {
            options = { 
                'custom_arguments': this.vlog_linter_arguments 
            };
        }
        return options;
    }

    lint(doc) {
        return __awaiter(this, void 0, void 0, function* () {
            if (doc === undefined) {
                return;
            }
            if (doc.languageId  == "verilog" || doc.languageId == "systemverilog") {
                if(this.vlog_linter == null) {
                    return;
                }
            }
            if (doc.languageId  == "vhdl") {
                if(this.vhdl_linter == null) {
                    return;
                }
            }
            let current_path = doc.uri.fsPath;
            //Save the uri linted
            this.add_uri_to_collections(doc.uri);
            let errors = [];
            if (doc.languageId == "verilog") {
                errors = yield this.vlog_linter.lint_from_file(
                    current_path, 
                    this.get_vlog_config(), 
                    this.vlog_linter.VLOGPARAMETERS);
            }
            else if (doc.languageId == "systemverilog") {
                errors = yield this.vlog_linter.lint_from_file(
                    current_path, 
                    this.get_vlog_config(),
                    this.vlog_linter.SVLOGPARAMETERS);
            }
            else if (doc.languageId == "vhdl") {
                errors = yield this.vhdl_linter.lint_from_file(
                    current_path, 
                    this.get_vhdl_config(),
                    this.vhdl_linter.VHDLPARAMETERS);
            }
            let diagnostics = [];
            for (var i = 0; i < errors.length; ++i) {
                const line = errors[i]['location']['position'][0];
                let col = errors[i]['location']['position'][1];
                let code = "";
                if (errors[i].code !== undefined) {
                    code = errors[i].code;
                }
                else {
                    code = errors[i].severity;
                }
                diagnostics.push({
                    severity: this.get_severity(errors[i]['severity']),
                    range: new vscode.Range((+line), (+col), (+line), Number.MAX_VALUE),
                    message: errors[i]['description'],
                    code: code,
                    source: `HDL:${this.linter_name}`
                });
            }
            this.diagnostic_collection.set(doc.uri, diagnostics);
        });
    }
    get_severity(sev) {
        if (sev === "error") {
            return vscode.DiagnosticSeverity.Error;
        }
        else if (sev === "warning") {
            return vscode.DiagnosticSeverity.Warning;
        }
        else {
            return vscode.DiagnosticSeverity.Error;
        }
    }
    remove_file_diagnostics(doc) {
        this.diagnostic_collection.delete(doc.uri);
        for (let i = 0; i < this.uri_collections.length; ++i) {
            if (doc.uri === this.uri_collections[i]) {
                this.uri_collections.splice(i, 1);
                break;
            }
        }
    }
    add_uri_to_collections(uri) {
        for (let i = 0; i < this.uri_collections.length; ++i) {
            if (uri === this.uri_collections[i]) {
                return;
            }
        }
        this.uri_collections.push(uri);
    }
    remove_all() {
        for (let i = 0; i < this.uri_collections.length; ++i) {
            this.lint_from_uri(this.uri_collections[i], true);
        }
    }
    refresh_lint() {
        for (let i = 0; i < this.uri_collections.length; ++i) {
            // this.remove_file_diagnostics();
            this.lint_from_uri(this.uri_collections[i]);
        }
    }
    lint_from_uri(uri, empty = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let current_path = uri.fsPath;
            let errors = yield this.linter.lint_from_file(current_path, this.get_config());
            let diagnostics = [];
            if (empty === true) {
                this.diagnostic_collection.set(uri, diagnostics);
                return;
            }
            for (var i = 0; i < errors.length; ++i) {
                const line = errors[i]['location']['position'][0];
                let col = errors[i]['location']['position'][1];
                let code = "";
                if (errors[i].code !== undefined) {
                    code = errors[i].code;
                }
                else {
                    code = errors[i].severity;
                }
                diagnostics.push({
                    severity: this.get_severity(errors[i]['severity']),
                    range: new vscode.Range((+line), (+col), (+line), Number.MAX_VALUE),
                    message: errors[i]['description'],
                    code: code,
                    source: `HDL:${this.linter_name}`
                });
            }
            this.diagnostic_collection.set(uri, diagnostics);
        });
    }
}

class Vsg_action_provider {
    provideCodeActions(document, range, context, token) {
        return context.diagnostics
            .filter(diagnostic => diagnostic.source == "HDL:vsg")
            .map(diagnostic => this.createCommandCodeAction(diagnostic, document, range));
        // let diagnostic_array = context.diagnostics;
        // return this.createCommandCodeAction(diagnostic_array,document,range);
    }
    createCommandCodeAction(diagnostic, document, range) {
        const action = new vscode.CodeAction(`Disable ${diagnostic.code} for this line.`, vscode.CodeActionKind.QuickFix);
        // action.command = 'workbench.action.files.save';
        action.command = {
            title: "info.description",
            command: 'workbench.action.files.save'
            // arguments: [document, file, info, rangeOrSelection]
        };
        action.diagnostics = [diagnostic];
        action.isPreferred = true;
        let pepe = range.start;
        action.edit = new vscode.WorkspaceEdit();
        let spaces = document.getText(new vscode.Range(range.start.line, 0, range.start.line, range.start.character));
        action.edit.insert(document.uri, new vscode.Position(range.start.line, range.start.character), `-- vsg-disable-next-line ${diagnostic.code}\n${spaces}`);
        return action;
    }
}
Vsg_action_provider.providedCodeActionKinds = [
    vscode.CodeActionKind.QuickFix
];