"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const vscode    = require("vscode");

const Vsg       = require('./linter/Vsg');

// Verilog or SystemVerilog only
const Icarus    = require('./linter/Icarus');
const Verilator = require('./linter/Verilator');
const Verible   = require('./linter/Verible');

// VHDL only
const Ghdl      = require('./linter/Ghdl');

// HDL linter
const Vivado    = require('./linter/Vivado');
const Modelsim  = require('./linter/Modelsim');

class Linter {
    constructor(linter_name, language) {
        if (linter_name === undefined) {
            throw new Error('Linter name is undefined.');
        }
        if (linter_name === 'ghdl') {
            return this.get_ghdl();
        }
        else if (linter_name === 'iverilog') {
            return this.get_icarus(language);
        }
        else if (linter_name === 'vivado') {
            return this.get_vivado(language);
        }
        else if (linter_name === 'modelsim') {
            return this.get_modelsim(language);
        }
        else if (linter_name === 'verilator') {
            return this.get_verilator(language);
        }
        else if (linter_name === 'verible') {
            return this.get_verible();
        }
        else if (linter_name === 'vsg') {
            return this.get_vsg();
        }
        else {
            console.log(`[colibri][error] Linter name ${linter_name} not supported `);
            throw new Error('Linter name not supported.');
        }
    }

    get_ghdl() {
        return new Ghdl.Ghdl();
    }
    get_icarus(language) {
        return new Icarus.Icarus(language);
    }
    get_modelsim(language) {
        return new Modelsim.Modelsim(language);
    }
    get_verilator(language) {
        return new Verilator.Verilator(language);
    }
    get_vivado(language) {
        return new Vivado.Vivado(language);
    }
    get_vsg() {
        return new Vsg.Vsg();
    }
    get_verible() {
        return new Verible.Verible();
    }
}

class registerLinterServer {
    constructor(language, linter_type, context) {
        var _a;
        this.uri_collections = [];
        this.linter_type = "";
        //Configuration
        this.linter_name = "";
        this.linter_path = "";
        this.linter_arguments = "";
        this.custom_exec = "";
        this.enable_custom_exec = false;
        this.lang = language;
        this.linter_type = linter_type;
        this.diagnostic_collection = vscode.languages.createDiagnosticCollection();
        // vscode.workspace.onDidOpenTextDocument(this.lint, this, this.subscriptions);
        vscode.workspace.onDidSaveTextDocument(this.lint, this, this.subscriptions);
        vscode.workspace.onDidCloseTextDocument(this.remove_file_diagnostics, this, this.subscriptions);
        vscode.workspace.onDidChangeConfiguration(this.config_linter, this, this.subscriptions);
        this.config_linter();
        this.lint((_a = vscode.window.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document);
        if (language === "vhdl" && linter_type === "linter_style") {
            context.subscriptions.push(vscode.languages.registerCodeActionsProvider('vhdl', new vsg_action_provider.Vsg_action_provider(), {
                providedCodeActionKinds: vsg_action_provider.Vsg_action_provider.providedCodeActionKinds
            }));
        }
    }
    config_linter() {
        //todo: use doc!! .git error
        this.linter_name = vscode.workspace.getConfiguration("HDL.linting").get("linter");
        this.linter_name = linter_name.toLowerCase();
        if (this.linter_type === "linter") {
            //Custom linter path
            this.linter_path        = vscode.workspace.getConfiguration("TOOL." + linter_name + ".install").get("path");
            //Enable custom binary exec
            this.custom_exec        = vscode.workspace.getConfiguration("HDL.linting." + linter_name + ".xcall").get("bin");
            this.enable_custom_exec = vscode.workspace.getConfiguration("HDL.linting." + linter_name + ".xcall").get("enable");
            //Custom arguments
            this.linter_arguments   = vscode.workspace.getConfiguration("HDL.linting." + linter_name).get("arguments");
        }
        this.linter_enable = true;
    }
    get_config() {
        let options;
        if (this.enable_custom_exec === true) {
            options = {
                'custom_bin': this.custom_exec,
                'custom_arguments': this.linter_arguments
            };
        }
        else if (this.linter_path !== "") {
            options = {
                'custom_path': this.linter_path,
                'custom_arguments': this.linter_arguments
            };
        }
        else {
            options = { 'custom_arguments': this.linter_arguments };
        }
        return options;
    }
    lint(doc) {
        return __awaiter(this, void 0, void 0, function* () {
            //todo: use doc!! .git error check sheme
            // if (vscode.window.activeTextEditor === undefined){
            //     return;
            // }
            // let document = vscode.window.activeTextEditor.document;
            if (doc === undefined) {
                return;
            }
            let language_id = doc.languageId;
            if (this.linter === undefined || (language_id !== this.lang)) {
                return;
            }
            if (this.linter_name === 'none' || this.linter_name === "") {
                this.linter_enable = false;
                this.remove_all();
            }
            if (this.linter_enable === true) {
                this.linter = new Linter(this.linter_name, language_id);
                this.refresh_lint();
            }
            else {
                this.linter = undefined;
                return;
            }
            // let current_path = vscode.window.activeTextEditor?.document.uri.fsPath;
            let current_path = doc.uri.fsPath;
            //Save the uri linted
            this.add_uri_to_collections(doc.uri);
            console.log(`[HDL] Linting ${current_path}`);
            let errors = yield this.linter.lint_from_file(current_path, this.get_config());
            let diagnostics = [];
            for (var i = 0; i < errors.length; ++i) {
                const line = errors[i]['location']['position'][0];
                let col = errors[i]['location']['position'][1];
                let code = "";
                if (errors[i].code !== undefined) {
                    code = errors[i].code;
                }
                else {
                    code = errors[i].severity;
                }
                diagnostics.push({
                    severity: this.get_severity(errors[i]['severity']),
                    range: new vscode.Range((+line), (+col), (+line), Number.MAX_VALUE),
                    message: errors[i]['description'],
                    code: code,
                    source: `HDL:${this.linter_name}`
                });
            }
            this.diagnostic_collection.set(doc.uri, diagnostics);
        });
    }
    remove_file_diagnostics(doc) {
        this.diagnostic_collection.delete(doc.uri);
        for (let i = 0; i < this.uri_collections.length; ++i) {
            if (doc.uri === this.uri_collections[i]) {
                this.uri_collections.splice(i, 1);
                break;
            }
        }
    }
    add_uri_to_collections(uri) {
        for (let i = 0; i < this.uri_collections.length; ++i) {
            if (uri === this.uri_collections[i]) {
                return;
            }
        }
        this.uri_collections.push(uri);
    }
    remove_all() {
        for (let i = 0; i < this.uri_collections.length; ++i) {
            this.lint_from_uri(this.uri_collections[i], true);
        }
    }
    refresh_lint() {
        for (let i = 0; i < this.uri_collections.length; ++i) {
            // this.remove_file_diagnostics();
            this.lint_from_uri(this.uri_collections[i]);
        }
    }
    get_severity(sev) {
        if (sev === "error") {
            return vscode.DiagnosticSeverity.Error;
        }
        else if (sev === "warning") {
            return vscode.DiagnosticSeverity.Warning;
        }
        else {
            return vscode.DiagnosticSeverity.Error;
        }
    }
    lint_from_uri(uri, empty = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let current_path = uri.fsPath;
            let errors = yield this.linter.lint_from_file(current_path, this.get_config());
            let diagnostics = [];
            if (empty === true) {
                this.diagnostic_collection.set(uri, diagnostics);
                return;
            }
            for (var i = 0; i < errors.length; ++i) {
                const line = errors[i]['location']['position'][0];
                let col = errors[i]['location']['position'][1];
                let code = "";
                if (errors[i].code !== undefined) {
                    code = errors[i].code;
                }
                else {
                    code = errors[i].severity;
                }
                diagnostics.push({
                    severity: this.get_severity(errors[i]['severity']),
                    range: new vscode.Range((+line), (+col), (+line), Number.MAX_VALUE),
                    message: errors[i]['description'],
                    code: code,
                    source: `HDL:${this.linter_name}`
                });
            }
            this.diagnostic_collection.set(uri, diagnostics);
        });
    }
}
exports.registerLinterServer = registerLinterServer;

class Vsg_action_provider {
    provideCodeActions(document, range, context, token) {
        return context.diagnostics
            .filter(diagnostic => diagnostic.source == "HDL:vsg")
            .map(diagnostic => this.createCommandCodeAction(diagnostic, document, range));
        // let diagnostic_array = context.diagnostics;
        // return this.createCommandCodeAction(diagnostic_array,document,range);
    }
    createCommandCodeAction(diagnostic, document, range) {
        const action = new vscode.CodeAction(`Disable ${diagnostic.code} for this line.`, vscode.CodeActionKind.QuickFix);
        // action.command = 'workbench.action.files.save';
        action.command = {
            title: "info.description",
            command: 'workbench.action.files.save'
            // arguments: [document, file, info, rangeOrSelection]
        };
        action.diagnostics = [diagnostic];
        action.isPreferred = true;
        let pepe = range.start;
        action.edit = new vscode.WorkspaceEdit();
        let spaces = document.getText(new vscode.Range(range.start.line, 0, range.start.line, range.start.character));
        action.edit.insert(document.uri, new vscode.Position(range.start.line, range.start.character), `-- vsg-disable-next-line ${diagnostic.code}\n${spaces}`);
        return action;
    }
}
Vsg_action_provider.providedCodeActionKinds = [
    vscode.CodeActionKind.QuickFix
];