"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const fs      = require("fs");
const fspath  = require("path");
const vscode  = require("vscode");
const child   = require("child_process");
const filesys = require("HDLfilesys");
const parser  = require("HDLparser");

const xilinx  = require("./xilinx");

class fpgaRegister {
    constructor (context, opeParam) {
        this.StartFPGA = null;
        this.currentState = false;

        this.context  = context;
        this.opeParam = opeParam;
        this.setting  = vscode.workspace.getConfiguration();
        this.getConfig();
        vscode.workspace.onDidChangeConfiguration(function () {
            this.getConfig();
        });
        var _this = this;
        vscode.window.onDidCloseTerminal(function (terminal) {
            if (terminal.name == "StartFPGA") {
                _this.currentState = false;
                xilinx.move_bd_IP(opeParam);
                vscode.window.showInformationMessage("Terminal Closed, name: " + terminal.name);
            }
        });
    }
    getConfig() {
        this.xilinxInstallPath = this.setting.get('TOOL.vivado.install.path');
        this.vivadoPath = "vivado";
        if (this.xilinxInstallPath != "") {
            this.vivadoPath = this.xilinxInstallPath.replace("//","/").replace(/\\/g,"\/");
            if (this.opeParam.os == "win32") {
                this.vivadoPath = this.vivadoPath + "vivado.bat";
            }
        }
    }
    Launch() {
        if (this.opeParam.propertyPath != "") {
            filesys.prjs.refreshPrjFolder(this.opeParam);
            if (!ensureTerminalExists("StartFPGA")) {
                this.StartFPGA = vscode.window.createTerminal({ name: 'StartFPGA' });
                // vscode.window.registerTerminalLinkProvider({
                //     provideTerminalLinks: (context, token)=> {
                //         if (context.line.indexOf("Exiting Vivado") != -1) {
                //             vscode.window.showInformationMessage(context.line);
                //         }
                //     },
                //     handleTerminalLink: (link)=> {
                //       vscode.window.showInformationMessage(`Link activated (data=${link.data})`);
                //     }
                // });
            }
            if (!this.currentState) {			
                this.StartFPGA.show(true);
                if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                    if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {					
                        this.StartFPGA.sendText(`${this.vivadoPath} -mode tcl -s ${this.opeParam.rootPath}/../resources/tool/Xilinx/Script/Vivado/Run.tcl -notrace -nolog -nojournal`);
                    }
                }
                this.currentState = true;
            }
        } else {
            let prjFileList = filesys.files.pickFile(this.opeParam.workspacePath, ".xpr");
            if (prjFileList.length != 0) {
                let command = `${this.vivadoPath} -mode gui -s ${this.opeParam.workspacePath}/${prjFileList[0]} -notrace -nolog -nojournal`
                child.exec(command, (error, stdout, stderr) => {
                    if (error !== null) {
                        vscode.window.showErrorMessage(stderr);
                    } else {
                        vscode.window.showInformationMessage("GUI open successfully")
                    }
                });
            }
        }
    }
    Refresh() {
        if (this.currentState == true) {			
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`refresh`);
		}
    }
    Simulation() {
        if (this.currentState == true){
            this.currentState = false;
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`sim`);
		}
    }
    Build() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`build`);
		}
    }
    Synth() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`synth`);
		}
    }
    Impl() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`impl`);
		}
    }
    Gen_Bit() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`bits`);
		}
    }
    Program() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`program`);
		}
    }
    GUI() {
        if (this.currentState == true){
			this.currentState = false;
			this.StartFPGA.sendText(`gui`);
			this.StartFPGA.hide();
        } else {
            filesys.prjs.refreshPrjFolder(this.opeParam);
            if (!ensureTerminalExists("StartFPGA")) {
                this.StartFPGA = vscode.window.createTerminal({ name: 'StartFPGA' });
            }	
            this.StartFPGA.show(true);
            this.currentState = false;
            if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {					
                    this.StartFPGA.sendText(`${this.vivadoPath} -mode gui -s ${this.opeParam.rootPath}/../resources/tool/Xilinx/Script/Vivado/Run.tcl -notrace -nolog -nojournal`);
                }
            }
        }
    }
    Exit() {
        this.currentState = false;
		this.StartFPGA.show(true);
		this.StartFPGA.sendText(`exit`);
		xilinx.move_bd_IP(this.opeParam);
    }
    setSrcTop(uri, HDLparam) {
        parser.utils.selectCurrentFileModule(HDLparam, uri.fsPath).then((selecModule) => {
            if (selecModule == null) {
                return null;
            }
            this.opeParam.srcTopModule = {
                name : selecModule.moduleName,
                path : selecModule.modulePath,
            }
            if (this.currentState == true) {	
                if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                    if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {	
                        let command = `set_property top ${selecModule.moduleName} [current_fileset]`;
                        this.StartFPGA.sendText(command);
                    }
                }		
            }
        })
    }
    setSimTop(uri, HDLparam) {
        parser.utils.selectCurrentFileModule(HDLparam, uri.fsPath).then((selecModule) => {
            if (selecModule == null) {
                return null;
            }
            this.opeParam.tbFilePath = editor.document.fileName.replace(/\\/g,"\/");
            this.opeParam.simTopModule = {
                name : selecModule.moduleName,
                path : selecModule.modulePath,
            }
            if (this.currentState == true) {	
                if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                    if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {	
                        let command = `set_property top ${selecModule.moduleName} [get_filesets sim_1]`;
                        this.StartFPGA.sendText(command);
                    }
                }		
            }
        })
    }
}
exports.fpgaRegister = fpgaRegister;

class synthNetlist {
    constructor(context, opeParam) {
        this.panel = undefined;
        this.context  = context;
        this.opeParam = opeParam;
    }
    open_viewer() {
        return __awaiter(this, void 0, void 0, function* () {
            this.create_viewer();
        });
    }
    create_viewer() {
        return __awaiter(this, void 0, void 0, function* () {
            // Create panel
            this.panel = vscode.window.createWebviewPanel(
                'netlist_viewer', 
                'Schematic viewer', 
                vscode.ViewColumn.Two, 
                {
                    enableScripts: true
                }
            );
            this.panel.onDidDispose(() => {
                // When the panel is closed, cancel any future updates to the webview content
                this.panel = undefined;
            }, null, this.context.subscriptions);
            // Handle messages from the webview
            this.panel.webview.onDidReceiveMessage(message => {
                switch (message.command) {
                    case 'export':
                        this.export_as(message.type, message.svg);
                        return;
                    case 'html_loaded':
                        this.update_viewer_last_code();
                        return;
                }
            }, undefined, this.context.subscriptions);
            let previewHtml = this.getWebviewContent(this.context);
            this.panel.webview.html = previewHtml;
            let code = yield this.get_code(undefined);
            if (code !== undefined) {
                this.code = code;
            }
        });
    }
    show_export_message(path_full) {
        vscode.window.showInformationMessage(`Schematic saved in ${path_full}`);
    }
    export_as(type, svg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (type === "svg") {
                let filter = { 'svg': ['svg'] };
                vscode.window.showSaveDialog({ filters: filter }).then(fileInfos => {
                    if ((fileInfos === null || fileInfos === void 0 ? void 0 : fileInfos.path) !== undefined) {
                        let path_full = this.normalize_path(fileInfos === null || fileInfos === void 0 ? void 0 : fileInfos.path);
                        fs.writeFileSync(path_full, svg);
                        this.show_export_message(path_full);
                    }
                });
            }
            else {
                console.log("Error export documentation.");
            }
        });
    }
    normalize_path(path) {
        if (path[0] === '/' && require('os').platform() === 'win32') {
            return path.substring(1);
        }
        else {
            return path;
        }
    }
    send_code(code) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let filename = this.document.fileName;
            if (code !== undefined) {
                yield ((_a = this.panel) === null || _a === void 0 ? void 0 : _a.webview.postMessage({ command: "update", code: code, filename: filename }));
            }
        });
    }
    get_code(document_trigger) {
        return __awaiter(this, void 0, void 0, function* () {
            let document = document_trigger;
            if (document_trigger === undefined) {
                let active_editor = vscode.window.activeTextEditor;
                if (!active_editor) {
                    return; // no editor
                }
                document = active_editor.document;
            }
            let language_id = document.languageId;
            let code = document.getText();
            if (language_id !== "verilog" && language_id !== 'systemverilog') {
                return;
            }
            this.document = document;
            return code;
        });
    }
    update_viewer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.panel !== undefined) {
                let code = yield this.get_code(undefined);
                this.code = code;
                yield this.send_code(code);
            }
        });
    }
    update_viewer_last_code() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.panel !== undefined) {
                yield this.send_code(this.code);
            }
        });
    }
    update_visible_viewer(e) {
        return __awaiter(this, void 0, void 0, function* () {
            if (e.length !== 1) {
                return;
            }
            let document = e[0].document;
            if (this.panel !== undefined) {
                let code = yield this.get_code(document);
                this.code = code;
                yield this.send_code(code);
            }
        });
    }
    getWebviewContent() {
        const resource_path = fspath.dirname(`${this.opeParam.rootPath}`) + fspath.sep + 'resources' + fspath.sep + 'synth' + fspath.sep + 'netlist_viewer.html';
        const dir_path = fspath.dirname(resource_path);
        let html = fs.readFileSync(resource_path, 'utf-8');
        html = html.replace(/(<link.+?href="|<script.+?src="|<img.+?src=")(.+?)"/g, (m, $1, $2) => {
            return $1 + vscode.Uri.file(fspath.resolve(dir_path, $2)).with({ scheme: 'vscode-resource' }).toString() + '"';
        });
        return html;
    }
}
exports.synthNetlist = synthNetlist;

function ensureTerminalExists(name) {
    let Exists_flag = false
    vscode.window.terminals.forEach(element => {
        if (element.name == name) {
            Exists_flag = true
        }
    });
    return Exists_flag
}