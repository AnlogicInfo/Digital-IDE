"use strict";

const fs      = require("fs");
const fspath  = require("path");
const vscode  = require("vscode");
const child   = require("child_process");
const filesys = require("HDLfilesys");
const parser  = require("HDLparser");

const xilinx  = require("./xilinx");

class fpgaRegister {
    constructor (context, opeParam) {
        this.StartFPGA = null;
        this.currentState = false;

        this.context  = context;
        this.opeParam = opeParam;
        this.setting  = vscode.workspace.getConfiguration();
        this.getConfig();
        var _this = this;
        vscode.workspace.onDidChangeConfiguration(function () {
            _this.getConfig();
        });
        vscode.window.onDidCloseTerminal(function (terminal) {
            if (terminal.name == "StartFPGA") {
                _this.currentState = false;
                xilinx.move_bd_IP(opeParam);
                vscode.window.showInformationMessage("Terminal Closed, name: " + terminal.name);
            }
        });
        // vscode.window.registerTerminalLinkProvider({
        //     provideTerminalLinks: (context, token)=> {
        //         if (context.line.indexOf("Exiting Vivado") != -1) {
        //             vscode.window.showInformationMessage(context.line);
        //         }
        //     },
        //     handleTerminalLink: (link)=> {
        //       vscode.window.showInformationMessage(`Link activated (data=${link.data})`);
        //     }
        // });
    }
    getConfig() {
        this.xilinxInstallPath = this.setting.get('TOOL.vivado.install.path');
        this.vivadoPath = "vivado";
        if (this.xilinxInstallPath != "") {
            this.vivadoPath = this.xilinxInstallPath.replace("//","/").replace(/\\/g,"\/");
            if (this.opeParam.os == "win32") {
                this.vivadoPath = this.vivadoPath + "vivado.bat";
            }
        }
    }
    Launch() {
        if (this.opeParam.propertyPath != "") {
            filesys.prjs.refreshPrjFolder(this.opeParam);
            if (!ensureTerminalExists("StartFPGA")) {
                this.StartFPGA = vscode.window.createTerminal({ name: 'StartFPGA' });
            }
            if (!this.currentState) {			
                this.StartFPGA.show(true);
                if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                    if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {					
                        this.StartFPGA.sendText(`${this.vivadoPath} -mode tcl -s ${this.opeParam.rootPath}/../resources/tool/Xilinx/Script/Vivado/Run.tcl -notrace -nolog -nojournal`);
                    }
                }
                this.currentState = true;
            }
        } else {
            let prjFileList = filesys.files.pickFile(this.opeParam.workspacePath, ".xpr");
            if (prjFileList.length != 0) {
                let command = `${this.vivadoPath} -mode gui -s ${this.opeParam.workspacePath}/${prjFileList[0]} -notrace -nolog -nojournal`
                child.exec(command, (error, stdout, stderr) => {
                    if (error !== null) {
                        vscode.window.showErrorMessage(stderr);
                    } else {
                        vscode.window.showInformationMessage("GUI open successfully")
                    }
                });
            }
        }
    }
    Refresh() {
        if (this.currentState == true) {			
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`refresh`);
		}
    }
    Simulation() {
        if (this.currentState == true){
            this.currentState = false;
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`sim`);
		}
    }
    Build() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`build`);
		}
    }
    Synth() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`synth`);
		}
    }
    Impl() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`impl`);
		}
    }
    Gen_Bit() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`bits`);
		}
    }
    Program() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`program`);
		}
    }
    GUI() {
        if (this.currentState == true){
			this.currentState = false;
			this.StartFPGA.sendText(`gui`);
			this.StartFPGA.hide();
        } else {
            filesys.prjs.refreshPrjFolder(this.opeParam);
            if (!ensureTerminalExists("StartFPGA")) {
                this.StartFPGA = vscode.window.createTerminal({ name: 'StartFPGA' });
            }	
            this.StartFPGA.show(true);
            this.currentState = false;
            if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {					
                    this.StartFPGA.sendText(`${this.vivadoPath} -mode gui -s ${this.opeParam.rootPath}/../resources/tool/Xilinx/Script/Vivado/Run.tcl -notrace -nolog -nojournal`);
                }
            }
        }
    }
    Exit() {
        this.currentState = false;
		this.StartFPGA.show(true);
		this.StartFPGA.sendText(`exit`);
		xilinx.move_bd_IP(this.opeParam);
    }
    setSrcTop(uri, HDLparam, fileExplorer) {
        parser.utils.selectCurrentFileModule(HDLparam, uri.fsPath).then((selecModule) => {
            if (selecModule == null) {
                return null;
            }
            this.opeParam.srcTopModule = {
                name : selecModule.moduleName,
                path : selecModule.modulePath,
            }
            fileExplorer.treeDataProvider.refresh();
            if (this.currentState == true) {	
                if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                    if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {	
                        let command = `set_property top ${selecModule.moduleName} [current_fileset]`;
                        this.StartFPGA.sendText(command);
                    }
                }		
            }
        })
    }
    setSimTop(uri, HDLparam, fileExplorer) {
        parser.utils.selectCurrentFileModule(HDLparam, uri.fsPath).then((selecModule) => {
            if (selecModule == null) {
                return null;
            }
            this.opeParam.tbFilePath = selecModule.modulePath;
            this.opeParam.simTopModule = {
                name : selecModule.moduleName,
                path : selecModule.modulePath,
            }
            fileExplorer.treeDataProvider.refresh();
            if (this.currentState == true) {	
                if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                    if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {	
                        let command = `set_property top ${selecModule.moduleName} [get_filesets sim_1]`;
                        this.StartFPGA.sendText(command);
                    }
                }		
            }
        })
    }
}
exports.fpgaRegister = fpgaRegister;

class synthNetlist {
    constructor(context, opeParam, HDLparam) {
        this.panel    = undefined;
        this.context  = context;
        this.opeParam = opeParam;
        this.HDLparam = HDLparam;
    }

    open_viewer(uri) {
        let docPath = uri.fsPath.replace(/\\/g,"\/").replace("//","/");
        if (filesys.files.isHasAttr(uri, "type")) {
            if (uri.type != null) {
                this.create_viewer({
                    name:uri.type,
                    path:docPath
                });
            } else {
                vscode.window.showErrorMessage("ERROR: uri.type is null");
            }
        } else {
            // 获取当前文件的模块名和模块数 选择要仿真的模块
            parser.utils.selectCurrentFileModule(this.HDLparam, docPath).then((selectModule) => {
                if (selectModule != null) {
                    this.create_viewer({
                        name:selectModule.moduleName,
                        path:selectModule.modulePath
                    });
                }
            });      
        }
    }

    create_viewer() {
        // Create panel
        this.panel = vscode.window.createWebviewPanel(
            'netlist_viewer', 
            'Schematic viewer', 
            vscode.ViewColumn.One, 
            {
                enableScripts: true,
                retainContextWhenHidden: true
            }
        );
        this.panel.onDidDispose(() => {
            // When the panel is closed, cancel any future updates to the webview content
            this.panel = undefined;
        }, null, this.context.subscriptions);
        // Handle messages from the webview
        this.panel.webview.onDidReceiveMessage(message => {
            switch (message.command) {
                case 'export':
                    this.export_as(message.type, message.svg);
                    return;
            }
        }, undefined, this.context.subscriptions);
        let previewHtml = this.getWebviewContent();
        this.panel.webview.html = previewHtml;
    }

    get_prjInfo(module) {
        let synthInstList = [];
        let synthIncludeList = [];
        let dependenceFilePathList = parser.utils.getModuleDependence(this.HDLparam, module, "all");
        let len = dependenceFilePathList.inst.length;
        for (let index = 0; index < len; index++) {
            const instFilePath = dependenceFilePathList.inst[index];
            const instFileText = fs.readFileSync(instFilePath, "utf-8");
            synthInstList.push({
                path: instFilePath.replace(':/', '/'),
                text: instFileText
            })
        }
        len = dependenceFilePathList.include.length;
        for (let index = 0; index < len; index++) {
            const includeFilePath = dependenceFilePathList.include[index];
            const includeFileText = fs.readFileSync(includeFilePath, "utf-8");
            synthIncludeList.push({
                path: includeFilePath.replace(':/', '/'),
                text: includeFileText
            })
        }
        module.text = fs.readFileSync(module.path, "utf-8");
        module.path = module.path.replace(':/', '/');
        return {
            module:module,
            instInfo:synthInstList,
            includeInfo:synthIncludeList
        };
    }

    send_code(synthPrjInfo) {
        if (this.panel == undefined) {
            create_viewer();
        }
        this.panel.webview.postMessage({ command: "update", synthPrjInfo: synthPrjInfo});
    }

    getWebviewContent() {
        const src_path  = `${this.opeParam.rootPath}/../resources/synth`;
        const html_path = src_path + '/netlist_viewer.html';
        let html = fs.readFileSync(html_path, 'utf-8');
        html = html.replace(/(<link.+?href="|<script.+?src="|<img.+?src=")(.+?)"/g, (m, $1, $2) => {
            return $1 + vscode.Uri.file(fspath.resolve(src_path, $2)).with({ scheme: 'vscode-resource' }).toString() + '"';
        });
        return html;
    }
    
    export_as(type, svg) {
        if (type === "svg") {
            let filter = { 'svg': ['svg'] };
            vscode.window.showSaveDialog({ filters: filter }).then(fileInfos => {
                let path_full = fileInfos === null || fileInfos === void 0 ? void 0 : fileInfos.path;
                if (path_full !== undefined) {
                    if (path_full[0] === '/' && require('os').platform() === 'win32') {
                        path_full = path_full.substring(1);
                    }
                    fs.writeFileSync(path_full, svg);
                    vscode.window.showInformationMessage(`Schematic saved in ${path_full}`);
                }
            });
        } else {
            console.log("Error export documentation.");
        }
    }

    refresh_prj(uri) {
        let docPath = uri.fsPath.replace(/\\/g,"\/").replace("//","/");
        if (filesys.files.isHasAttr(uri, "type")) {
            if (uri.type != null) {
                let synthPrjInfo = this.get_prjInfo({
                    name:uri.type,
                    path:docPath
                });
                if (synthPrjInfo !== null) {
                    this.send_code(synthPrjInfo);
                }
            } else {
                vscode.window.showErrorMessage("ERROR: uri.type is null");
            }
        } else {
            // 获取当前文件的模块名和模块数 选择要仿真的模块
            parser.utils.selectCurrentFileModule(this.HDLparam, docPath).then((selectModule) => {
                if (selectModule != null) {
                    let synthPrjInfo = this.get_prjInfo({
                        name:selectModule.moduleName,
                        path:selectModule.modulePath
                    });
                    if (synthPrjInfo !== null) {
                        this.send_code(synthPrjInfo);
                    }
                }
            });      
        }
    }
}
exports.synthNetlist = synthNetlist;

function ensureTerminalExists(name) {
    let Exists_flag = false
    vscode.window.terminals.forEach(element => {
        if (element.name == name) {
            Exists_flag = true
        }
    });
    return Exists_flag
}