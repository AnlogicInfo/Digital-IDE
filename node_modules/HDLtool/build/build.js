"use strict";

const fs      = require("fs");
const fspath  = require("path");
const vscode  = require("vscode");
const child   = require("child_process");
const filesys = require("HDLfilesys");
const parser  = require("HDLparser");
const kernel  = require("HDLkernel");

const xilinx  = require("./xilinx");

class hardwareRegister {
    constructor (context, opeParam) {

        this.HardWare = null;
        this.currentState = false;

        this.context   = context;
        this.opeParam  = opeParam;
        this.prjStruct = {};

        this.setting  = vscode.workspace.getConfiguration();
        this.getConfig();
        var _this = this;
        vscode.workspace.onDidChangeConfiguration(function () {
            _this.getConfig();
        });

        vscode.window.onDidCloseTerminal(function (terminal) {
            if (terminal.name == "HardWare") {
                _this.currentState = false;
                xilinx.move_bd_IP(opeParam);
                vscode.window.showInformationMessage("Terminal Closed, name: " + terminal.name);
            }
        });

        // vscode.window.registerTerminalLinkProvider({
        //     provideTerminalLinks: (context, token)=> {
        //         if (context.line.indexOf("Exiting Vivado") != -1) {
        //             vscode.window.showInformationMessage(context.line);
        //         }
        //     },
        //     handleTerminalLink: (link)=> {
        //       vscode.window.showInformationMessage(`Link activated (data=${link.data})`);
        //     }
        // });
    }
    getConfig() {
        this.xilinxInstallPath = this.setting.get('TOOL.vivado.install.path');
        this.vivadoPath = "vivado";
        if (this.xilinxInstallPath != "") {
            this.vivadoPath = this.xilinxInstallPath.replace("//","/").replace(/\\/g,"\/");
            if (this.opeParam.os == "win32") {
                this.vivadoPath = this.vivadoPath + "vivado.bat";
            }
        }
    }
    
    Launch() {
        if (this.opeParam.propertyPath != "") {
            filesys.prjs.refreshPrjFolder(this.opeParam);
            if (!ensureTerminalExists("HardWare")) {
                this.HardWare = vscode.window.createTerminal({ name: 'HardWare' });
            }
            if (!this.currentState) {			
                this.HardWare.show(true);
                if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                    if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {					
                        this.HardWare.sendText(`${this.vivadoPath} -mode tcl -s ${this.opeParam.rootPath}/../resources/tool/Xilinx/Script/Vivado/Run.tcl -notrace -nolog -nojournal`);
                    }
                }
                this.currentState = true;
            }
        } else {
            let prjFileList = filesys.files.pickFile(this.opeParam.workspacePath, ".xpr");
            if (prjFileList.length != 0) {
                let command = `${this.vivadoPath} -mode gui -s ${this.opeParam.workspacePath}/${prjFileList[0]} -notrace -nolog -nojournal`
                child.exec(command, (error, stdout, stderr) => {
                    if (error !== null) {
                        vscode.window.showErrorMessage(stderr);
                    } else {
                        vscode.window.showInformationMessage("GUI open successfully")
                    }
                });
            }
        }
    }
    Refresh() {
        if (this.currentState == true) {			
			this.HardWare.show(true);
			this.HardWare.sendText(`refresh`);
		}
    }
    Simulation() {
        if (this.currentState == true){
            this.currentState = false;
			this.HardWare.show(true);
			this.HardWare.sendText(`sim`);
		}
    }
    Build() {
        if (this.currentState == true){
			this.HardWare.show(true);
			this.HardWare.sendText(`build`);
		}
    }
    Synth() {
        if (this.currentState == true){
			this.HardWare.show(true);
			this.HardWare.sendText(`synth`);
		}
    }
    Impl() {
        if (this.currentState == true){
			this.HardWare.show(true);
			this.HardWare.sendText(`impl`);
		}
    }
    Gen_Bit() {
        if (this.currentState == true){
			this.HardWare.show(true);
			this.HardWare.sendText(`bits`);
		}
    }
    Program() {
        if (this.currentState == true){
			this.HardWare.show(true);
			this.HardWare.sendText(`program`);
		}
    }
    GUI() {
        if (this.currentState == true){
			this.currentState = false;
			this.HardWare.sendText(`gui`);
			this.HardWare.hide();
        } else {
            filesys.prjs.refreshPrjFolder(this.opeParam);
            if (!ensureTerminalExists("HardWare")) {
                this.HardWare = vscode.window.createTerminal({ name: 'HardWare' });
            }	
            this.HardWare.show(true);
            this.currentState = false;
            if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {					
                    this.HardWare.sendText(`${this.vivadoPath} -mode gui -s ${this.opeParam.rootPath}/../resources/tool/Xilinx/Script/Vivado/Run.tcl -notrace -nolog -nojournal`);
                }
            }
        }
    }
    Exit() {
        this.currentState = false;
		this.HardWare.show(true);
		this.HardWare.sendText(`exit`);
		xilinx.move_bd_IP(this.opeParam);
    }
    setSrcTop(uri, HDLparam, fileExplorer) {
        parser.utils.selectCurrentFileModule(HDLparam, uri.fsPath).then((selecModule) => {
            if (selecModule == null) {
                return null;
            }
            this.opeParam.srcTopModule = {
                name : selecModule.moduleName,
                path : selecModule.modulePath,
            }
            fileExplorer.treeDataProvider.refresh();
            if (this.currentState == true) {	
                if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                    if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {	
                        let command = `set_property top ${selecModule.moduleName} [current_fileset]`;
                        this.HardWare.sendText(command);
                    }
                }		
            }
        })
    }
    setSimTop(uri, HDLparam, fileExplorer) {
        parser.utils.selectCurrentFileModule(HDLparam, uri.fsPath).then((selecModule) => {
            if (selecModule == null) {
                return null;
            }
            this.opeParam.tbFilePath = selecModule.modulePath;
            this.opeParam.simTopModule = {
                name : selecModule.moduleName,
                path : selecModule.modulePath,
            }
            fileExplorer.treeDataProvider.refresh();
            if (this.currentState == true) {	
                if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                    if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {	
                        let command = `set_property top ${selecModule.moduleName} [get_filesets sim_1]`;
                        this.HardWare.sendText(command);
                    }
                }		
            }
        })
    }
}
exports.hardwareRegister = hardwareRegister;

function ensureTerminalExists(name) {
    let Exists_flag = false
    vscode.window.terminals.forEach(element => {
        if (element.name == name) {
            Exists_flag = true
        }
    });
    return Exists_flag
}