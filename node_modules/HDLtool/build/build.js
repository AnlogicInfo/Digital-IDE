"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const fs      = require("fs");
const fspath  = require("path");
const vscode  = require("vscode");
const child   = require("child_process");
const filesys = require("HDLfilesys");
const parser  = require("HDLparser");

const xilinx  = require("./xilinx");

class fpgaRegister {
    constructor (context, HDLparam, opeParam) {
        this.StartFPGA = null;
        this.currentState = false;

        this.context  = context;
        this.opeParam = opeParam;
        this.HDLparam = HDLparam;
        var _this = this;
        this.prjParam = filesys.prjs.refreshPrjInfo(this.opeParam);
        vscode.window.onDidCloseTerminal(function (terminal) {
            if (terminal.name == "StartFPGA") {
                _this.currentState = false;
                _this.xilinx.xclean(_this.opeParam.workspacePath,"none");
                _this.xilinx.move_xbd_xIP(_this.opeParam.workspacePath,opeParam.propertyPath);
                vscode.window.showInformationMessage("Terminal Closed, name: " + terminal.name);
            }
        });

        this.Register(this.context);
    }
    launch() {
        if (opeParam.propertyPath != "") {
            this.prjParam = filesys.prjs.refreshPrjInfo(this.opeParam);
            filesys.prjs.refreshPrjFolder(this.opeParam);
            if (!ensureTerminalExists("StartFPGA")) {
                this.StartFPGA = vscode.window.createTerminal({ name: 'StartFPGA' });
            }
            if (!this.currentState) {			
                this.StartFPGA.show(true);
                if (this.prjParam.FPGA_VERSION == "xilinx") {					
                    this.StartFPGA.sendText(`vivado -mode tcl -s ${opeParam.rootPath}/../resources/tool/Xilinx/Script/Xilinx_TCL/Vivado/Run.tcl -notrace -nolog -nojournal`);
                }
                this.currentState = true;
            }
        }
    }
    refresh() {
        if (this.currentState == true) {			
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`update`);
		}
    }
    Top() {
        if (this.currentState == true) {			
			if (this.prjParam.FPGA_VERSION == "xilinx") {	
				let editor = vscode.window.activeTextEditor;
				if (!editor) {
					return;
				}
                this.HDLparam.forEach(element => {
                    if ( element.modulePath == editor.document.fileName ) {
                        moduleNameList.push(element.moduleName);
                    }
                });
				if (moduleNameList == null) {
					vscode.window.showWarningMessage("there is no module here")
				} else {
					if (moduleNameList.length > 1) {
						vscode.window.showQuickPick(moduleNameList).then(selection => {
							if (!selection) {
								return;
							}
							this.StartFPGA.sendText(`set_property top ${selection} [current_fileset]`);
						});
					} else {
						this.StartFPGA.sendText(`set_property top ${moduleNameList[0]} [current_fileset]`);
					}
				}
			}
		}
    }
    Build() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`build`);
		}
    }
    Synth() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`synth`);
		}
    }
    Impl() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`impl`);
		}
    }
    Gen_Bit() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`bits`);
		}
    }
    Program() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`program`);
		}
    }
    GUI() {
        if (this.currentState == true){
			this.currentState = false;
			this.StartFPGA.sendText(`gui`);
			this.StartFPGA.hide();
        } else {
            this.prjParam = filesys.prjs.refreshPrjInfo(this.opeParam);
            filesys.prjs.refreshPrjFolder(this.opeParam);
            if (!ensureTerminalExists("StartFPGA")) {
                this.StartFPGA = vscode.window.createTerminal({ name: 'StartFPGA' });
            }	
            this.StartFPGA.show(true);
            this.currentState = false;
            if (this.prjParam.FPGA_VERSION == "xilinx") {					
                this.StartFPGA.sendText(`vivado -mode gui -s ${opeParam.rootPath}/../resources/tool/Xilinx/Script/Xilinx_TCL/Vivado/Run.tcl -notrace -nolog -nojournal`);
            }
        }
    }
    Exit() {
        this.currentState = false;
		this.StartFPGA.show(true);
		this.StartFPGA.sendText(`exit`);
		xilinx.move_bd_IP(this.opeParam);
    }
    Register(context) {
        context.subscriptions.push(vscode.commands.registerCommand('FPGA.Launch', () => {
            this.Launch();
        }));
        context.subscriptions.push(vscode.commands.registerCommand('FPGA.Refresh', () => {
            this.refresh();
        }));
        context.subscriptions.push(vscode.commands.registerCommand('FPGA.Top', () => {
            this.Top();
        }));
        context.subscriptions.push(vscode.commands.registerCommand('FPGA.Build', () => {
            this.Build();
        }));
        context.subscriptions.push(vscode.commands.registerCommand('FPGA.Synth', () => {
            this.Synth();
        }));
        context.subscriptions.push(vscode.commands.registerCommand('FPGA.Impl', () => {
            this.Impl();
        }));
        context.subscriptions.push(vscode.commands.registerCommand('FPGA.Gen_Bit', () => {
            this.Gen_Bit();
        }));
        context.subscriptions.push(vscode.commands.registerCommand('FPGA.Program', () => {
            this.Program();
        }));
        context.subscriptions.push(vscode.commands.registerCommand('FPGA.GUI', () => {
            this.GUI();
        }));
        context.subscriptions.push(vscode.commands.registerCommand('FPGA.exit', () => {
            this.Exit();
        }));
    }
}
exports.fpgaRegister = fpgaRegister;

class synthNetlist {
    constructor(context, opeParam) {
        this.panel = undefined;
        this.context  = context;
        this.opeParam = opeParam;
    }
    open_viewer() {
        return __awaiter(this, void 0, void 0, function* () {
            this.create_viewer();
        });
    }
    create_viewer() {
        return __awaiter(this, void 0, void 0, function* () {
            // Create panel
            this.panel = vscode.window.createWebviewPanel('netlist_viewer', 'Schematic viewer', vscode.ViewColumn.Two, {
                enableScripts: true
            });
            this.panel.onDidDispose(() => {
                // When the panel is closed, cancel any future updates to the webview content
                this.panel = undefined;
            }, null, this.context.subscriptions);
            // Handle messages from the webview
            this.panel.webview.onDidReceiveMessage(message => {
                switch (message.command) {
                    case 'export':
                        this.export_as(message.type, message.svg);
                        return;
                    case 'html_loaded':
                        this.update_viewer_last_code();
                        return;
                }
            }, undefined, this.context.subscriptions);
            let previewHtml = this.getWebviewContent(this.context);
            this.panel.webview.html = previewHtml;
            let code = yield this.get_code(undefined);
            if (code !== undefined) {
                this.code = code;
            }
        });
    }
    show_export_message(path_full) {
        vscode.window.showInformationMessage(`Schematic saved in ${path_full} ðŸ˜Š`);
    }
    export_as(type, svg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (type === "svg") {
                let filter = { 'svg': ['svg'] };
                vscode.window.showSaveDialog({ filters: filter }).then(fileInfos => {
                    if ((fileInfos === null || fileInfos === void 0 ? void 0 : fileInfos.path) !== undefined) {
                        let path_full = this.normalize_path(fileInfos === null || fileInfos === void 0 ? void 0 : fileInfos.path);
                        fs.writeFileSync(path_full, svg);
                        this.show_export_message(path_full);
                    }
                });
            }
            else {
                console.log("Error export documentation.");
            }
        });
    }
    normalize_path(path) {
        if (path[0] === '/' && require('os').platform() === 'win32') {
            return path.substring(1);
        }
        else {
            return path;
        }
    }
    send_code(code) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let filename = this.document.fileName;
            if (code !== undefined) {
                yield ((_a = this.panel) === null || _a === void 0 ? void 0 : _a.webview.postMessage({ command: "update", code: code, filename: filename }));
            }
        });
    }
    get_code(document_trigger) {
        return __awaiter(this, void 0, void 0, function* () {
            let document = document_trigger;
            if (document_trigger === undefined) {
                let active_editor = vscode.window.activeTextEditor;
                if (!active_editor) {
                    return; // no editor
                }
                document = active_editor.document;
            }
            let language_id = document.languageId;
            let code = document.getText();
            if (language_id !== "verilog" && language_id !== 'systemverilog') {
                return;
            }
            this.document = document;
            return code;
        });
    }
    update_viewer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.panel !== undefined) {
                let code = yield this.get_code(undefined);
                this.code = code;
                yield this.send_code(code);
            }
        });
    }
    update_viewer_last_code() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.panel !== undefined) {
                yield this.send_code(this.code);
            }
        });
    }
    update_visible_viewer(e) {
        return __awaiter(this, void 0, void 0, function* () {
            if (e.length !== 1) {
                return;
            }
            let document = e[0].document;
            if (this.panel !== undefined) {
                let code = yield this.get_code(document);
                this.code = code;
                yield this.send_code(code);
            }
        });
    }
    getWebviewContent() {
        const resource_path = fspath.dirname(`${this.opeParam.rootPath}`) + fspath.sep + 'resources' + fspath.sep + 'synth' + fspath.sep + 'netlist_viewer.html';
        const dir_path = fspath.dirname(resource_path);
        let html = fs.readFileSync(resource_path, 'utf-8');
        html = html.replace(/(<link.+?href="|<script.+?src="|<img.+?src=")(.+?)"/g, (m, $1, $2) => {
            return $1 + vscode.Uri.file(fspath.resolve(dir_path, $2)).with({ scheme: 'vscode-resource' }).toString() + '"';
        });
        return html;
    }
}
exports.synthNetlist = synthNetlist;

function ensureTerminalExists(name) {
    let Exists_flag = false
    vscode.window.terminals.forEach(element => {
        if (element.name == name) {
            Exists_flag = true
        }
    });
    return Exists_flag
}