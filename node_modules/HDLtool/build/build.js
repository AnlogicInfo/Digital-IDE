"use strict";

const fs      = require("fs");
const fspath  = require("path");
const vscode  = require("vscode");
const child   = require("child_process");
const filesys = require("HDLfilesys");
const parser  = require("HDLparser");

const xilinx  = require("./xilinx");

class fpgaRegister {
    constructor (context, opeParam) {
        this.StartFPGA = null;
        this.currentState = false;

        this.context  = context;
        this.opeParam = opeParam;
        this.setting  = vscode.workspace.getConfiguration();
        this.getConfig();
        vscode.workspace.onDidChangeConfiguration(function () {
            this.getConfig();
        });
        var _this = this;
        vscode.window.onDidCloseTerminal(function (terminal) {
            if (terminal.name == "StartFPGA") {
                _this.currentState = false;
                xilinx.move_bd_IP(opeParam);
                vscode.window.showInformationMessage("Terminal Closed, name: " + terminal.name);
            }
        });
        // vscode.window.registerTerminalLinkProvider({
        //     provideTerminalLinks: (context, token)=> {
        //         if (context.line.indexOf("Exiting Vivado") != -1) {
        //             vscode.window.showInformationMessage(context.line);
        //         }
        //     },
        //     handleTerminalLink: (link)=> {
        //       vscode.window.showInformationMessage(`Link activated (data=${link.data})`);
        //     }
        // });
    }
    getConfig() {
        this.xilinxInstallPath = this.setting.get('TOOL.vivado.install.path');
        this.vivadoPath = "vivado";
        if (this.xilinxInstallPath != "") {
            this.vivadoPath = this.xilinxInstallPath.replace("//","/").replace(/\\/g,"\/");
            if (this.opeParam.os == "win32") {
                this.vivadoPath = this.vivadoPath + "vivado.bat";
            }
        }
    }
    Launch() {
        if (this.opeParam.propertyPath != "") {
            filesys.prjs.refreshPrjFolder(this.opeParam);
            if (!ensureTerminalExists("StartFPGA")) {
                this.StartFPGA = vscode.window.createTerminal({ name: 'StartFPGA' });
            }
            if (!this.currentState) {			
                this.StartFPGA.show(true);
                if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                    if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {					
                        this.StartFPGA.sendText(`${this.vivadoPath} -mode tcl -s ${this.opeParam.rootPath}/../resources/tool/Xilinx/Script/Vivado/Run.tcl -notrace -nolog -nojournal`);
                    }
                }
                this.currentState = true;
            }
        } else {
            let prjFileList = filesys.files.pickFile(this.opeParam.workspacePath, ".xpr");
            if (prjFileList.length != 0) {
                let command = `${this.vivadoPath} -mode gui -s ${this.opeParam.workspacePath}/${prjFileList[0]} -notrace -nolog -nojournal`
                child.exec(command, (error, stdout, stderr) => {
                    if (error !== null) {
                        vscode.window.showErrorMessage(stderr);
                    } else {
                        vscode.window.showInformationMessage("GUI open successfully")
                    }
                });
            }
        }
    }
    Refresh() {
        if (this.currentState == true) {			
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`refresh`);
		}
    }
    Simulation() {
        if (this.currentState == true){
            this.currentState = false;
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`sim`);
		}
    }
    Build() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`build`);
		}
    }
    Synth() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`synth`);
		}
    }
    Impl() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`impl`);
		}
    }
    Gen_Bit() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`bits`);
		}
    }
    Program() {
        if (this.currentState == true){
			this.StartFPGA.show(true);
			this.StartFPGA.sendText(`program`);
		}
    }
    GUI() {
        if (this.currentState == true){
			this.currentState = false;
			this.StartFPGA.sendText(`gui`);
			this.StartFPGA.hide();
        } else {
            filesys.prjs.refreshPrjFolder(this.opeParam);
            if (!ensureTerminalExists("StartFPGA")) {
                this.StartFPGA = vscode.window.createTerminal({ name: 'StartFPGA' });
            }	
            this.StartFPGA.show(true);
            this.currentState = false;
            if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {					
                    this.StartFPGA.sendText(`${this.vivadoPath} -mode gui -s ${this.opeParam.rootPath}/../resources/tool/Xilinx/Script/Vivado/Run.tcl -notrace -nolog -nojournal`);
                }
            }
        }
    }
    Exit() {
        this.currentState = false;
		this.StartFPGA.show(true);
		this.StartFPGA.sendText(`exit`);
		xilinx.move_bd_IP(this.opeParam);
    }
    setSrcTop(uri, HDLparam, fileExplorer) {
        parser.utils.selectCurrentFileModule(HDLparam, uri.fsPath).then((selecModule) => {
            if (selecModule == null) {
                return null;
            }
            this.opeParam.srcTopModule = {
                name : selecModule.moduleName,
                path : selecModule.modulePath,
            }
            fileExplorer.treeDataProvider.refresh();
            if (this.currentState == true) {	
                if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                    if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {	
                        let command = `set_property top ${selecModule.moduleName} [current_fileset]`;
                        this.StartFPGA.sendText(command);
                    }
                }		
            }
        })
    }
    setSimTop(uri, HDLparam, fileExplorer) {
        parser.utils.selectCurrentFileModule(HDLparam, uri.fsPath).then((selecModule) => {
            if (selecModule == null) {
                return null;
            }
            this.opeParam.tbFilePath = selecModule.modulePath;
            this.opeParam.simTopModule = {
                name : selecModule.moduleName,
                path : selecModule.modulePath,
            }
            fileExplorer.treeDataProvider.refresh();
            if (this.currentState == true) {	
                if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                    if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {	
                        let command = `set_property top ${selecModule.moduleName} [get_filesets sim_1]`;
                        this.StartFPGA.sendText(command);
                    }
                }		
            }
        })
    }
}
exports.fpgaRegister = fpgaRegister;

class synthNetlist {
    constructor(context, opeParam) {
        this.panel = undefined;
        this.context  = context;
        this.opeParam = opeParam;
    }
    open_viewer() {
        this.create_viewer();
    }
    create_viewer() {
        // Create panel
        this.panel = vscode.window.createWebviewPanel(
            'netlist_viewer', 
            'Schematic viewer', 
            vscode.ViewColumn.Two, 
            {
                enableScripts: true
            }
        );
        this.panel.onDidDispose(() => {
            // When the panel is closed, cancel any future updates to the webview content
            this.panel = undefined;
        }, null, this.context.subscriptions);
        // Handle messages from the webview
        this.panel.webview.onDidReceiveMessage(message => {
            switch (message.command) {
                case 'export':
                    this.export_as(message.type, message.svg);
                    return;
                case 'html_loaded':
                    this.update_viewer_last_code();
                    return;
            }
        }, undefined, this.context.subscriptions);
        let previewHtml = this.getWebviewContent(this.context);
        this.panel.webview.html = previewHtml;
        let code = this.get_code(undefined);
        if (code !== undefined) {
            this.code = code;
        }
    }
    show_export_message(path_full) {
        vscode.window.showInformationMessage(`Schematic saved in ${path_full}`);
    }
    export_as(type, svg) {
        if (type === "svg") {
            let filter = { 'svg': ['svg'] };
            vscode.window.showSaveDialog({ filters: filter }).then(fileInfos => {
                if ((fileInfos === null || fileInfos === void 0 ? void 0 : fileInfos.path) !== undefined) {
                    let path_full = this.normalize_path(fileInfos === null || fileInfos === void 0 ? void 0 : fileInfos.path);
                    fs.writeFileSync(path_full, svg);
                    this.show_export_message(path_full);
                }
            });
        }
        else {
            console.log("Error export documentation.");
        }
    }
    normalize_path(path) {
        if (path[0] === '/' && require('os').platform() === 'win32') {
            return path.substring(1);
        }
        else {
            return path;
        }
    }
    send_code(code) {
        var _a;
        let filename = this.document.fileName;
        if (code !== undefined) {
            (
                (_a = this.panel) === null || _a === void 0 ? void 0 : _a.webview.postMessage({ command: "update", code: code, filename: filename })
            );
        }
    }
    get_code(document_trigger) {
        let document = document_trigger;
        if (document_trigger === undefined) {
            let active_editor = vscode.window.activeTextEditor;
            if (!active_editor) {
                return; // no editor
            }
            document = active_editor.document;
        }
        let language_id = document.languageId;
        let code = document.getText();
        if (language_id !== "verilog" && language_id !== 'systemverilog') {
            return;
        }
        this.document = document;
        return code;
    }
    update_viewer() {
        if (this.panel !== undefined) {
            let code = this.get_code(undefined);
            this.code = code;
            this.send_code(code);
        }
    }
    update_viewer_last_code() {
        if (this.panel !== undefined) {
            this.send_code(this.code);
        }
    }
    update_visible_viewer(e) {
        if (e.length !== 1) {
            return;
        }
        let document = e[0].document;
        if (this.panel !== undefined) {
            let code = this.get_code(document);
            this.code = code;
            this.send_code(code);
        }
    }
    getWebviewContent() {
        const resource_path = fspath.dirname(`${this.opeParam.rootPath}`) + fspath.sep + 'resources' + fspath.sep + 'synth' + fspath.sep + 'netlist_viewer.html';
        const dir_path = fspath.dirname(resource_path);
        let html = fs.readFileSync(resource_path, 'utf-8');
        html = html.replace(/(<link.+?href="|<script.+?src="|<img.+?src=")(.+?)"/g, (m, $1, $2) => {
            return $1 + vscode.Uri.file(fspath.resolve(dir_path, $2)).with({ scheme: 'vscode-resource' }).toString() + '"';
        });
        return html;
    }
}
exports.synthNetlist = synthNetlist;

function ensureTerminalExists(name) {
    let Exists_flag = false
    vscode.window.terminals.forEach(element => {
        if (element.name == name) {
            Exists_flag = true
        }
    });
    return Exists_flag
}