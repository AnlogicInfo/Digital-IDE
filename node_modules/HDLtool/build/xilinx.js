"use strict";

const fs     = require("fs");
const vscode = require("vscode");
const child  = require("child_process");

const filesys = require("HDLfilesys");

function Add_bd(opeParam) {
    let Property_param = this.json.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    let bd_folder = vscode.workspace.getConfiguration().get('PRJ.xilinx.BD.repo.path')
    if ( bd_folder == "") {
        bd_folder = `${opeParam.rootPath}/../resources/tool/Xilinx/IP/Example_bd/`;
    }
    vscode.window.showInputBox({
        password:false, 
        ignoreFocusOut:true,
        placeHolder:'Please input the name of bd_file', }).then(function(bd_file) {
        let bd_list = Property_param.properties.SOC_MODE.properties.bd_file.enum;
        if (bd_list.find(function(value) {
            if(value === bd_file) {
                return false;
            }
            else{
                return true;
            }
        })) {		
            bd_list.push(bd_file);
            this.json.pushJsonInfo(`${opeParam.rootPath}/../property.json`,Property_param);
            const bd_path = bd_folder + bd_file + '.bd';
            this.file.writeFile(bd_path,"\n\n");
            vscode.window.showInformationMessage(`generate the ${bd_file} successfully!!!`);
            const options = {
                preview: false,
                viewColumn: vscode.ViewColumn.Active
            };
            vscode.window.showTextDocument(vscode.Uri.file(bd_path), options);
        }
        else {
            vscode.window.showWarningMessage(`The ${bd_file} already exists`)
        }
    });
}
exports.Add_bd = Add_bd;

function Delete_bd(opeParam) {
    let Property_param = this.json.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    vscode.window.showQuickPick(this.file.pick_file(`${opeParam.rootPath}/../resources/tool/Xilinx/IP/Example_bd`,".bd")).then(selection => {
          // the user canceled the selection
        if (!selection) {
            return;
        }
        // the user selected some item. You could use `selection.name` too
        let bd_list = Property_param.properties.SOC_MODE.properties.bd_file.enum;
        for(var index = 0; index < bd_list.length;index++){
            if(selection == (bd_list[index] + '.bd')){
                bd_list.splice(index,1);
            }
        }
        this.json.pushJsonInfo(`${opeParam.rootPath}/../property.json`,Property_param);
        const bd_path = `${opeParam.rootPath}/../resources/tool/Xilinx/IP/Example_bd/` + selection;
        this.file.deleteFile(bd_path);
        vscode.window.showInformationMessage(`delete the ${selection} successfully!!!`);
    });
}
exports.Delete_bd = Delete_bd;

function Overwrite_bd(opeParam) {
    vscode.window.showQuickPick(this.file.pick_file(`${opeParam.rootPath}/../resources/tool/Xilinx/IP/Example_bd`,".bd")).then(selection => {
        // the user canceled the selection
      if (!selection) {
          return;
      }
      // the user selected some item. You could use `selection.name` too
      const bd_path = `${opeParam.rootPath}/../resources/tool/Xilinx/IP/Example_bd/` + selection;
      const options = {
          preview: false,
          viewColumn: vscode.ViewColumn.Active
      };
      vscode.window.showTextDocument(vscode.Uri.file(bd_path), options);
  });
}
exports.Overwrite_bd = Overwrite_bd;

function move_bd_IP(opeParam) {
    let prj_info = filesys.files.pullJsonInfo(opeParam.propertyPath);
    let target_path = "";
    let source_IP_path = `${opeParam.workspacePath}prj/xilinx/${prj_info.PRJ_NAME.FPGA}.srcs/sources_1/ip`;
    let source_bd_path = `${opeParam.workspacePath}prj/xilinx/${prj_info.PRJ_NAME.FPGA}.srcs/sources_1/bd`;
    if (prj_info.SOC_MODE.soc == "none") {
        target_path = `${opeParam.workspacePath}user`;
    }else{
        target_path = `${opeParam.workspacePath}user/Hardware`;
    }
    if (fs.existsSync(source_IP_path)) {
        fs.readdirSync(source_IP_path).forEach(element => {
            filesys.dirs.movedir(`${source_IP_path}/${element}`,`${target_path}/IP`)
        });
    }
    if (fs.existsSync(source_bd_path)) {
        fs.readdirSync(source_bd_path).forEach(element => {
            filesys.dirs.movedir(`${source_bd_path}/${element}`,`${target_path}/bd`)
        });
    }
}
exports.move_bd_IP = move_bd_IP;

function generateBootFile(opeParam) {
    let BootInfo = {
        "outside_folder" : `${opeParam.workspacePath}user/BOOT`,
        "inside_folder"  : `${opeParam.rootPath}/../resources/tool/Xilinx/BOOT`,
        "output_path"    : `${opeParam.rootPath}/../resources/tool/Xilinx/BOOT`,
        "elf_path"    : '',
        "bit_path"    : '',
        "fsbl_path"   : ''
    };

    let output_context =  "//arch = zynq; split = false; format = BIN\n";
        output_context += "the_ROM_image:\n";
        output_context += "{\n";

    BootInfo.fsbl_path = getfsblPath(opeParam);
    if (fs.existsSync(BootInfo.outside_folder)) {
        BootInfo.bit_path = getBitPath(BootInfo.outside_folder);
        BootInfo.elf_path = getElfPath(BootInfo.outside_folder);
    }
    else {
        BootInfo.bit_path = getBitPath(BootInfo.inside_folder);
        BootInfo.elf_path = getElfPath(BootInfo.inside_folder);
    }
    output_context += BootInfo.fsbl_path + BootInfo.bit_path + BootInfo.elf_path + "}";
    fs.writeFileSync(`${BootInfo.output_path}/output.bif`,output_context);
    let command = `bootgen -arch zynq -image ${BootInfo.output_path}/output.bif -o ${opeParam.workspacePath}BOOT.bin -w on`;
    child.exec(command, function (error, stdout, stderr) {
        if (error) {
            vscode.window.showErrorMessage(`${error}`);
            vscode.window.showErrorMessage(`stderr: ${stderr}`);
            return;
        }
    });
}
exports.generateBootFile = generateBootFile;

function getfsblPath(opeParam) {
    let fsbl_path = "";
    if (fs.existsSync(`${opeParam.workspacePath}user/BOOT/fsbl.elf`)) {
        fsbl_path = `\t[bootloader]${opeParam.workspacePath}user/BOOT/fsbl.elf\n`;
    }
    else {
        fsbl_path = "\t[bootloader]" + `${opeParam.rootPath}/../resources/tool/Xilinx/BOOT` + "/fsbl.elf\n";
    }
    return fsbl_path;
}

async function getBitPath(bit_path) {
    let bitList = filesys.files.pickFile(bit_path,".bit");
    if (bitList.length == 0) {
        vscode.window.showWarningMessage("The bit filesys.files was not found\nThe elf filesys.dirs was generated as a bin filesys.dirs");
    } else if (bitList.length == 1) {
        let bitPath = "\t" + bit_path + bitList[0] + "\n";
        return bitPath;	
    }
    else{
        return await vscode.window.showQuickPick(bitList).then(selection => {
            if (!selection) {
                return;
            }
            let bitPath = "\t" + bit_path + selection + "\n";
            return bitPath;
        });
    }
}

async function getElfPath(elf_path) {
    let elfList = pickElfFile(elf_path);
    if (elfList.length == 0) {
        vscode.window.showWarningMessage("The elf filesys.files was not found\nThe elf filesys.dirs was generated as a bin filesys.dirs");
    } else if (elfList.length == 1) {
        let elfPath = "\t" + elf_path + elfList[0] + "\n";
        return elfPath;	
    }
    else{
        return await vscode.window.showQuickPick(elfList).then(selection => {
            if (!selection) {
                return;
            }
            let elfPath = "\t" + elf_path + selection + "\n";
            return elfPath;
        });
    }
}

function pickElfFile(path) {
    let elf_list = filesys.files.pickFile(path,".elf");
    elf_list = elf_list.filter(function (elf_file) {
        return elf_file !== 'fsbl.elf';
    });
    return elf_list
}
