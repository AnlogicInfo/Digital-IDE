"use strict";

const fs      = require("fs");
const vscode  = require("vscode");
const child   = require("child_process");
const filesys = require("HDLfilesys");

class xilinxOperation {
    constructor(opeParam, prjStruct) {
        this.opeParam  = opeParam;
        this.prjStruct = prjStruct;
        this.cmds = [
            "set_param general.maxThreads",
            "set_property SOURCE_SET sources_1   [get_filesets sim_1]",
            "set_property top_lib xil_defaultlib [get_filesets sim_1]",
            "update_compile_order -fileset sim_1 -quiet"
        ]
    }

    launch(terminal, opeParam) {
        if (filesys.files.isHasValue(opeParam.prjInfo, "PRJ_STRUCTURE", "customer")) {
            // 视之为用户自定义文件结构
        } else {
            // 视之为标准文件结构
            let prjFilePath;
            let prjFiles = [];
            prjFiles = filesys.files.pickFile(`${opeParam.workspacePath}/prj/xilinx`, ".xpr");
            // 找到工程文件，如果找到就直接打开，找不到就根据配置信息新建工程。
            if (prjFiles.length) {
                prjFilePath = prjFiles[0];
                if (prjFiles.length > 1) {
                    
                }
                this.open(prjFilePath, opeParam);
            } else {
                this.creat(opeParam);
                // 如果是新建工程则根据配置信息进行文件导入
                
            }
            
        }
    }

    creat(opeParam) {
        let prjName = "template";
        let device  = "xc7z020clg400-2";
        if (filesys.files.isHasAttr(opeParam.prjInfo, "PRJ_NAME.FPGA")) {
            prjName = opeParam.prjInfo.PRJ_NAME.FPGA;
        }
        if (filesys.files.isHasAttr(opeParam.prjInfo, "Device")) {
            device = opeParam.prjInfo.Device;
        }
        terminal.sendText(`set_param general.maxThreads 8`);
        terminal.sendText(`create_project ${prjName} ./prj/xilinx -part ${device} -force -quiet`);
        terminal.sendText(`set_property SOURCE_SET sources_1   [get_filesets sim_1]`);
        terminal.sendText(`set_property top_lib xil_defaultlib [get_filesets sim_1]`);
        terminal.sendText(`update_compile_order -fileset sim_1 -quiet`);
    }

    open(prjFilePath, opeParam) {
        terminal.sendText(`set_param general.maxThreads 8`);
        terminal.sendText(`open_project ${prjFilePath} -quiet`);
        terminal.sendText(`set_property top ${opeParam.srcTopModule.path} [current_fileset]`);
        terminal.sendText(`set_property top ${opeParam.simTopModule.path} [get_filesets sim_1]`);
    }

    launchSim() {
        this.terminal.sendText(`if{[current_sim]!=""}{relaunch_sim -quiet}else{launch_simulation -quiet}`);
    }
    
    runSim(time) {
        this.terminal.sendText(`run ${time}`);
    }

    synth() {
        this.terminal.sendText(`reset_run   synth_1 ${this.quietArg}`);
        this.terminal.sendText(`launch_runs synth_1 ${this.quietArg} -jobs 4`);
        this.terminal.sendText(`wait_on_run synth_1 ${this.quietArg}`);
    }

    impl() {
        this.terminal.sendText(`reset_run   impl_1 ${this.quietArg}`);
        this.terminal.sendText(`launch_runs impl_1 ${this.quietArg} -jobs 4`);
        this.terminal.sendText(`wait_on_run impl_1 ${this.quietArg}`);
    }

    build() {
        this.synth();
        this.impl();
        this.terminal.sendText(`open_run impl_1 ${this.quietArg}`);
        this.terminal.sendText(`report_timing_summary ${this.quietArg}`);
    }

    program() {
        
    }

    boot() {

    }

    clean() {
        // move_bd_IP(opeParam);
        if (this.opeParam.propertyPath != "") {
            let fileList = fs.readdirSync(this.opeParam.workspacePath);
            for (let i = 0; i < fileList.length; i++) {
                const element = fileList[i];
                if (element != ".vscode" && 
                    element != "user" && 
                    fs.statSync(`${this.opeParam.workspacePath}/${element}`).isDirectory()) {
                    filesys.dirs.deleteDir(`${this.opeParam.workspacePath}/${element}`);
                }
            }        
            let strFile = filesys.files.pickFile(this.opeParam.workspacePath,".str");
            strFile.forEach(element => {
                filesys.files.deleteFile(`${this.opeParam.workspacePath}/${element}`);
            });
            let logFile = filesys.files.pickFile(this.opeParam.workspacePath,".log");
            logFile.forEach(element => {
                filesys.files.deleteFile(`${this.opeParam.workspacePath}/${element}`);
            });
        }
    }

    move_bd_IP() {
        let prj_info = filesys.files.pullJsonInfo(this.opeParam.propertyPath);
        let target_path = "";
        let source_IP_path = `${this.opeParam.workspacePath}/prj/xilinx/${prj_info.PRJ_NAME.FPGA}.srcs/sources_1/ip`;
        let source_bd_path = `${this.opeParam.workspacePath}/prj/xilinx/${prj_info.PRJ_NAME.FPGA}.srcs/sources_1/bd`;
        if (prj_info.SOC_MODE.soc == "none") {
            target_path = `${this.opeParam.workspacePath}/user`;
        }else{
            target_path = `${this.opeParam.workspacePath}/user/Hardware`;
        }
        if (fs.existsSync(source_IP_path)) {
            fs.readdirSync(source_IP_path).forEach(element => {
                filesys.dirs.movedir(`${source_IP_path}/${element}`,`${target_path}/IP`)
            });
        }
        if (fs.existsSync(source_bd_path)) {
            let bdFIleList = fs.readdirSync(source_bd_path);
            bdFIleList.forEach(element => {
                filesys.dirs.movedir(`${source_bd_path}/${element}`,`${target_path}/bd`);
            });
        }
    }
}
module.exports = xilinxOperation;

function Add_bd(opeParam) {
    let propertyParam = filesys.files.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    let bd_folder = vscode.workspace.getConfiguration().get('PRJ.xilinx.BD.repo.path')
    if ( bd_folder == "") {
        bd_folder = `${opeParam.rootPath}/../lib/Xilinx_lib/bd`;
    }
    vscode.window.showInputBox({
        password:false, 
        ignoreFocusOut:true,
        placeHolder:'Please input the name of bd_file', }).then(function(bd_file) {
        let bd_list = propertyParam.properties.SOC_MODE.properties.bd_file.enum;
        if (!bd_list.indexOf(bd_file)) {		
            bd_list.push(bd_file);
            filesys.files.pushJsonInfo(`${opeParam.rootPath}/../property.json`,propertyParam);
            const bd_path = `${bd_folder}/${bd_file}.bd`;
            fs.writeFileSync(bd_path, "\n\n", "utf8");
            vscode.window.showInformationMessage(`generate the ${bd_file} successfully!!!`);
            const options = {
                preview: false,
                viewColumn: vscode.ViewColumn.Active
            };
            vscode.window.showTextDocument(vscode.Uri.file(bd_path), options);
        }
        else {
            vscode.window.showWarningMessage(`The ${bd_file} already exists`);
        }
    });
}
exports.Add_bd = Add_bd;

function Delete_bd(opeParam) {
    let propertyParam = filesys.files.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    vscode.window.showQuickPick(filesys.files.pickFile(`${opeParam.rootPath}/../lib/Xilinx_lib/bd`,".bd")).then(selection => {
        // the user canceled the selection
        if (!selection) {
            return;
        }
        // the user selected some item. You could use `selection.name` too
        let bd_list = propertyParam.properties.SOC_MODE.properties.bd_file.enum;
        for(var index = 0; index < bd_list.length;index++){
            if(selection == (bd_list[index] + '.bd')){
                bd_list.splice(index,1);
            }
        }
        filesys.files.pushJsonInfo(`${opeParam.rootPath}/../property.json`,propertyParam);
        const bd_path = `${opeParam.rootPath}/../lib/Xilinx_lib/bd` + selection;
        this.file.deleteFile(bd_path);
        vscode.window.showInformationMessage(`delete the ${selection} successfully!!!`);
    });
}
exports.Delete_bd = Delete_bd;

function Overwrite_bd(opeParam) {
    vscode.window.showQuickPick(filesys.files.pickFile(`${opeParam.rootPath}/../lib/Xilinx_lib/bd`,".bd")).then(selection => {
        // the user canceled the selection
      if (!selection) {
          return;
      }
      // the user selected some item. You could use `selection.name` too
      const bd_path = `${opeParam.rootPath}/../lib/Xilinx_lib/bd/` + selection;
      const options = {
          preview: false,
          viewColumn: vscode.ViewColumn.Active
      };
      vscode.window.showTextDocument(vscode.Uri.file(bd_path), options);
  });
}
exports.Overwrite_bd = Overwrite_bd;

function generateBootFile(opeParam) {
    let BootInfo = {
        "outside_folder" : `${opeParam.workspacePath}/user/BOOT`,
        "inside_folder"  : `${opeParam.rootPath}/../resources/tool/Xilinx/BOOT`,
        "output_path"    : `${opeParam.rootPath}/../resources/tool/Xilinx/BOOT`,
        "elf_path"    : '',
        "bit_path"    : '',
        "fsbl_path"   : ''
    };

    let output_context =  "//arch = zynq; split = false; format = BIN\n";
        output_context += "the_ROM_image:\n";
        output_context += "{\n";

    BootInfo.fsbl_path = getfsblPath(opeParam);
    if (fs.existsSync(BootInfo.outside_folder)) {
        BootInfo.bit_path = getBitPath(BootInfo.outside_folder);
        BootInfo.elf_path = getElfPath(BootInfo.outside_folder);
    }
    else {
        BootInfo.bit_path = getBitPath(BootInfo.inside_folder);
        BootInfo.elf_path = getElfPath(BootInfo.inside_folder);
    }
    output_context += BootInfo.fsbl_path + BootInfo.bit_path + BootInfo.elf_path + "}";
    fs.writeFileSync(`${BootInfo.output_path}/output.bif`,output_context);
    let command = `bootgen -arch zynq -image ${BootInfo.output_path}/output.bif -o ${opeParam.workspacePath}/BOOT.bin -w on`;
    child.exec(command, function (error, stdout, stderr) {
        if (error) {
            vscode.window.showErrorMessage(`${error}`);
            vscode.window.showErrorMessage(`stderr: ${stderr}`);
            return;
        }
    });
}
exports.generateBootFile = generateBootFile;

function getfsblPath(opeParam) {
    let fsbl_path = "";
    if (fs.existsSync(`${opeParam.workspacePath}/user/BOOT/fsbl.elf`)) {
        fsbl_path = `\t[bootloader]${opeParam.workspacePath}/user/BOOT/fsbl.elf\n`;
    }
    else {
        fsbl_path = "\t[bootloader]" + `${opeParam.rootPath}/../resources/tool/Xilinx/BOOT` + "/fsbl.elf\n";
    }
    return fsbl_path;
}

async function getBitPath(bit_path) {
    let bitList = filesys.files.pickFile(bit_path,".bit");
    if (bitList.length == 0) {
        vscode.window.showWarningMessage("The bit filesys.files was not found\nThe elf filesys.dirs was generated as a bin filesys.dirs");
    } else if (bitList.length == 1) {
        let bitPath = "\t" + bit_path + bitList[0] + "\n";
        return bitPath;	
    }
    else{
        return await vscode.window.showQuickPick(bitList).then(selection => {
            if (!selection) {
                return;
            }
            let bitPath = "\t" + bit_path + selection + "\n";
            return bitPath;
        });
    }
}

async function getElfPath(elf_path) {
    let elfList = pickElfFile(elf_path);
    if (elfList.length == 0) {
        vscode.window.showWarningMessage("The elf filesys.files was not found\nThe elf filesys.dirs was generated as a bin filesys.dirs");
    } else if (elfList.length == 1) {
        let elfPath = "\t" + elf_path + elfList[0] + "\n";
        return elfPath;	
    }
    else{
        return await vscode.window.showQuickPick(elfList).then(selection => {
            if (!selection) {
                return;
            }
            let elfPath = "\t" + elf_path + selection + "\n";
            return elfPath;
        });
    }
}

function pickElfFile(path) {
    let elf_list = filesys.files.pickFile(path,".elf");
    elf_list = elf_list.filter(function (elf_file) {
        return elf_file !== 'fsbl.elf';
    });
    return elf_list
}
