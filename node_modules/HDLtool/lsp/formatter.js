"use strict";
const os   = require('os');
const fs   = require('fs');
const path = require('path');

const temp = require('./temp');

const vlogFormatter = require("./formatter/vlogFormatter.js");
const vhdlFormatter = require("./formatter/vhdlFormatter.js");

class Formatter {
    constructor(formatter_name) {
        if (formatter_name === undefined) {
            throw new Error('Formatter name is undefined.');
        }
        else if (formatter_name === "VSG") {
            return this.get_vsg();
        }
        else if (formatter_name === "ISTYLE") {
            return this.get_istyle();
        }
        else if (formatter_name === "VERIBLE") {
            //   return this.get_verible();
        }
        else if (formatter_name === "STANDALONE") {
            return this.get_standalone_vhdl();
        }
        else {
            throw new Error('Formatter name not supported.');
        }
    }

    get_istyle() {
        return new Istyle();
    }
    get_verible() {
        return new Verible();
    }
    get_standalone_vhdl() {
        return new Standalone_vhdl();
    }
    get_vsg() {
        return new Vsg();
    }
}
exports.Formatter = Formatter;

class Base_formatter {
    _get_command(file, synt, synt_windows, options) {
        let command = "";
        if (options !== undefined && options.custom_bin !== undefined) {
            command += options.custom_bin + " ";
        }
        else if (os.platform() === "win32") {
            if (options !== undefined && options.custom_path !== undefined) {
                command += options.custom_path + path.sep + synt_windows + " ";
            }
            else {
                command += synt_windows + " ";
            }
        }
        else {
            if (options !== undefined && options.custom_path !== undefined) {
                command += options.custom_path + path.sep + synt + " ";
            }
            else {
                command += synt + " ";
            }
        }

        if (options !== undefined && options.custom_arguments !== undefined) {
            command += options.custom_arguments + " ";
        }

        command += file;
        return command;
    }

    async _create_temp_file_of_code(content) {
        const temp_file = temp.openSync();
        if (temp_file === undefined) {
            // eslint-disable-next-line no-throw-literal
            throw "Unable to create temporary file";
        }
        fs.writeSync(temp_file.fd, content);
        fs.closeSync(temp_file.fd);
        return temp_file.path;
    }

    async _exec_formatter(file, synt, synt_windows, options) {
        var command = this._get_command(file, synt, synt_windows, options);
        const exec = require('child_process').exec;
        return new Promise((resolve) => {
            exec(command, (error, stdout, stderr) => {
                let result = { 'stdout': stdout, 'stderr': stderr };
                resolve(result);
            });
        });
    }
}

class Istyle extends Base_formatter {
    constructor() {
        super();
    }

    //Options: {custom_path:"/path/to/bin, custom_bin:"bin", style:"path/to/rules.json" extra_args:""}
    async format_from_code(code, options) {
        let vlogFormatter = await vFormatter();
        vlogFormatter.FS.writeFile("/share/FILE_IN.v", code, { encoding: 'utf8' });
        vlogFormatter.ccall('run', '', ['string'], [`${options} finish`]);
        let formatted_code = vlogFormatter.FS.readFile("/share/FILE_OUT.v", { encoding: 'utf8' });
        return formatted_code;
    }

    verilogFormatterServe(path, argu) {
        vFormatter().then((Module) => {
            let content = fs.readFileSync(path, "utf-8");
            Module.FS.writeFile("/share/FILE_IN.v", content, { encoding: 'utf8' });
            Module.ccall('run', '', ['string'], [`${argu} finish`]);
            content = Module.FS.readFile("/share/FILE_OUT.v", { encoding: 'utf8' });
            fs.writeFileSync(path, content, "utf-8");
            console.log(content);
        });
    }
}

class Vsg extends Base_formatter {
    constructor() {
        super();
    }

    //Options: {custom_path:"/path/to/bin, custom_bin:"bin", file_rules:"path/to/rules.json"}
    async format_from_code(code, options) {
        let temp_file = await this._create_temp_file_of_code(code);
        let formatted_code = await this._format(temp_file, options);
        return formatted_code;
    }

    async _format(file, options) {
        let synt = "";
        if (options !== undefined && options.file_rules !== undefined) {
            synt = `vsg --fix -lr ${options.file_rules} -f `;
        }
        else {
            synt = `vsg --fix -f `;
        }
        await this._exec_formatter(file, synt, synt, options);
        let formatted_code = fs.readFileSync(file, 'utf8');
        return formatted_code;
    }
}

class Verible extends Base_formatter {
    constructor() {
        super();
        this.PARAMETERS = {
            'SYNT': "verilog_format ",
            'SYNT_WINDOWS': "verilog_format "
        };
    }

    //Options: {path:"/path/to/bin"}
    async format_from_code(code, options) {
        let temp_file = await this._create_temp_file_of_code(code);
        let formatted_code = await this._format(temp_file, options);
        return formatted_code;
    }

    async _format(file, options) {
        let formatted_code = await this._exec_linter(file, this.PARAMETERS.SYNT,
            this.PARAMETERS.SYNT_WINDOWS, options);
        return formatted_code.stdout;
    }
}

class Standalone_vhdl {
    constructor() {
    }

    //Options: {custom_path:"/path/to/bin, custom_bin:"bin", settings:""}
    async format_from_code(code, options) {
        let beautifuler = new vhdlFormatter.Beautifuler();
        let formatted_code = beautifuler.beauty(code, options.settings);
        return formatted_code;
    }
}
