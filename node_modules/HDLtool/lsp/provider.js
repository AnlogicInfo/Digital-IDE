"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const vscode = require("vscode");

/* 语言服务功能 */

// 悬停提示
class numberHoverProvider{
    provideHover(document, position, token) {
        let numberHover;
        if (document.languageId == "systemverilog" || document.languageId == "verilog") {
            numberHover = this.verilog_hover(document, position, token);
        } else if (document.languageId == "vhdl") {
            numberHover = this.vhdl_hover(document, position, token);
        }
        return numberHover;
    }
    vhdl_hover(document, position, token) {
        let wordRange = document.getWordRangeAtPosition(position, /\w[-\w\.\"]*/g);
        if (wordRange !== undefined) {
            let leadingText = document.getText(new vscode.Range(wordRange.start, wordRange.end));
            if (/x"[0-9a-fA-F_]+"/g.test(leadingText)) {
                const regex = /x"([0-9a-fA-F_]+)"/g;
                let number = regex.exec(leadingText.replace('_', ''));
                if (number === null || number[1] === null) {
                    return;
                }
                let x = parseInt(number[1], 16);
                let x1 = this.eval_signed_hex(number[1], x);
                if (x === x1) {
                    return new vscode.Hover(leadingText + ' = ' + x);
                }
                else {
                    return new vscode.Hover(leadingText + ' = ' + x + ' (unsigned)  || ' + x1 + ' (signed)');
                }
            }
            else if (/[0-1_]+"/g.test(leadingText)) {
                const regex = /([0-1_]+)"/g;
                let number = regex.exec(leadingText.replace('_', ''));
                if (number === null || number[1] === null) {
                    return;
                }
                let x = parseInt(number[0], 2);
                let x1 = this.eval_signed_bin(number[0], x);
                if (x === x1) {
                    return new vscode.Hover('"' + leadingText + ' = ' + x);
                }
                else {
                    return new vscode.Hover('"' + leadingText + ' = ' + x + ' (unsigned) || ' + x1 + ' (signed)');
                }
            }
        }
    }
    verilog_hover(document, position, token) {
        let wordRange = document.getWordRangeAtPosition(position, /\w[-\w\.\']*/g);
        if (wordRange !== undefined) {
            let leadingText = document.getText(new vscode.Range(wordRange.start, wordRange.end));
            if (/h[0-9a-fA-F_]+/g.test(leadingText)) {
                const regex = /h([0-9a-fA-F_]+)/g;
                let number = regex.exec(leadingText.replace('_', ''));
                if (number === null || number[1] === null) {
                    return;
                }
                let x = parseInt(number[1], 16);
                let x1 = this.eval_signed_hex(number[1], x);
                if (x === x1) {
                    return new vscode.Hover(leadingText + ' = ' + x);
                }
                else {
                    return new vscode.Hover(leadingText + ' = ' + x + ' (unsigned) || ' + x1 + ' (signed)');
                }
            }
            else if (/b[0-1_]+/g.test(leadingText)) {
                const regex = /b([0-1_]+)/g;
                let number = regex.exec(leadingText.replace('_', ''));
                if (number === null || number[1] === null) {
                    return;
                }
                let x = parseInt(number[1], 2);
                let x1 = this.eval_signed_bin(number[1], x);
                if (x === x1) {
                    return new vscode.Hover(leadingText + ' = ' + x);
                }
                else {
                    return new vscode.Hover(leadingText + ' = ' + x + ' (unsigned) || ' + x1 + ' (signed)');
                }
            }
            else if (/o[0-8_]+/g.test(leadingText)) {
                const regex = /o([0-7_]+)/g;
                let number = regex.exec(leadingText.replace('_', ''));
                if (number === null || number[1] === null) {
                    return;
                }
                let x = parseInt(number[1], 8);
                let x1 = this.eval_signed_oct(number[1], x);
                if (x === x1) {
                    return new vscode.Hover(leadingText + ' = ' + x);
                }
                else {
                    return new vscode.Hover(leadingText + ' = ' + x + ' (unsigned) || ' + x1 + ' (signed)');
                }
            }
        }
    }
    eval_signed_hex(number_s, int_number) {
        let pow_hex = Math.pow(16, number_s.length);
        let x1 = int_number;
        if (int_number >= pow_hex >> 1) {
            x1 = int_number - pow_hex;
        }
        return x1;
    }
    eval_signed_bin(number_s, int_number) {
        let pow_bin = 1 << number_s.length - 1;
        let x1 = int_number;
        if (int_number >= pow_bin >> 1) {
            x1 = int_number - pow_bin;
        }
        return x1;
    }
    eval_signed_oct(number_s, int_number) {
        let pow_oct = Math.pow(8, number_s.length);
        let x1 = int_number;
        if (int_number >= pow_oct >> 1) {
            x1 = int_number - pow_oct;
        }
        return x1;
    }
}
exports.numberHoverProvider = numberHoverProvider;

class HoverProvider {
    provideHover(document, position, token) {
        return new Promise((resolve, reject) => {
            var lookupRange = document.getWordRangeAtPosition(position);
            if (!lookupRange) {
                return resolve(undefined);
            }
            let defination = vscode.commands.executeCommand("vscode.executeDefinitionProvider", document.uri, position, token);
            resolve(defination.then((loc) => {
                return vscode.workspace.openTextDocument(loc[0].uri).then(doc => {
					let content = doc.lineAt(loc[0].range.start.line).text;
					if(String.prototype.trim) {
						content = content.trim();
					} else {
						content = content.replace(/^\s+(.*?)\s+$/g, "$1");
                    }
                    content = this.del_spacing(content, 4);
                    content = content.replace(/\/\//g, "\n//") + "\n" + this.get_comment(doc, loc[0].range.start.line - 1);
					return content;
                });
            }).then((str) => {
                return new vscode.Hover( { language: 'systemverilog', value: str } );
            }));
        });
    }
    get_comment(doc, line) {
        let comment = "";
        let commentList = [];
        let content = doc.lineAt(line).text;
        let isblank   = content.match(/\S+/g);
        let l_comment = content.match(/(?<!(\s*\w+\s*))(\/\/.*)/g);
        let b_comment = content.match(/.*\*\//g);
        while (1) {
            if ( l_comment == null && b_comment == null && isblank != null) {
                break;
            } else {
                if ( isblank != null ) {                    
                    if (l_comment != null) {
                        commentList.push(l_comment + "\n");
                    } else {
                        commentList.push(b_comment + "\n");
                        while (1) {
                            line = line - 1;
                            content = doc.lineAt(line).text;
                            b_comment = content.match(/\/\*.*/g);
                            if (b_comment != null || line == 0) {
                                commentList.push(b_comment + "\n");
                                break;
                            }
                            commentList.push(content + "\n");
                        }
                    }
                }
                line = line - 1;
                if (line == -1) {
                    break;
                }
                content = doc.lineAt(line).text;
                isblank   = content.match(/\S+/g);
                l_comment = content.match(/(?<!(\s*\w+\s*))(\/\/.*)/g);
                b_comment = content.match(/.*\*\//g);
            }
        }
        for (let index = (commentList.length - 1); index >= 0; index--) {
            comment = comment + commentList[index];
        }
        return comment;
    }
    del_spacing(content, spacingNum) {
        let newContent = '';
        let i = 0;
        for (let index = 0; index < content.length; index++) {
            const element = content[index];
            if (element == ' ') {
                i++;
            }
            if (((element != ' ') && (element != '\t')) || (i <= spacingNum)) {
                newContent = newContent + element;
                if (i > spacingNum) {
                    i = 0;
                }
            }
        }
        return newContent;
    }
}
exports.HoverProvider = HoverProvider;

// 定义跳转
class DefinitionProvider {
    constructor(workspaceSymProvider) {
        // Strings used in regex'es
        // private regex_module = '$\\s*word\\s*(';
        this.regex_port = '\\.word\\s*\\(';
        this.regex_package = '\\b(\\w+)\\s*::\\s*(word)';
        this.workspaceSymProvider = workspaceSymProvider;
    };
    provideDefinition(document, position, token) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            let range = document.getWordRangeAtPosition(position);
            let line = document.lineAt(position.line).text;
            let word = document.getText(range);
            // Check for port
            let match_port = line.match(this.regex_port.replace('word', word));
            let match_package = line.match(this.regex_package.replace('word', word));
            if (!range) {
                reject();
            }
            // Port
            else if (match_port && match_port.index === range.start.character - 1) {
                let container = this.moduleFromPort(document, range);
                resolve(Promise.resolve(this.workspaceSymProvider.provideWorkspaceSymbols(container, token, true).then(res => {
                    return Promise.all(res.map(x => this.findPortLocation(x, word)));
                }).then(arrWithUndefined => {
                    return this.clean(arrWithUndefined, undefined);
                })));
                reject();
            }
            // Parameter
            else if (match_package && line.indexOf(word, match_package.index) == range.start.character) {
                yield this.workspaceSymProvider.provideWorkspaceSymbols(match_package[1], token, true)
                    .then((ws_symbols) => {
                    if (ws_symbols.length && ws_symbols[0].location) {
                        return ws_symbols[0].location.uri;
                    }
                }).then(uri => {
                    if (uri) {
                        vscode.commands.executeCommand("vscode.executeDocumentSymbolProvider", uri, word).then((symbols) => {
                            let results = [];
                            this.getDocumentSymbols(results, symbols, word, uri, match_package[1]);
                            resolve(results);
                        });
                    }
                });
                reject();
            }
            else {
                // Lookup all symbols in the current document
                yield vscode.commands.executeCommand("vscode.executeDocumentSymbolProvider", document.uri, word)
                    .then((symbols) => {
                    let results = [];
                    this.getDocumentSymbols(results, symbols, word, document.uri);
                    if (results.length !== 0) {
                        resolve(results);
                    }
                });
                yield this.workspaceSymProvider.provideWorkspaceSymbols(word, token, true)
                    .then(res => {
                    if (res.length !== 0) {
                        resolve(res.map(x => x.location));
                    }
                });
                reject();
            }
        }));
    }
    findPortLocation(symbol, port) {
        return vscode.workspace.openTextDocument(symbol.location.uri).then(doc => {
            for (let i = symbol.location.range.start.line; i < doc.lineCount; i++) {
                let line = doc.lineAt(i).text;
                if (line.match("\\bword\\b".replace('word', port))) {
                    return new vscode.Location(symbol.location.uri, new vscode.Position(i, line.indexOf(port)));
                }
            }
        });
    }
    moduleFromPort(document, range) {
        let text = document.getText(new vscode.Range(new vscode.Position(0, 0), range.end));
        let depthParathesis = 0;
        let i = 0;
        for (i = text.length; i > 0; i--) {
            if (text[i] == ')')
                depthParathesis++;
            else if (text[i] == '(')
                depthParathesis--;
            if (depthParathesis == -1) {
                let match_param = text.slice(0, i).match(/(\w+)\s*#\s*$/);
                let match_simple = text.slice(0, i).match(/(\w+)\s+(\w+)\s*$/);
                if (match_param)
                    return match_param[1];
                else if (match_simple)
                    return match_simple[1];
            }
        }
    }
    getDocumentSymbols(results, entries, word, uri, containerName) {
        for (let entry of entries) {
            if (entry.name === word) {
                if (containerName) {
                    if (entry.containerName === containerName) {
                        results.push({
                            uri: uri,
                            range: entry.range,
                        });
                    }
                }
                else {
                    results.push({
                        uri: uri,
                        range: entry.range,
                    });
                }
            }
            if (entry.children) {
                this.getDocumentSymbols(results, entry.children, word, uri);
            }
        }
    }
    clean(arr, deleteValue) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] == deleteValue) {
                arr.splice(i, 1);
                i--;
            }
        }
        return arr;
    }
}
exports.DefinitionProvider = DefinitionProvider;

// 文件标志
class DocumentSymbolProvider {
    constructor(indexer) {
        this.indexer = indexer;
    }
    /**
        Matches the regex pattern with the document's text. If a match is found, it creates a `Symbol` object.
        If `documentSymbols` is not `undefined`, than the object is added to it,
        otherwise add the objects to an empty list and return it.
        
        @param document The document in which the command was invoked.
        @param token A cancellation token.
        @return A list of `Symbol` objects or a thenable that resolves to such. The lack of a result can be
        signaled by returning `undefined`, `null`, or an empty list.
    */
    provideDocumentSymbols(document, token) {
        // console.debug("provideDocumentSymbols!", document.uri.path);
        return new Promise((resolve) => {
            /*
            Matches the regex and uses the index from the regex to find the position
            TODO: Look through the symbols to check if it either is defined in the current file or in the workspace.
                  Use that information to figure out if an instanciated 'unknown' object is of a known type.
            */
            let symbols = this.indexer.getFileParam(document, "symbol", 0, null, null, this.indexer.HDLSymbol);
            resolve(symbols);
            // resolve(show_SymbolKinds(document.uri));
        });
    }
}
exports.DocumentSymbolProvider = DocumentSymbolProvider;

// 工作区标志
class WorkspaceSymbolProvider {
    constructor(indexer) {
        this.NUM_FILES = 250;
        this.indexer = indexer;
    };
    /**
        Queries a symbol from `this.symbols`, performs an exact match if `exactMatch` is set to true,
        and a partial match if it's not passed or set to false.

        @param query the symbol's name
        @param token the CancellationToken
        @param exactMatch whether to perform an exact or a partial match
        @return an array of matching Symbol
    */
    provideWorkspaceSymbols(query, token, exactMatch) {
        return new Promise((resolve, reject) => {
            if (query.length === 0) {
                resolve(this.indexer.mostRecentSymbols);
            } else {
                const pattern = new RegExp(".*" + query.replace(" ", "").split("").map((c) => c).join(".*") + ".*", 'i');
                let results = new Array();
                this.indexer.symbols.forEach(list => {
                    list.forEach(symbol => {
                        if (exactMatch === true) {
                            if (symbol.name == query) {
                                results.push(symbol);
                            }
                        }
                        else if (symbol.name.match(pattern)) {
                            results.push(symbol);
                        }
                    });
                });
                this.indexer.updateMostRecentSymbols(results.slice(0)); //pass a shallow copy of the array
                resolve(results);
            }
        });
    }
    /**
        Queries a `module` with a given name from `this.symbols`, performs an exact match if `exactMatch` is set to true,
        and a partial match if it's not passed or set to false.
        @param query the symbol's name
        @return the module's Symbol
    */
    provideWorkspaceModule(query) {
        if (query.length === 0) {
            return undefined;
        }
        else {
            let symbolInfo = undefined;
            this.indexer.symbols.forEach(list => {
                list.forEach(symbol => {
                    if (symbol.name == query && symbol.kind == this.indexer.HDLSymbol.getSymbolKind("module")) {
                        symbolInfo = symbol;
                        return false;
                    }
                });
                if (symbolInfo) {
                    return false;
                }
            });
            this.indexer.updateMostRecentSymbols([symbolInfo]);
            return symbolInfo;
        }
    }
}
exports.WorkspaceSymbolProvider = WorkspaceSymbolProvider;
