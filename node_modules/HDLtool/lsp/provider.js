"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const vscode = require("vscode");

/* 语言服务功能 */

/* Symbol */
/**
 * Creates a new symbol information object.
 */
class HDLSymbol {
    /**
     * set a symbol information object.
     *
     * @param  name The name of the symbol.
     * @param  type The name of the symbol.
     * @param  containerName The name of the symbol containing the symbol.
     * @param  location The location of the symbol.
     * @return The object of the SymbolInformation.
     */
    setSymbolInformation(match, containerName, document, offset){
        let location = new vscode.Location(
            document.uri, 
            new vscode.Range(
                document.positionAt(match.index + offset), 
                document.positionAt(match.index + match[0].length + offset)));
        return vscode.SymbolInformation(
            match.groups.name,
            this.getSymbolKind(match.groups.type),
            containerName,
            location);
    }
    /**
     * get a symbol Kind.
     *
     * @param name The name of the symbol.
     * @return     The SymbolKind of the symbol's name.
     */
    getSymbolKind(name) {
        if (name === undefined || name === '') { // Ports may be declared without type
            return vscode.SymbolKind.Variable;
        } else if (name.indexOf('[') != -1) {
            return vscode.SymbolKind.Array;
        }
        switch (name) {
            case 'module':      return vscode.SymbolKind.Package;
            case 'package':     return vscode.SymbolKind.Package;
            case 'import':      return vscode.SymbolKind.Package;
            case 'program':     return vscode.SymbolKind.Package;
            case 'begin':       return vscode.SymbolKind.Operator;
    
            case 'task':        return vscode.SymbolKind.Method;
            case 'function':    return vscode.SymbolKind.Function;
    
            case 'assert':
            case 'event':       return vscode.SymbolKind.Event;
    
            case 'time':        return vscode.SymbolKind.TypeParameter;
            case 'define':      return vscode.SymbolKind.TypeParameter;
            case 'typedef':     return vscode.SymbolKind.TypeParameter;
            case 'generate':    return vscode.SymbolKind.Operator;
            case 'enum':        return vscode.SymbolKind.Enum;
            case 'modport':     return vscode.SymbolKind.Null;
            case 'property':    return vscode.SymbolKind.property;

            // port 
            case 'interface':   return vscode.SymbolKind.Interface;

            // synth param    
            case 'parameter':   return vscode.SymbolKind.Constant;
            case 'localparam':  return vscode.SymbolKind.Constant;
            case 'integer':     return vscode.SymbolKind.Constant;
            case 'char':        return vscode.SymbolKind.Constant;
            case 'float':       return vscode.SymbolKind.Constant;
            case 'int':         return vscode.SymbolKind.Constant;

            // unsynth param
            case 'string':      return vscode.SymbolKind.String;
            case 'struct':      return vscode.SymbolKind.Struct;
            case 'class':       return vscode.SymbolKind.Class;
            
            case 'logic':       return vscode.SymbolKind.Variable;
            case 'wire':        return vscode.SymbolKind.Variable;
            case 'reg':         return vscode.SymbolKind.Variable;
            case 'bit':         return vscode.SymbolKind.Variable;
            default:            return vscode.SymbolKind.Field;
        }
        /* Unused/Free SymbolKind icons
            return SymbolKind.Number;
            return SymbolKind.Enum;
            return SymbolKind.EnumMember;
            return SymbolKind.Operator;
            return SymbolKind.Array;
        */
    }
}
exports.HDLSymbol = HDLSymbol;

// 定义跳转
class DefinitionProvider {
    constructor(workspaceSymProvider) {
        // Strings used in regex'es
        // private regex_module = '$\\s*word\\s*(';
        this.regex_port = '\\.word\\s*\\(';
        this.regex_package = '\\b(\\w+)\\s*::\\s*(word)';
        this.workspaceSymProvider = workspaceSymProvider;
    };
    provideDefinition(document, position, token) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            let range = document.getWordRangeAtPosition(position);
            let line = document.lineAt(position.line).text;
            let word = document.getText(range);
            // Check for port
            let match_port = line.match(this.regex_port.replace('word', word));
            let match_package = line.match(this.regex_package.replace('word', word));
            if (!range) {
                reject();
            }
            // Port
            else if (match_port && match_port.index === range.start.character - 1) {
                let container = this.moduleFromPort(document, range);
                resolve(Promise.resolve(this.workspaceSymProvider.provideWorkspaceSymbols(container, token, true).then(res => {
                    return Promise.all(res.map(x => this.findPortLocation(x, word)));
                }).then(arrWithUndefined => {
                    return this.clean(arrWithUndefined, undefined);
                })));
                reject();
            }
            // Parameter
            else if (match_package && line.indexOf(word, match_package.index) == range.start.character) {
                yield this.workspaceSymProvider.provideWorkspaceSymbols(match_package[1], token, true)
                    .then((ws_symbols) => {
                    if (ws_symbols.length && ws_symbols[0].location) {
                        return ws_symbols[0].location.uri;
                    }
                }).then(uri => {
                    if (uri) {
                        vscode.commands.executeCommand("vscode.executeDocumentSymbolProvider", uri, word).then((symbols) => {
                            let results = [];
                            this.getDocumentSymbols(results, symbols, word, uri, match_package[1]);
                            resolve(results);
                        });
                    }
                });
                reject();
            }
            else {
                // Lookup all symbols in the current document
                yield vscode.commands.executeCommand("vscode.executeDocumentSymbolProvider", document.uri, word)
                    .then((symbols) => {
                    let results = [];
                    this.getDocumentSymbols(results, symbols, word, document.uri);
                    if (results.length !== 0) {
                        resolve(results);
                    }
                });
                yield this.workspaceSymProvider.provideWorkspaceSymbols(word, token, true)
                    .then(res => {
                    if (res.length !== 0) {
                        resolve(res.map(x => x.location));
                    }
                });
                reject();
            }
        }));
    }
    findPortLocation(symbol, port) {
        return vscode.workspace.openTextDocument(symbol.location.uri).then(doc => {
            for (let i = symbol.location.range.start.line; i < doc.lineCount; i++) {
                let line = doc.lineAt(i).text;
                if (line.match("\\bword\\b".replace('word', port))) {
                    return new vscode.Location(symbol.location.uri, new vscode.Position(i, line.indexOf(port)));
                }
            }
        });
    }
    moduleFromPort(document, range) {
        let text = document.getText(new vscode.Range(new vscode.Position(0, 0), range.end));
        let depthParathesis = 0;
        let i = 0;
        for (i = text.length; i > 0; i--) {
            if (text[i] == ')')
                depthParathesis++;
            else if (text[i] == '(')
                depthParathesis--;
            if (depthParathesis == -1) {
                let match_param = text.slice(0, i).match(/(\w+)\s*#\s*$/);
                let match_simple = text.slice(0, i).match(/(\w+)\s+(\w+)\s*$/);
                if (match_param)
                    return match_param[1];
                else if (match_simple)
                    return match_simple[1];
            }
        }
    }
    getDocumentSymbols(results, entries, word, uri, containerName) {
        for (let entry of entries) {
            if (entry.name === word) {
                if (containerName) {
                    if (entry.containerName === containerName) {
                        results.push({
                            uri: uri,
                            range: entry.range,
                        });
                    }
                }
                else {
                    results.push({
                        uri: uri,
                        range: entry.range,
                    });
                }
            }
            if (entry.children) {
                this.getDocumentSymbols(results, entry.children, word, uri);
            }
        }
    }
    clean(arr, deleteValue) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] == deleteValue) {
                arr.splice(i, 1);
                i--;
            }
        }
        return arr;
    }
}
exports.DefinitionProvider = DefinitionProvider;

// 悬停提示
class HoverProvider {
    provideHover(document, position, token) {
        return new Promise((resolve, reject) => {
            var lookupRange = document.getWordRangeAtPosition(position);
            if (!lookupRange) {
                return resolve(undefined);
            }
            let defination = vscode.commands.executeCommand("vscode.executeDefinitionProvider", document.uri, position, token);
            resolve(defination.then((loc) => {
                return vscode.workspace.openTextDocument(loc[0].uri).then(doc => {
					let content = doc.lineAt(loc[0].range.start.line).text;
					if(String.prototype.trim) {
						content = content.trim();
					} else {
						content = content.replace(/^\s+(.*?)\s+$/g, "$1");
                    }
                    content = this.del_spacing(content, 4);
                    content = content.replace(/\/\//g, "\n//") + "\n" + this.get_comment(doc, loc[0].range.start.line - 1);
					return content;
                });
            }).then((str) => {
                return new vscode.Hover( { language: 'systemverilog', value: str } );
            }));
        });
    }
    get_comment(doc, line) {
        let comment = "";
        let commentList = [];
        let content = doc.lineAt(line).text;
        let isblank   = content.match(/\S+/g);
        let l_comment = content.match(/(?<!(\s*\w+\s*))(\/\/.*)/g);
        let b_comment = content.match(/.*\*\//g);
        while (1) {
            if ( l_comment == null && b_comment == null && isblank != null) {
                break;
            } else {
                if ( isblank != null ) {                    
                    if (l_comment != null) {
                        commentList.push(l_comment + "\n");
                    } else {
                        commentList.push(b_comment + "\n");
                        while (1) {
                            line = line - 1;
                            content = doc.lineAt(line).text;
                            b_comment = content.match(/\/\*.*/g);
                            if (b_comment != null || line == 0) {
                                commentList.push(b_comment + "\n");
                                break;
                            }
                            commentList.push(content + "\n");
                        }
                    }
                }
                line = line - 1;
                content = doc.lineAt(line).text;
                isblank   = content.match(/\S+/g);
                l_comment = content.match(/(?<!(\s*\w+\s*))(\/\/.*)/g);
                b_comment = content.match(/.*\*\//g);
            }
        }
        for (let index = (commentList.length - 1); index >= 0; index--) {
            comment = comment + commentList[index];
        }
        return comment;
    }
    del_spacing(content, spacingNum) {
        let newContent = '';
        let i = 0;
        for (let index = 0; index < content.length; index++) {
            const element = content[index];
            if (element == ' ') {
                i++;
            }
            if (((element != ' ') && (element != '\t')) || (i <= spacingNum)) {
                newContent = newContent + element;
                if (i > spacingNum) {
                    i = 0;
                }
            }
        }
        return newContent;
    }
}
exports.HoverProvider = HoverProvider;

// 文件标志
class DocumentSymbolProvider {
    constructor(parser) {
        this.depth = -1;
        this.parser = parser;
        const settings = vscode.workspace.getConfiguration();
        this.precision = settings.get("HDL.documentSymbolsPrecision");
        if (this.precision != "full") {
            this.depth = 1;
        }
    }
    /**
        Matches the regex pattern with the document's text. If a match is found, it creates a `Symbol` object.
        If `documentSymbols` is not `undefined`, than the object is added to it,
        otherwise add the objects to an empty list and return it.
        
        @param document The document in which the command was invoked.
        @param token A cancellation token.
        @return A list of `Symbol` objects or a thenable that resolves to such. The lack of a result can be
        signaled by returning `undefined`, `null`, or an empty list.
    */
    provideDocumentSymbols(document, token) {
        // console.debug("provideDocumentSymbols!", document.uri.path);
        return new Promise((resolve) => {
            /*
            Matches the regex and uses the index from the regex to find the position
            TODO: Look through the symbols to check if it either is defined in the current file or in the workspace.
                  Use that information to figure out if an instanciated 'unknown' object is of a known type.
            */
            resolve(this.parser.get_HDLfileparam(document, "symbol", 0, null));
            // resolve(show_SymbolKinds(document.uri));
        });
    }
}
exports.DocumentSymbolProvider = DocumentSymbolProvider;

// 工作区标志
class WorkspaceSymbolProvider {
    constructor(indexer) {
        this.NUM_FILES = 250;
        this.indexer = indexer;
        this.HDLSymbol = new HDLSymbol();
    };
    /**
        Queries a symbol from `this.symbols`, performs an exact match if `exactMatch` is set to true,
        and a partial match if it's not passed or set to false.

        @param query the symbol's name
        @param token the CancellationToken
        @param exactMatch whether to perform an exact or a partial match
        @return an array of matching Symbol
    */
    provideWorkspaceSymbols(query, token, exactMatch) {
        return new Promise((resolve, reject) => {
            if (query.length === 0) {
                resolve(this.indexer.mostRecentSymbols);
            }
            else {
                const pattern = new RegExp(".*" + query.replace(" ", "").split("").map((c) => c).join(".*") + ".*", 'i');
                let results = new Array();
                this.indexer.symbols.forEach(list => {
                    list.forEach(symbol => {
                        if (exactMatch === true) {
                            if (symbol.name == query) {
                                results.push(symbol);
                            }
                        }
                        else if (symbol.name.match(pattern)) {
                            results.push(symbol);
                        }
                    });
                });
                this.indexer.updateMostRecentSymbols(results.slice(0)); //pass a shallow copy of the array
                resolve(results);
            }
        });
    }
    /**
        Queries a `module` with a given name from `this.symbols`, performs an exact match if `exactMatch` is set to true,
        and a partial match if it's not passed or set to false.
        @param query the symbol's name
        @return the module's Symbol
    */
    provideWorkspaceModule(query) {
        if (query.length === 0) {
            return undefined;
        }
        else {
            let symbolInfo = undefined;
            this.indexer.symbols.forEach(list => {
                list.forEach(symbol => {
                    if (symbol.name == query && symbol.kind == this.HDLSymbol.getSymbolKind("module")) {
                        symbolInfo = symbol;
                        return false;
                    }
                });
                if (symbolInfo) {
                    return false;
                }
            });
            this.indexer.updateMostRecentSymbols([symbolInfo]);
            return symbolInfo;
        }
    }
}
exports.WorkspaceSymbolProvider = WorkspaceSymbolProvider;
