"use strict";

const fs      = require("fs");
const fspath  = require("path");
const vscode  = require("vscode");
const parser  = require("HDLparser");

class FileSystemProvider {
    constructor(HDLparam, opeParam) {
        this._onDidChangeTreeData = new vscode.EventEmitter();
        this.onDidChangeTreeData  = this._onDidChangeTreeData.event;
        this.HDLparam = HDLparam;
        this.opeParam = opeParam;
        this.childCollapsibleState = vscode.TreeItemCollapsibleState.Collapsed;
    }
    
    refresh(element) {
        if (element) {
            this._onDidChangeTreeData.fire(element);
        } else {
            this._onDidChangeTreeData.fire();
        }
    }

    // TODO 完成 data 目录
    getChildren(element) {
        // 如果不是根节点
        if (element) {
            switch (element.type) {
                case "src"  : return parser.utils.getSrcTopElement(this.opeParam, this.HDLparam);
                // case "Data"      : return this.getDataTopElement();
                case "sim"  : return parser.utils.getSimTopElement(this.opeParam, this.HDLparam);
                default     : return parser.utils.getChildElement(element.type, this.HDLparam);
            }
        }

        // 根节点
        return [
            {"name": "", "type" : "src", "fsPath" : ""},
            // { "type" : "Data", "fsPath" : "" },
            {"name": "", "type" : "sim", "fsPath" : "" }
        ];
    }

    getTreeItem(element) {
        let iconPath = "top";
        let elementName = "";
        if (element.name == "" || element.name == undefined) {
            if (element.type == "src") {
                iconPath = "src";
            }
            else if (element.type == "sim") {
                iconPath = "sim";
            }
            else if (element.fsPath == "celllib") {
                iconPath = "celllib";
            }
            else if (element.fsPath.indexOf(this.opeParam.workspacePath) == -1) {
                iconPath = "lib";
                if (!fs.existsSync(element.fsPath)) {
                    iconPath = "File Error";
                }
            }
            elementName = element.type;
        } else {
            if (fs.existsSync(element.fsPath)) {                
                if (element.fsPath.indexOf(this.opeParam.workspacePath) != -1) {                
                    if (parser.utils.getLanguageId(element.fsPath) == "vlog") {
                        iconPath = "verilog";
                    } else if (parser.utils.getLanguageId(element.fsPath) == "vhdl") {
                        iconPath = "vhdl";
                    }
                } else {
                    iconPath = "lib";
                }
            } else {
                if (element.fsPath == "celllib") {
                    iconPath = "celllib";
                } else {
                    iconPath = "File Error";
                }
            }
            elementName = element.name + ' \( ' + element.type + ' \)';
        }
        let childrenList = this.getChildren(element);
        const treeItem = new vscode.TreeItem(
            elementName,
            childrenList.length === 0 ? 
            vscode.TreeItemCollapsibleState.None :
            this.childCollapsibleState 
        );
        let TreeItemList = [];
        for (let index = 0; index < childrenList.length; index++) {
            const element = childrenList[index];
            TreeItemList.push(this.getTreeItem(element));
        }
        let fileType = ["vhdl", "verilog", "lib", "top"]
        treeItem.tooltip = element.fsPath;
        if (fileType.includes(iconPath)) {
            treeItem.contextValue = 'file';
        } else {
            treeItem.contextValue = 'other';
        }
        treeItem.children = TreeItemList;
        if (iconPath == "top") {
            if (this.opeParam.srcTopModule != null && element.mode == "src") {
                if (this.opeParam.srcTopModule.name == element.type &&
                    this.opeParam.srcTopModule.path == element.fsPath) {
                    iconPath = "currentSrcTop";
                }
            }
            if (this.opeParam.simTopModule != null && element.mode == "sim") {
                if (this.opeParam.simTopModule.name == element.type &&
                    this.opeParam.simTopModule.path == element.fsPath) {
                    iconPath = "currentSimTop";
                }
            }
        }
        treeItem.iconPath = {
            light : `${this.opeParam.rootPath}/../images/svg/light/` + iconPath + ".svg",
            dark  : `${this.opeParam.rootPath}/../images/svg/dark/`  + iconPath + ".svg"
        };
        treeItem.command = { 
            title:     "Open this HDL File", 
            command:   'FILE.openFile', 
            arguments: [element.fsPath], 
        };
        return treeItem;
    }
}
exports.FileSystemProvider = FileSystemProvider;

class FileExplorer {
    constructor(HDLparam, opeParam, _context) {
        this._context = _context;
        this.treeDataProvider = new FileSystemProvider(HDLparam, opeParam);
        this.fileExplorer = vscode.window.createTreeView('TOOL.file_tree', {
            treeDataProvider: this.treeDataProvider,
            canSelectMany: true
        });
        
        vscode.commands.registerCommand("FILE.expand",   () => this.expand());
        vscode.commands.registerCommand('FILE.collapse', () => this.collapse());
        vscode.commands.registerCommand("FILE.refresh",  () => this.treeDataProvider.refresh());
        vscode.commands.registerCommand('FILE.openFile', (resource) => this.openResource(resource));
    }
    collapse() {
        this.treeDataProvider.childCollapsibleState = vscode.TreeItemCollapsibleState.Collapsed;
        this.treeDataProvider.refresh();
    }
    expand() {
        this.treeDataProvider.childCollapsibleState = vscode.TreeItemCollapsibleState.Expanded;
        this.treeDataProvider.refresh();
    }
    openResource(resource) {
        if (fs.existsSync(resource)) {
            vscode.window.showTextDocument(vscode.Uri.file(resource));
        }
    }
}
exports.FileExplorer = FileExplorer;

class hardTreeDataProvider {
    constructor(opeParam){
        this.opeParam = opeParam;
    }
    getChildren(element) {
        // 如果不是根节点
        if (element) {
            if (element.name === "Build") {
                return [
                    { "name" : "Synth"   },
                    { "name" : "Impl"    },
                    { "name" : "Gen_Bit" }
                ];
            } else {
                return [];
            }
        }
        // 根节点
        return [
            { "name" : "Launch"   },
            { "name" : "Simulate" },
            { "name" : "Refresh"  },
            { "name" : "Build"    },
            { "name" : "Program"  },
            { "name" : "GUI"      },
            { "name" : "Exit"     }
        ];
    }
    getTreeItem(element) {
        let childrenList = this.getChildren(element);
        const treeItem = new vscode.TreeItem(
            element.name,
            childrenList.length === 0 ? 
            vscode.TreeItemCollapsibleState.None :
            vscode.TreeItemCollapsibleState.Collapsed 
        );
        let TreeItemList = [];
        for (let index = 0; index < childrenList.length; index++) {
            const element = childrenList[index];
            TreeItemList.push(this.getTreeItem(element));
        }
        treeItem.contextValue = 'FPGA';
        treeItem.children = TreeItemList;
        treeItem.command  = this.getCommand(element.name);
        treeItem.tooltip  = this.getToolTip(element.name);
        treeItem.iconPath = this.getIconPath(element.name);
        return treeItem;
    }
    getCommand(name){
        let cuurentCommand = { 
            title:     name, 
            command:   ""
        };
        switch (name) {
            case "Launch"   : cuurentCommand.command = "FPGA.Launch";   break;
            case "Simulate" : cuurentCommand.command = "FPGA.Simulate"; break;
            case "Refresh"  : cuurentCommand.command = "FPGA.Refresh";  break;
            case "Build"    : cuurentCommand.command = "FPGA.Build";    break;
            case "Program"  : cuurentCommand.command = "FPGA.Program";  break;
            case "GUI"      : cuurentCommand.command = "FPGA.GUI";      break;
            case "Exit"     : cuurentCommand.command = "FPGA.Exit";     break;

            case "Synth"    : cuurentCommand.command = "FPGA.Synth";    break;
            case "Impl"     : cuurentCommand.command = "FPGA.Impl";     break;
            case "Gen_Bit"  : cuurentCommand.command = "FPGA.Gen_Bit";  break;
            
            default: break;
        }
        return cuurentCommand;
    }
    getIconPath(name){
        let iconPath = ""
        switch (name) {
            case "Launch"   : iconPath = "cmd"; break;
            case "Simulate" : iconPath = "cmd"; break;
            case "Refresh"  : iconPath = "cmd"; break;
            case "Build"    : iconPath = "cmd"; break;
            case "Program"  : iconPath = "cmd"; break;
            case "GUI"      : iconPath = "cmd"; break;
            case "Exit"     : iconPath = "cmd"; break;

            case "Synth"    : iconPath = "branch"; break;
            case "Impl"     : iconPath = "branch"; break;
            case "Gen_Bit"  : iconPath = "branch"; break;
            
            default: break;
        }
        let currentIconPath = {
            light : `${this.opeParam.rootPath}/../images/svg/light/` + iconPath + ".svg",
            dark  : `${this.opeParam.rootPath}/../images/svg/dark/`  + iconPath + ".svg"
        };
        return currentIconPath;
    }
    getToolTip(name){
        let currentToolTip = ""
        switch (name) {
            case "Launch"   : currentToolTip = "Launch FPGA development assist function"; break;
            case "Simulate" : currentToolTip = "Launch the manufacturer Simulation"; break;
            case "Refresh"  : currentToolTip = "Refresh the current project file"; break;
            case "Build"    : currentToolTip = "Build the current fpga project"; break;
            case "Program"  : currentToolTip = "Download the bit file into the device"; break;
            case "GUI"      : currentToolTip = "Open the GUI"; break;
            case "Exit"     : currentToolTip = "Exit the current project"; break;

            case "Synth"    : currentToolTip = "Synth the current project"; break;
            case "Impl"     : currentToolTip = "Impl  the current project"; break;
            case "Gen_Bit"  : currentToolTip = "Generate the BIT File"; break;
            
            default: break;
        }
        return currentToolTip;
    }
}
exports.hardTreeDataProvider = hardTreeDataProvider;

class softTreeDataProvider {
    constructor(opeParam){
        this.opeParam = opeParam;
    }
    getChildren(element) {
        // 根节点
        return [
            { "name" : "Launch"   },
            { "name" : "Build"    },
            { "name" : "Download" }
        ];
    }
    getTreeItem(element) {
        let treeItem = new vscode.TreeItem(
            element.name,
            vscode.TreeItemCollapsibleState.None
        );
        treeItem.contextValue = 'SDK';
        treeItem.command  = this.getCommand(element.name);
        treeItem.tooltip  = this.getToolTip(element.name);
        treeItem.iconPath = this.getIconPath(element.name);
        return treeItem;
    }
    getCommand(name){
        let cuurentCommand = { 
            title:     name, 
            command:   ""
        };
        switch (name) {
            case "Launch"   : cuurentCommand.command = "SDK.Launch";   break;
            case "Build"    : cuurentCommand.command = "SDK.Build";    break;
            case "Download" : cuurentCommand.command = "SDK.Download"; break;
            
            default: break;
        }
        return cuurentCommand;
    }
    getIconPath(name){
        let iconPath = ""
        switch (name) {
            case "Launch"   : iconPath = "cmd"; break;
            case "Build"    : iconPath = "cmd"; break;
            case "Download" : iconPath = "cmd"; break;
            
            default: break;
        }
        let currentIconPath = {
            light : `${this.opeParam.rootPath}/../images/svg/light/` + iconPath + ".svg",
            dark  : `${this.opeParam.rootPath}/../images/svg/dark/`  + iconPath + ".svg"
        };
        return currentIconPath;
    }
    getToolTip(name){
        let currentToolTip = ""
        switch (name) {
            case "Launch"   : currentToolTip = "Launch SDK development assist function"; break;
            case "Build"    : currentToolTip = "Build the current SDK project"; break;
            case "Download" : currentToolTip = "Download the boot file into the device"; break;

            default: break;
        }
        return currentToolTip;
    }
}
exports.softTreeDataProvider = softTreeDataProvider;

class toolTreeDataProvider {
    constructor(opeParam){
        this.opeParam = opeParam;
    }
    getChildren(element) {
        // 根节点
        return [
            { "name" : "BOOT"   },
            { "name" : "Clean"    },
            { "name" : "SerialPort" }
        ];
    }
    getTreeItem(element) {
        let treeItem = new vscode.TreeItem(
            element.name,
            vscode.TreeItemCollapsibleState.None
        );
        treeItem.contextValue = 'TOOL';
        treeItem.command  = this.getCommand(element.name);
        treeItem.tooltip  = this.getToolTip(element.name);
        treeItem.iconPath = this.getIconPath(element.name);
        return treeItem;
    }
    getCommand(name){
        let cuurentCommand = { 
            title:     name, 
            command:   ""
        };
        switch (name) {
            case "BOOT"       : cuurentCommand.command = "TOOL.Gen_BOOT";   break;
            case "Clean"      : cuurentCommand.command = "TOOL.Clean";      break;
            case "SerialPort" : cuurentCommand.command = "TOOL.SerialPort"; break;
            
            default: break;
        }
        return cuurentCommand;
    }
    getIconPath(name){
        let iconPath = ""
        switch (name) {
            case "BOOT"       : iconPath = "BOOT"; break;
            case "Clean"      : iconPath = "clean"; break;
            case "SerialPort" : iconPath = "SerialPort"; break;
            
            default: break;
        }
        let currentIconPath = {
            light : `${this.opeParam.rootPath}/../images/svg/light/` + iconPath + ".svg",
            dark  : `${this.opeParam.rootPath}/../images/svg/dark/`  + iconPath + ".svg"
        };
        return currentIconPath;
    }
    getToolTip(name){
        let currentToolTip = ""
        switch (name) {
            case "BOOT"       : currentToolTip = "Launch SDK development assist function"; break;
            case "Clean"      : currentToolTip = "Clean the current project"; break;
            case "SerialPort" : currentToolTip = "Launch Serial monitor"; break;

            default: break;
        }
        return currentToolTip;
    }
}
exports.toolTreeDataProvider = toolTreeDataProvider;
