"use strict";

class Templates_factory {
    constructor() { }

    get_template(type, language) {
        let template;
        if (type === Codes.TYPES.VUNIT) {
            template = this.get_vunit_template();
        }
        else if (type === Codes.TYPES.COCOTB) {
            template = this.get_cocotb_template(language);
        }
        else if (type === Codes.TYPES.VERILATOR) {
            template = this.get_verilator_template();
        }
        else if (type === Codes.TYPES.TESTBENCH) {
            if (language === General.LANGUAGES.VHDL) {
                template = this.get_vhdl_testbench();
            }
            else if (language === General.LANGUAGES.VERILOG) {
                template = this.get_verilog_testbench();
            }
        }
        else if (type === Codes.TYPES.COMPONENT) {
            if (language === General.LANGUAGES.VHDL) {
                template = this.get_vhdl_component();
            }
            else if (language === General.LANGUAGES.VERILOG) {
                template = this.get_verilog_component();
            }
        }
        return template;
    }

    get_cocotb_template(language) {
        return new cocotb(language);
    }

    get_verilator_template() {
        return new verilator();
    }

    get_vunit_template() {
        return new VUnit();
    }

    get_vhdl_testbench() {
        return new Vhdl_editor();
    }

    get_verilog_testbench() {
        return new Verilog_editor();
    }

    get_vhdl_component() {
        return new Vhdl_component();
    }

    get_verilog_component() {
        return new Verilog_component();
    }

}

module.exports = {
    Codes: Codes,
    Templates_factory: Templates_factory
};

class cocotb {
    constructor( ) { }
    // eslint-disable-next-line no-unused-vars
    async generate(ports) {
        let test = "";

        test += this.header();
        test += this.python_libraries();
        test += this.coco_test(ports);
        test += this.register_test();
        return test;
    }

    header() {
        let test = "# -*- coding: utf-8 -*-\n";
        return test;
    }
    python_libraries() {
        let test = "import cocotb\n";
        test += "from cocotb.clock import Clock\n";
        test += "from cocotb.triggers import Timer\n";
        test += "from cocotb.regression import TestFactory\n";
        return test;
    }
    coco_test(ports) {
        let test_instance = "";
        test_instance += '\n@cocotb.test()\n';
        test_instance += 'async def run_test(dut):\n';
        test_instance += '    PERIOD = 10\n';
        
        // Search clock
        let clock_ports_index = [];
        for (let i = 0; i < ports.length; i++) {
            const port = ports[i];
            let is_clk = (port["direction"] === "in" || port["direction"] === "input")
                && (port["name"] === "clk" || port["name"].startsWith("clk")
                    || port["name"] === "clk" || port["name"].startsWith("aclk"));

            if (is_clk === true) {
                clock_ports_index.push(i);
                //Clock instance
                test_instance += `    cocotb.fork(Clock(dut.${port['name']}, PERIOD, 'ns').start(start_high=False))\n`;
            }
        }
        test_instance += '\n';
        //Ports instance to 0
        for (let i = 0; i < ports.length; i++) {
            const port = ports[i];
            if (clock_ports_index.includes(i) === false) {
                test_instance += `    dut.${port['name']} = 0\n`;
            }
        }
        test_instance += '\n';
        test_instance += `    await Timer(20*PERIOD, units='ns')\n\n`;
        //Ports instance to 1
        for (let i = 0; i < ports.length; i++) {
            const port = ports[i];
            if (clock_ports_index.includes(i) === false) {
                test_instance += `    dut.${port['name']} = 1\n`;
            }
        }
        test_instance += '\n';
        test_instance += `    await Timer(20*PERIOD, units='ns')\n`;

        return test_instance;
    }
    register_test() {
        let test_instance = "";
        test_instance += `
  # Register the test.
  factory = TestFactory(run_test)
  factory.generate_tests()
      `;
        return test_instance;
    }

}

class VUnit {
    constructor() {
        this.str = "";
        this.str_out = "";
        this.path = require('path');
    }
    generate(options) {
        this.str = options;
        this.header();
        this.python_libraries();
        this.set_lang();
        this.separator();
        this.checks();
        this.separator();
        this.check_simulator();
        this.separator();
        this.vunit_instance();
        this.add_src();
        this.addTb();
        this.check_calls();
        this.separator();
        this.simulator_suport();
        this.separator();
        this.post_run_fcn();
        this.separator();
        this.run();
        return this.str_out;
    }

    header() {
        this.str_out = "# -*- coding: utf-8 -*-\n";
    }
    python_libraries() {
        this.str_out += "from os.path import join , dirname, abspath\nimport subprocess\nfrom vunit.sim_if.ghdl ";
        this.str_out += "import GHDLInterface\nfrom vunit.sim_if.factory import SIMULATOR_FACTORY\n";
    }
    set_lang() {
        if (this.str.lang === "vhdl") {
            this.str_out += "from vunit   import VUnit, VUnitCLI\n";
        }
        else if (this.str.lang === "verilog") {
            this.str_out += "from vunit.verilog   import VUnit, VUnitCLI\n";
        }
    }
    separator() {
        this.str_out += "\n################################################################################\n";
    }
    checks() {
        if (this.str.config.checks) {
            this.str_out += "#pre_config func\n";
            this.str_out += "def pre_config_func():\n";
            this.str_out += '    """\n';
            this.str_out += "    Before test.\n";
            this.str_out += '    """\n';
            this.str_out += "#post_check func\n";
            this.str_out += "def post_check_func():\n";
            this.str_out += '    """\n';
            this.str_out += "    After test.\n";
            this.str_out += '    """\n';
            this.str_out += "    def post_check(output_path):\n";
            this.str_out += "        check = True\n";
            this.str_out += "        return check\n";
            this.str_out += "    return post_check\n";
        }
    }
    check_simulator() {
        this.str_out += "#Check simulator.\n";
        this.str_out += 'print ("=============================================")\n';
        this.str_out += 'simname = SIMULATOR_FACTORY.select_simulator().name\n';
        if (this.str.config.simulator_suport.modelsim.enable) {
            this.check_modelsim();
        }
        if (this.str.config.simulator_suport.ghdl.enable) {
            this.check_ghdl();
        }
        this.str_out += 'print ("Simulator = " + simname)\n';
        this.str_out += 'print ("=============================================")\n';
    }
    check_modelsim() {
        this.str_out += 'code_coverage = False\n';
        this.str_out += 'if (simname == "modelsim"):\n';
        this.str_out += '    f= open("modelsim.do","w+")\n';
        this.str_out += '    f.write("add wave * \\nlog -r /*\\nvcd file\\nvcd add -r /*\\n")\n';
        this.str_out += '    f.close()\n';
    }
    check_ghdl() {
        this.str_out += 'code_coverage = (simname == "ghdl" and \\\n';
        this.str_out += '                (GHDLInterface.determine_backend("")=="gcc" or  \\\n';
        this.str_out += '                GHDLInterface.determine_backend("")=="GCC"))\n';
    }
    vunit_instance() {
        this.str_out += '#VUnit instance.\n';
        this.str_out += 'ui = VUnit.from_argv()\n';
    }
    add_src() {
        this.str_out += '\n#Add module sources.\n';
        this.str_out += this.str.config["name"] + '_src_lib = ui.add_library("src_lib")\n';
        for (var x = 0; x < this.str.src.length; x++) {
            let file = this.path.relative(this.str.config["output_path"], this.str.src[x]);
            file.replace("\\", "\\\\");
            this.str_out += this.str.config["name"] + '_src_lib.add_source_files("' + file + '")\n';
        }
    }
    addTb() {
        this.str_out += '\n#Add tb sources.\n';
        this.str_out += this.str.config["name"] + '_tb_lib = ui.add_library("tb_lib")\n';
        for (var x = 0; x < this.str.tb.length; x++) {
            let file = this.path.relative(this.str.config["output_path"], this.str.tb[x]);
            file.replace("\\", "\\\\");
            this.str_out += this.str.config["name"] + '_tb_lib.add_source_files("' + file + '")\n';
        }
    }
    check_calls() {
        if (this.str.config.checks) {
            let file = this.path.relative(this.str.config["output_path"], this.str.tb[0]);
            file.replace("\\", "\\\\");
            this.str_out += '\n#func checks\n';
            this.str_out += 'tb_generated = ' + this.str.config["name"] + '_tb_lib.test_bench("' + file.split(".")[0] + '")\n';
            this.str_out += 'for test in tb_generated.get_tests():\n';
            this.str_out += '    test.add_config(name="test_alive", pre_config=pre_config_func()';
            this.str_out += ',post_check=post_check_func())\n';
        }
    }
    simulator_suport() {
        if (this.str.config.simulator_suport.ghdl.enable) {
            this.str_out += '#Simulators flags.\n';
            this.str_out += 'if(code_coverage == True):\n';
            this.ghdl_config(true);
            this.str_out += 'else:\n';
            this.ghdl_config(false);
        }
        if (this.str.config.simulator_suport.modelsim.enable) {
            this.str_out += '\n';
            this.modelsim_config();
        }
        if (this.str.config.simulator_suport.ghdl.config.disable_ieee_warnings) {
            this.disable_ieee_warnings();
        }
    }
    ghdl_config(coverage) {
        let flags_vars = ' ';
        let sim_vars = ' ';
        let sep = ' ';
        if (this.str.config.simulator_suport.ghdl.config.synopsys_libraries) {
            let synopsys_var = '"-fexplicit","--ieee=synopsys","--no-vital-checks","-frelaxed-rules"';
            flags_vars += synopsys_var;
            sim_vars += synopsys_var;
            sep = ',';
        }
        if (coverage) {
            if (this.str.config.simulator_suport.ghdl.config.code_coverage.enable) {
                let code_coverage_var = '"-fprofile-arcs","-ftest-coverage"';
                let code_coverage_sim = '"-Wl,-lgcov"';
                flags_vars += sep + code_coverage_var;
                sim_vars += sep + code_coverage_sim;
            }
        }
        this.str_out += '    ' + this.str.config["name"]
            + '_src_lib.add_compile_option   ("ghdl.flags"     , [ ' + flags_vars + '])\n';
        this.str_out += '    ' + this.str.config["name"]
            + '_tb_lib.add_compile_option    ("ghdl.flags"     , [ ' + flags_vars + '])\n';
        this.str_out += '    ui.set_sim_option("ghdl.elab_flags", [' + sim_vars + '])\n';
    }
    modelsim_config() {
        this.str_out += 'ui.set_sim_option("modelsim.init_files.after_load" ,["modelsim.do"])\n';
    }
    disable_ieee_warnings() {
        this.str_out += 'ui.set_sim_option("disable_ieee_warnings", True)\n';
    }
    post_run_fcn() {
        this.str_out += 'def post_run_fcn(results):\n';
        this.str_out += '    if(code_coverage == True ):\n';
        for (var x = 0; x < this.str.src.length; x++) {
            this.str_out += '        subprocess.call(["lcov", "--capture", "--directory", "'
                + this.path.basename(this.str.src[x]).split(".")[0]
                + '.gcda", "--output-file",  "code_' + x.toString() + '.info" ])\n';
        }
        this.str_out += '        subprocess.call(["genhtml"';
        for (let x = 0; x < this.str.src.length; x++) {
            this.str_out += ',"code_' + x.toString() + '.info"',
                +this.str.config.simulator_suport.ghdl.config.code_coverage["output_path"] + '"])\n';
        }
        this.str_out += ',"--output-directory", "'
            + this.str.config.simulator_suport.ghdl.config.code_coverage["output_path"] + '"])\n';
    }
    run() {
        this.str_out += '#Run tests.\n';
        this.str_out += 'ui.main(post_run=post_run_fcn)\n';
    }
}

class verilator {
    constructor() {
        this.str = "";
        this.str_out = "";
        this.language = General.LANGUAGES.VERILOG;
        this.path = require('path');
    }
    async generate(src) {
        let parser = new ParserLib.ParserFactory;
        parser = await parser.getParser(this.language, '');
        let structure = await parser.get_all(src);
        if (structure === undefined) {
            return undefined;
        }
        this.str = structure;
        this.header();
        this.loop();
        this.verilatortb();
        return this.str_out;
    }

    header() {
        this.str_out = "#include <stdlib.h>\n";
        this.str_out += '#include "V' + this.str.entity["name"] + '.h"\n';
        this.str_out += '#include "verilated.h"\n\n';
        this.str_out += 'int main(int argc, char **argv, char** env) {\n';
        this.str_out += '  // Initialize Verilators variables\n';
        this.str_out += '  Verilated::commandArgs(argc, argv);\n\n';
        this.str_out += '  // Create an instance of our module under test\n';
        this.str_out += '  V' + this.str.entity["name"] + ' *tb = new V' + this.str.entity["name"] + ';\n\n';
    }

    loop() {
        this.str_out += '// Tick the clock until we are done';
        this.str_out += '//  while(!Verilated::gotFinish()) {\n';
        for (var x = 0; x < this.str.ports.length; x++) {
            if (this.str.ports[x]["direction"] === "input") {
                this.str_out += '//    tb-> ' + this.str.ports[x]["name"] + ' = 1;\n';
            }
        }
        for (let x = 0; x < this.str.ports.length; x++) {
            if (this.str.ports[x]["direction"] === "output") {
                this.str_out += '//    printf(" Output ' + this.str.ports[x]["name"] + ': %d \\n",tb-> '
                    + this.str.ports[x]["name"] + ');\n';
            }
        }
        this.str_out += '//    tb->eval();\n';
        this.str_out += '//  } exit(EXIT_SUCCESS);\n\n';
        for (let x = 0; x < this.str.ports.length; x++) {
            if (this.str.ports[x]["direction"] === "input") {
                this.str_out += '    tb-> ' + this.str.ports[x]["name"] + ' = 1;\n';
            }
        }
        this.str_out += '    tb->eval();\n';
        for (let x = 0; x < this.str.ports.length; x++) {
            if (this.str.ports[x]["direction"] === "output") {
                this.str_out += '    printf(" Output ' + this.str.ports[x]["name"] + ': %d \\n",tb-> '
                    + this.str.ports[x]["name"] + ');\n';
            }
        }
        this.str_out += '   exit(EXIT_SUCCESS);\n}';
    }

    verilatortb() {
        this.header();
        this.loop();
    }
}

class Verilog_editor {
    constructor() { }

    async generate(src, options) {
        let parser = new ParserLib.ParserFactory;
        parser = await parser.getParser(General.LANGUAGES.VERILOG, '');
        let structure = await parser.get_all(src);
        if (structure === undefined) {
            return undefined;
        }
        var vunit = false;
        var version = General.VERILOGSTANDARS.VERILOG2001;
        if (options !== null) {
            vunit = options['type'] === Codes.TYPESTESTBENCH.VUNIT;
            version = options['version'];
        }
        var space = '  ';
        var str = '';
        if (vunit === true) {
            str += this.set_vunit_libraries();
            str += '\n';
        }
        str += this.set_entity(structure['entity']);
        str += '\n';
        str += this.set_constants(space, structure['generics']);
        str += '\n';
        str += '  // Ports\n';
        str += this.set_signals_tb(space, structure['ports']);
        str += '\n';

        str += this.set_instance2001(space, structure['entity']['name'], structure['generics'], structure['ports']);
        str += '\n';
        if (vunit === true) {
            str += this.set_vunit_process(space);
            str += '\n';
        } else {
            str += this.set_main(space);
            str += '\n';
        }
        str += this.set_clk_process(space, structure['ports']);
        str += '\n';
        str += 'endmodule\n';

        return str;
    }

    set_vunit_libraries() {
        var str = '';
        str += '`include "vunit_defines.svh"\n';
        return str;
    }

    set_libraries(m) {
        var str = '';
        for (let x = 0; x < m.length; ++x) {
            str += `use ${m[x]['name']};\n`;
        }
        return str;
    }

    set_entity(m) {
        var str = '';
        str += `module ${m['name']}_tb;\n`;
        return str;
    }

    set_vunit_entity(m) {
        var str = '';
        str += 'entity ' + m['name'] + '_tb is\n';
        str += '  generic (runner_cfg : string);\n';
        str += 'end;\n';
        return str;
    }

    set_constants(space, m) {
        var str = '';
        str += `${space}// Parameters\n`;
        for (let x = 0; x < m.length; ++x) {
            str += `${space}localparam ${m[x]['type']} ${m[x]['name']} = 1;\n`;
        }
        return str;
    }

    set_signals_tb(space, m) {
        var str = '';
        for (let x = 0; x < m.length; ++x) {
            if (m[x]['type'] === '') {
                if (m[x]['direction'] === "input") {
                    str += `${space}reg ${m[x]['name']} = 0;\n`;
                } else {
                    str += `${space}wire ${m[x]['name']};\n`;
                }

            }
            else {
                const regex = /\[(.*?)\]/;
                let type = m[x]['type'].match(regex);
                if (type === null) {
                    type = '';
                } else {
                    type = type[0];
                }
                if (m[x]['direction'] === "input") {
                    if (type === '') {
                        str += `${space}reg ${type} ${m[x]['name']} = 0;\n`;
                    } else {
                        str += `${space}reg ${type} ${m[x]['name']};\n`;
                    }
                } else {
                    str += `${space}wire ${type} ${m[x]['name']};\n`;
                }

            }
        }
        return str;
    }

    set_signals(space, m) {
        var str = '';
        for (let x = 0; x < m.length; ++x) {
            if (m[x]['type'] === '') {
                str += `${space}reg r_${m[x]['name']};\n`;

            }
            else {
                const regex = /\[(.*?)\]/;
                let type = m[x]['type'].match(regex);
                if (type === null) {
                    type = '';
                } else {
                    type = type[0];
                }
                str += `${space}reg ${type} r_${m[x]['name']};\n`;
            }
        }
        return str;
    }

    set_instance(space, name, generics, ports) {
        var str = '';
        //Instance name
        str += `${space}${name}\n`;
        //Parameters
        if (generics.length > 0) {
            str += `${space}  #(\n`;
            for (let x = 0; x < generics.length - 1; ++x) {
                str += `${space}    ${generics[x]['name']},\n`;
            }
            str += `${space}    ${generics[generics.length - 1]['name']}\n`;
            str += `${space}  )\n`;
        }
        //Ports
        if (ports.length > 0) {
            str += `${space} ${name}_dut (\n`;
            for (let x = 0; x < ports.length - 1; ++x) {
                str += `${space}    ${ports[x]['name']},\n`;
            }
            str += `${space}    ${ports[ports.length - 1]['name']}\n`;
            str += `${space}  );\n`;
        }
        return str;
    }

    set_instance2001(space, name, generics, ports) {
        var str = '';
        //Instance name
        str += `${space} ${name} \n`;
        //Parameters
        if (generics.length > 0) {
            str += `${space}  #(\n`;
            for (let x = 0; x < generics.length - 1; ++x) {
                str += `${space}    .${generics[x]['name']}(${generics[x]['name']} ),\n`;
            }
            str += `${space}    .${generics[generics.length - 1]['name']} (
          ${generics[generics.length - 1]['name']} )\n`;
            str += `${space}  )\n`;
        }
        //Ports
        if (ports.length > 0) {
            str += `${space} ${name}_dut (\n`;
            for (let x = 0; x < ports.length - 1; ++x) {
                str += `${space}    .${ports[x]['name']} (${ports[x]['name']} ),\n`;
            }
            str += `${space}    .${ports[ports.length - 1]['name']}  ( ${ports[ports.length - 1]['name']})\n`;
            str += `${space}  );\n`;
        }
        return str;
    }

    set_vunit_process(space) {
        var str = '';
        str += `${space}\`TEST_SUITE begin\n`;
        str += `${space}  // It is possible to create a basic test bench without any test cases\n`;
        str += `${space}  $display("Hello world");\n`;
        str += `${space}end\n`;
        return str;
    }

    set_main(space) {
        var str = '';
        str += `${space}initial begin\n`;
        str += `${space}  begin\n`;
        str += `${space}    $finish;\n`;
        str += `${space}  end\n`;
        str += `${space}end\n`;
        return str;
    }

    set_clk_process(space, ports) {
        var str = '';
        for (let x = 0; x < ports.length; ++x) {
            let is_clk = (ports[x]["direction"] === "input") &&
                (ports[x]["name"].includes("clk") || ports[x]["name"].includes("clock"));
            if (is_clk === true) {
                str += `${space}always\n`;
                str += `${space}  #5  ${ports[x]["name"]} = ! ${ports[x]["name"]} ;\n`;
            }
        }
        return str;
    }
}

class Verilog_component extends Verilog_editor {
    async generate(src, options) {
        let parser = new ParserLib.ParserFactory;
        parser = await parser.getParser(General.LANGUAGES.VERILOG, '');
        let structure = await parser.get_all(src);
        if (structure === undefined) {
            return undefined;
        }
        if (options === null) { return ""; }
        var component = "";
        if (options['type'] === Codes.TYPESCOMPONENTS.COMPONENT) {
            component = "";
        } else if (options['type'] === Codes.TYPESCOMPONENTS.INSTANCE) {
            component = this.set_instance2001('  ', structure['entity']['name'],
                structure['generics'], structure['ports'], false);
        } else if (options['type'] === Codes.TYPESCOMPONENTS.SIGNALS) {
            component = this.set_signals('  ', structure['ports']);
        }
        return component;
    }
}

class Vhdl_editor {
    constructor() { }

    async generate(src, options) {
        let parser = new ParserLib.ParserFactory;
        parser = await parser.getParser(General.LANGUAGES.VHDL, '');
        parser.init();
        let structure = await parser.get_all(src);
        if (structure === undefined) {
            return undefined;
        }
        let vunit = false;
        if (options !== null) {
            vunit = options['type'] === Codes.TYPESTESTBENCH.VUNIT;
        }
        let space = '  ';
        let str = '';
        str += "library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n";
        str += '\n';
        if (vunit === true) {
            str += this.set_Vunit_Libraries();
            str += '\n';
        }
        if (vunit === true) {
            str += this.set_Vunit_Entity(structure['entity']);
            str += '\n';
        } else {
            str += this.set_Entity(structure['entity']);
            str += '\n';
        }
        str += this.set_Architecture(structure['architecture'], structure['entity']);
        str += '\n';
        if (vunit === false) {
            str += this.set_Component(space, structure['entity']['name'], structure['generics'],
                structure['ports']);
        }
        str += '\n';
        str += this.set_Constants(space, structure['generics']);
        str += '\n';
        str += '  -- Ports\n';
        str += this.set_Signals(space, structure['ports']);
        str += '\n';
        str += 'begin\n';
        str += '\n';
        str += this.set_Instance(space, structure['entity']['name'], structure['generics'], structure['ports'], vunit);
        str += '\n';
        if (vunit === true) {
            str += this.set_Vunit_Process(space);
            str += '\n';
        }
        str += this.set_Clk_Process(space);
        str += '\n';
        str += 'end;\n';

        return str;
    }

    set_Vunit_Libraries() {
        var str = '';
        str += 'library src_lib;\n';
        str += '--\n';
        str += 'library vunit_lib;\n';
        str += 'context vunit_lib.vunit_context;\n';
        str += '-- use vunit_lib.array_pkg.all;\n';
        str += '-- use vunit_lib.lang.all;\n';
        str += '-- use vunit_lib.string_ops.all;\n';
        str += '-- use vunit_lib.dictionary.all;\n';
        str += '-- use vunit_lib.path.all;\n';
        str += '-- use vunit_lib.log_types_pkg.all;\n';
        str += '-- use vunit_lib.log_special_types_pkg.all;\n';
        str += '-- use vunit_lib.log_pkg.all;\n';
        str += '-- use vunit_lib.check_types_pkg.all;\n';
        str += '-- use vunit_lib.check_special_types_pkg.all;\n';
        str += '-- use vunit_lib.check_pkg.all;\n';
        str += '-- use vunit_lib.run_types_pkg.all;\n';
        str += '-- use vunit_lib.run_special_types_pkg.all;\n';
        str += '-- use vunit_lib.run_base_pkg.all;\n';
        str += '-- use vunit_lib.run_pkg.all;\n';
        return str;
    }

    set_Libraries(m) {
        var str = '';
        for (let x = 0; x < m.length; ++x) {
            str += 'use ' + m[x]['name'] + ';\n';
        }
        return str;
    }

    set_Entity(m) {
        var str = '';
        str += 'entity ' + m['name'] + '_tb is\n';
        str += 'end;\n';
        return str;
    }

    set_Vunit_Entity(m) {
        var str = '';
        str += 'entity ' + m['name'] + '_tb is\n';
        str += '  generic (runner_cfg : string);\n';
        str += 'end;\n';
        return str;
    }

    set_Architecture(m, n) {
        var str = '';
        str += 'architecture bench of ' + n['name'] + '_tb is\n';
        return str;
    }

    set_Constants(space, m) {
        var str = '';
        str += space + '-- Clock period\n';
        str += space + 'constant clk_period : time := 5 ns;\n';
        str += space + '-- Generics\n';
        for (let x = 0; x < m.length; ++x) {
            var normalized_type = m[x]['type'].replace(/\s/g, '').toLowerCase();
            if (normalized_type === "integer") {
                str += space + 'constant ' + m[x]['name'] + ' : ' + m[x]['type'] + ' := 0;\n';
            }
            else if (normalized_type === "signed" || normalized_type === "unsigned") {
                str += space + 'constant ' + m[x]['name'] + ' : ' + m[x]['type'] + " := (others => '0');\n";

            }
            else if (normalized_type === "string") {
                str += space + 'constant ' + m[x]['name'] + ' : ' + m[x]['type'] + ' := "";\n';
            }
            else if (normalized_type === "boolean") {
                str += space + 'constant ' + m[x]['name'] + ' : ' + m[x]['type'] + ' := false;\n';
            }
            else {
                str += space + 'constant ' + m[x]['name'] + ' : ' + m[x]['type'] + ';\n';
            }
        }
        return str;
    }

    set_Signals(space, m) {
        var str = '';
        for (let x = 0; x < m.length; ++x) {
            str += space + 'signal ' + m[x]['name'] + ' : ' + m[x]['type'] + ';\n';
        }
        return str;
    }

    set_Component(space, name, generics, ports) {
        var str = '';
        //Component name
        str += space + 'component ' + name + '\n';
        //Generics
        if (generics.length > 0) {
            str += space + '  generic (\n';
            for (let x = 0; x < generics.length - 1; ++x) {
                str += space + '    ' + generics[x]['name'] + ' : ' + generics[x]['type'] + ';\n';
            }
            str += space + '    ' + generics[generics.length - 1]['name'] + ' : ' +
                generics[generics.length - 1]['type'] + '\n';
            str += space + '  );\n';
        }
        //Ports
        if (ports.length > 0) {
            str += space + '  port (\n';
            for (let x = 0; x < ports.length - 1; ++x) {
                str += space + '    ' + ports[x]['name'] + ' : ' + ports[x]['direction'] + ' ' +
                    ports[x]['type'] + ';\n';
            }
            str += space + '    ' + ports[ports.length - 1]['name'] + ' : ' +
                ports[ports.length - 1]['direction'] + ' ' +
                ports[ports.length - 1]['type'] + '\n';
            str += space + '  );\n';
        }
        //End component
        str += space + 'end component;\n';

        return str;
    }

    set_Instance(space, name, generics, ports, vunit, vhdl2008) {
        var str = '';
        //Instance name
        if (vunit !== undefined && vunit === true) {
            str += space + name + '_inst : entity src_lib.' + name + '\n';
        } else if (vhdl2008 !== undefined && vhdl2008 === true) {
            str += space + name + '_inst : entity work.' + name + '\n';
        } else {
            str += space + name + '_inst : ' + name + '\n';
        }
        //Generics
        if (generics.length > 0) {
            str += space + '  generic map (\n';
            for (let x = 0; x < generics.length - 1; ++x) {
                str += space + '    ' + generics[x]['name'] + ' => ' + generics[x]['name'] + ',\n';
            }
            str += space + '    ' + generics[generics.length - 1]['name'] + ' => '
                + generics[generics.length - 1]['name'] + '\n';
            str += space + '  )\n';
        }
        //Ports
        if (ports.length > 0) {
            str += space + '  port map (\n';
            for (let x = 0; x < ports.length - 1; ++x) {
                str += space + '    ' + ports[x]['name'] + ' => ' + ports[x]['name'] + ',\n';
            }
            str += space + '    ' + ports[ports.length - 1]['name'] + ' => ' + ports[ports.length - 1]['name'] + '\n';
            str += space + '  );\n';
        }
        return str;
    }

    set_Vunit_Process(space) {
        var str = '';
        str += space + 'main : process\n';
        str += space + 'begin\n';
        str += space + '  test_runner_setup(runner, runner_cfg);\n';
        str += space + '  while test_suite loop\n';
        str += space + '    if run("test_alive") then\n';
        str += space + '      info("Hello world test_alive");\n';
        str += space + '      wait for 100 ns;\n';
        str += space + '      test_runner_cleanup(runner);\n';
        str += space + '      \n';
        str += space + '    elsif run("test_0") then\n';
        str += space + '      info("Hello world test_0");\n';
        str += space + '      wait for 100 ns;\n';
        str += space + '      test_runner_cleanup(runner);\n';
        str += space + '    end if;\n';
        str += space + '  end loop;\n';
        str += space + 'end process main;\n';
        return str;
    }

    set_Clk_Process(space) {
        var str = '';
        str += '-- ' + space + "clk_process : process\n";
        str += '-- ' + space + "begin\n";
        str += '-- ' + space + "  clk <= '1';\n";
        str += '-- ' + space + "  wait for clk_period/2;\n";
        str += '-- ' + space + "  clk <= '0';\n";
        str += '-- ' + space + "  wait for clk_period/2;\n";
        str += '-- ' + space + "end process clk_process;\n";
        return str;
    }
}

class Vhdl_component extends Vhdl_editor {
    async generate(src, options) {
        let parser = new ParserLib.ParserFactory;
        parser = await parser.getParser(General.LANGUAGES.VHDL, '');
        parser.init();
        let structure = await parser.get_all(src);
        if (structure === undefined) {
            return undefined;
        }
        if (options === null) { return ""; }
        var component = "";
        if (options['type'] === Codes.TYPESCOMPONENTS.COMPONENT) {
            component = this.set_Component('  ', structure['entity']['name'],
                structure['generics'], structure['ports'], false);
        } else if (options['type'] === Codes.TYPESCOMPONENTS.INSTANCE) {
            component = this.set_Instance('  ', structure['entity']['name'],
                structure['generics'], structure['ports'], false, false);
        } else if (options['type'] === Codes.TYPESCOMPONENTS.INSTANCE_VHDL2008) {
            component = this.set_Instance('  ', structure['entity']['name'],
                structure['generics'], structure['ports'], false, true);
        } else if (options['type'] === Codes.TYPESCOMPONENTS.SIGNALS) {
            component = this.set_Signals('  ', structure['ports']);
        }
        else {
            // eslint-disable-next-line no-console
            console.log("error");
        }
        return component;
    }
}