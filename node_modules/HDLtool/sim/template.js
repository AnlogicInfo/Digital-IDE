"use strict";

// Copyright 2020 Teros Technology
//
// Ismael Perez Rojo
// Carlos Alberto Ruiz Naranjo
// Alfredo Saez
//
// This file is part of Colibri.
//
// Colibri is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Colibri is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Colibri.  If not, see <https://www.gnu.org/licenses/>.


const vscode = require("vscode");

const TYPES = {
    COCOTB: 'cocotb',
    VUNIT : 'vunit',
    VERILATOR: 'verilator',
};

async function get_template() {
    if (!vscode.window.activeTextEditor) {
        return; // no editor
    }
    let picker_value = "";
    let document = vscode.window.activeTextEditor.document;
    let language_id = document.languageId;
    const TYPES_VHDL_INFO    = ["cocotb", "vunit"];
    const TYPES_VERILOG_INFO = ["cocotb", "vunit", "verilator"];
    if (language_id === "vhdl") {
        picker_value = await vscode.window.showQuickPick(TYPES_VHDL_INFO, 
            { placeHolder: 'Select the template type.'  });
        
    }
    else if (language_id === "verilog" || language_id === "systemverilog") {
        picker_value = await vscode.window.showQuickPick(TYPES_VERILOG_INFO, 
            { placeHolder: 'Select the template type.' });
    }
    else {
        return;
    }
    let code = document.getText();
    let templates_cl = new Templates_factory();
    let template = await templates_cl.get_template(picker_value, language_id);
    let template_str = await template.generate(code, options);
    //Error
    if (template_str === undefined) {
        vscode.window.showErrorMessage('Select a valid file.!');
        console.log("Error parser template.");
    }
    else {
        vscode.window.showInformationMessage('Template copied to clipboard!\n');
        vscode.env.clipboard.writeText(template_str);
    }
}
exports.get_template = get_template;

class Templates_factory {
    constructor() { }

    get_template(type, language) {
        let template;
        if (type === TYPES.VUNIT) {
            template = this.get_vunit_template();
        }
        else if (type === TYPES.COCOTB) {
            template = this.get_cocotb_template(language);
        }
        else if (type === TYPES.VERILATOR) {
            template = this.get_verilator_template();
        }
        return template;
    }

    get_cocotb_template(language) {
        return new cocotb(language);
    }

    get_verilator_template() {
        return new verilator();
    }

    get_vunit_template() {
        return new VUnit();
    }
}

class cocotb {
    constructor() { }
    // eslint-disable-next-line no-unused-vars
    async generate(structure) {
        let test = "";

        test += this.header();
        test += this.python_libraries();
        test += this.coco_test(structure.ports);
        test += this.register_test();
        return test;
    }

    header() {
        let test = "# -*- coding: utf-8 -*-\n";
        return test;
    }
    python_libraries() {
        let test = "import cocotb\n";
        test += "from cocotb.clock import Clock\n";
        test += "from cocotb.triggers import Timer\n";
        test += "from cocotb.regression import TestFactory\n";
        return test;
    }
    coco_test(ports) {
        let test_instance = "";
        test_instance += '\n@cocotb.test()\n';
        test_instance += 'async def run_test(dut):\n';
        test_instance += '    PERIOD = 10\n';

        // Search clock
        let clock_ports_index = [];
        for (let i = 0; i < ports.length; i++) {
            const port = ports[i];
            let is_clk = (port["type"] === "in" || port["type"] === "input")
                && (port["name"] === "clk" || port["name"].startsWith("clk")
                    || port["name"] === "clk" || port["name"].startsWith("aclk"));

            if (is_clk === true) {
                clock_ports_index.push(i);
                //Clock instance
                test_instance += `    cocotb.fork(Clock(dut.${port['name']}, PERIOD, 'ns').start(start_high=False))\n`;
            }
        }
        test_instance += '\n';
        //Ports instance to 0
        for (let i = 0; i < ports.length; i++) {
            const port = ports[i];
            if (clock_ports_index.includes(i) === false) {
                test_instance += `    dut.${port['name']} = 0\n`;
            }
        }
        test_instance += '\n';
        test_instance += `    await Timer(20*PERIOD, units='ns')\n\n`;
        //Ports instance to 1
        for (let i = 0; i < ports.length; i++) {
            const port = ports[i];
            if (clock_ports_index.includes(i) === false) {
                test_instance += `    dut.${port['name']} = 1\n`;
            }
        }
        test_instance += '\n';
        test_instance += `    await Timer(20*PERIOD, units='ns')\n`;

        return test_instance;
    }
    register_test() {
        let test_instance = "";
        test_instance += `
  # Register the test.
  factory = TestFactory(run_test)
  factory.generate_tests()
      `;
        return test_instance;
    }

}

class verilator {
    constructor() {
        this.str = "";
        this.str_out = "";
        this.path = require('path');
    }

    async generate(structure) {
        if (structure === undefined) {
            return undefined;
        }
        this.str = structure;
        this.header();
        this.loop();
        this.verilatortb();
        return this.str_out;
    }

    header() {
        this.str_out = "#include <stdlib.h>\n";
        this.str_out += '#include "V' + this.str.moduleName + '.h"\n';
        this.str_out += '#include "verilated.h"\n\n';
        this.str_out += 'int main(int argc, char **argv, char** env) {\n';
        this.str_out += '  // Initialize Verilators variables\n';
        this.str_out += '  Verilated::commandArgs(argc, argv);\n\n';
        this.str_out += '  // Create an instance of our module under test\n';
        this.str_out += '  V' + this.str.moduleName + ' *tb = new V' + this.str.moduleName + ';\n\n';
    }

    loop() {
        this.str_out += '// Tick the clock until we are done';
        this.str_out += '//  while(!Verilated::gotFinish()) {\n';
        for (var x = 0; x < this.str.ports.length; x++) {
            if (this.str.ports[x]["type"] === "input") {
                this.str_out += '//    tb-> ' + this.str.ports[x]["name"] + ' = 1;\n';
            }
        }
        for (let x = 0; x < this.str.ports.length; x++) {
            if (this.str.ports[x]["type"] === "output") {
                this.str_out += '//    printf(" Output ' + this.str.ports[x]["name"] + ': %d \\n",tb-> '
                    + this.str.ports[x]["name"] + ');\n';
            }
        }
        this.str_out += '//    tb->eval();\n';
        this.str_out += '//  } exit(EXIT_SUCCESS);\n\n';
        for (let x = 0; x < this.str.ports.length; x++) {
            if (this.str.ports[x]["type"] === "input") {
                this.str_out += '    tb-> ' + this.str.ports[x]["name"] + ' = 1;\n';
            }
        }
        this.str_out += '    tb->eval();\n';
        for (let x = 0; x < this.str.ports.length; x++) {
            if (this.str.ports[x]["type"] === "output") {
                this.str_out += '    printf(" Output ' + this.str.ports[x]["name"] + ': %d \\n",tb-> '
                    + this.str.ports[x]["name"] + ');\n';
            }
        }
        this.str_out += '   exit(EXIT_SUCCESS);\n}';
    }

    verilatortb() {
        this.header();
        this.loop();
    }
}

class VUnit {
    constructor() {
        this.str = null;
        this.str_out = "";
        this.path = require('path');
    }
    generate(structure) {
        this.str = structure;
        this.header();
        this.python_libraries();
        this.set_lang();
        this.separator();
        this.checks();
        this.separator();
        this.check_simulator();
        this.separator();
        this.vunit_instance();
        this.add_src();
        this.addTb();
        this.check_calls();
        this.separator();
        this.simulator_suport();
        this.separator();
        this.post_run_fcn();
        this.separator();
        this.run();
        return this.str_out;
    }

    header() {
        this.str_out = "# -*- coding: utf-8 -*-\n";
    }
    python_libraries() {
        this.str_out += "from os.path import join , dirname, abspath\nimport subprocess\nfrom vunit.sim_if.ghdl ";
        this.str_out += "import GHDLInterface\nfrom vunit.sim_if.factory import SIMULATOR_FACTORY\n";
    }
    set_lang() {
        if (this.str.lang === "vhdl") {
            this.str_out += "from vunit   import VUnit, VUnitCLI\n";
        }
        else if (this.str.lang === "verilog") {
            this.str_out += "from vunit.verilog   import VUnit, VUnitCLI\n";
        }
    }
    separator() {
        this.str_out += "\n################################################################################\n";
    }
    checks() {
        if (this.str.config.checks) {
            this.str_out += "#pre_config func\n";
            this.str_out += "def pre_config_func():\n";
            this.str_out += '    """\n';
            this.str_out += "    Before test.\n";
            this.str_out += '    """\n';
            this.str_out += "#post_check func\n";
            this.str_out += "def post_check_func():\n";
            this.str_out += '    """\n';
            this.str_out += "    After test.\n";
            this.str_out += '    """\n';
            this.str_out += "    def post_check(output_path):\n";
            this.str_out += "        check = True\n";
            this.str_out += "        return check\n";
            this.str_out += "    return post_check\n";
        }
    }
    check_simulator() {
        this.str_out += "#Check simulator.\n";
        this.str_out += 'print ("=============================================")\n';
        this.str_out += 'simname = SIMULATOR_FACTORY.select_simulator().name\n';
        if (this.str.config.simulator_suport.modelsim.enable) {
            this.check_modelsim();
        }
        if (this.str.config.simulator_suport.ghdl.enable) {
            this.check_ghdl();
        }
        this.str_out += 'print ("Simulator = " + simname)\n';
        this.str_out += 'print ("=============================================")\n';
    }
    check_modelsim() {
        this.str_out += 'code_coverage = False\n';
        this.str_out += 'if (simname == "modelsim"):\n';
        this.str_out += '    f= open("modelsim.do","w+")\n';
        this.str_out += '    f.write("add wave * \\nlog -r /*\\nvcd file\\nvcd add -r /*\\n")\n';
        this.str_out += '    f.close()\n';
    }
    check_ghdl() {
        this.str_out += 'code_coverage = (simname == "ghdl" and \\\n';
        this.str_out += '                (GHDLInterface.determine_backend("")=="gcc" or  \\\n';
        this.str_out += '                GHDLInterface.determine_backend("")=="GCC"))\n';
    }
    vunit_instance() {
        this.str_out += '#VUnit instance.\n';
        this.str_out += 'ui = VUnit.from_argv()\n';
    }
    add_src() {
        this.str_out += '\n#Add module sources.\n';
        this.str_out += this.str.config["name"] + '_src_lib = ui.add_library("src_lib")\n';
        for (var x = 0; x < this.str.src.length; x++) {
            let file = this.path.relative(this.str.config["output_path"], this.str.src[x]);
            file.replace("\\", "\\\\");
            this.str_out += this.str.config["name"] + '_src_lib.add_source_files("' + file + '")\n';
        }
    }
    addTb() {
        this.str_out += '\n#Add tb sources.\n';
        this.str_out += this.str.config["name"] + '_tb_lib = ui.add_library("tb_lib")\n';
        for (var x = 0; x < this.str.tb.length; x++) {
            let file = this.path.relative(this.str.config["output_path"], this.str.tb[x]);
            file.replace("\\", "\\\\");
            this.str_out += this.str.config["name"] + '_tb_lib.add_source_files("' + file + '")\n';
        }
    }
    check_calls() {
        if (this.str.config.checks) {
            let file = this.path.relative(this.str.config["output_path"], this.str.tb[0]);
            file.replace("\\", "\\\\");
            this.str_out += '\n#func checks\n';
            this.str_out += 'tb_generated = ' + this.str.config["name"] + '_tb_lib.test_bench("' + file.split(".")[0] + '")\n';
            this.str_out += 'for test in tb_generated.get_tests():\n';
            this.str_out += '    test.add_config(name="test_alive", pre_config=pre_config_func()';
            this.str_out += ',post_check=post_check_func())\n';
        }
    }
    simulator_suport() {
        if (this.str.config.simulator_suport.ghdl.enable) {
            this.str_out += '#Simulators flags.\n';
            this.str_out += 'if(code_coverage == True):\n';
            this.ghdl_config(true);
            this.str_out += 'else:\n';
            this.ghdl_config(false);
        }
        if (this.str.config.simulator_suport.modelsim.enable) {
            this.str_out += '\n';
            this.modelsim_config();
        }
        if (this.str.config.simulator_suport.ghdl.config.disable_ieee_warnings) {
            this.disable_ieee_warnings();
        }
    }
    ghdl_config(coverage) {
        let flags_vars = ' ';
        let sim_vars = ' ';
        let sep = ' ';
        if (this.str.config.simulator_suport.ghdl.config.synopsys_libraries) {
            let synopsys_var = '"-fexplicit","--ieee=synopsys","--no-vital-checks","-frelaxed-rules"';
            flags_vars += synopsys_var;
            sim_vars += synopsys_var;
            sep = ',';
        }
        if (coverage) {
            if (this.str.config.simulator_suport.ghdl.config.code_coverage.enable) {
                let code_coverage_var = '"-fprofile-arcs","-ftest-coverage"';
                let code_coverage_sim = '"-Wl,-lgcov"';
                flags_vars += sep + code_coverage_var;
                sim_vars += sep + code_coverage_sim;
            }
        }
        this.str_out += '    ' + this.str.config["name"]
            + '_src_lib.add_compile_option   ("ghdl.flags"     , [ ' + flags_vars + '])\n';
        this.str_out += '    ' + this.str.config["name"]
            + '_tb_lib.add_compile_option    ("ghdl.flags"     , [ ' + flags_vars + '])\n';
        this.str_out += '    ui.set_sim_option("ghdl.elab_flags", [' + sim_vars + '])\n';
    }
    modelsim_config() {
        this.str_out += 'ui.set_sim_option("modelsim.init_files.after_load" ,["modelsim.do"])\n';
    }
    disable_ieee_warnings() {
        this.str_out += 'ui.set_sim_option("disable_ieee_warnings", True)\n';
    }
    post_run_fcn() {
        this.str_out += 'def post_run_fcn(results):\n';
        this.str_out += '    if(code_coverage == True ):\n';
        for (var x = 0; x < this.str.src.length; x++) {
            this.str_out += '        subprocess.call(["lcov", "--capture", "--directory", "'
                + this.path.basename(this.str.src[x]).split(".")[0]
                + '.gcda", "--output-file",  "code_' + x.toString() + '.info" ])\n';
        }
        this.str_out += '        subprocess.call(["genhtml"';
        for (let x = 0; x < this.str.src.length; x++) {
            this.str_out += ',"code_' + x.toString() + '.info"',
                +this.str.config.simulator_suport.ghdl.config.code_coverage["output_path"] + '"])\n';
        }
        this.str_out += ',"--output-directory", "'
            + this.str.config.simulator_suport.ghdl.config.code_coverage["output_path"] + '"])\n';
    }
    run() {
        this.str_out += '#Run tests.\n';
        this.str_out += 'ui.main(post_run=post_run_fcn)\n';
    }
}