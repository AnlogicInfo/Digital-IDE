"use strict";

const fs      = require("fs");
const child   = require("child_process");
const fspath  = require("path");
const vscode  = require("vscode");
const parser  = require("HDLparser");
const filesys = require("HDLfilesys");

let gtkwaveInstallPath = vscode.workspace.getConfiguration().get('TOOL.gtkwave.install.path');

function Overwrite_tb(opeParam) {
    let tbSourcePath = "";
    vscode.window.showQuickPick(['vlog','vhdl'],{placeHolder:"Which type you want to Overwrite?"}).then(select => {
        if (select == "vlog") {
            tbSourcePath = `${opeParam.rootPath}/../lib/src_lib/Hardware/testbench.v`;
        } else if (select == "vhdl") {
            tbSourcePath = `${opeParam.rootPath}/../lib/src_lib/Hardware/testbench.vhd`;
        }
        const options = {
            preview: false,
            viewColumn: vscode.ViewColumn.Active
        };
        vscode.window.showTextDocument(vscode.Uri.file(tbSourcePath), options);
    });
}
exports.Overwrite_tb = Overwrite_tb;

function generatetbFile(opeParam) {
    let tbFilePath = "";
    let tbSourcePath = "";
    vscode.window.showQuickPick(['vlog','vhdl'],{placeHolder:"Which type you want to generate?"}).then(select => {
        // "Which type you want to generate?"
        if (select == "vlog") {
            tbFilePath   = `${opeParam.currentSrcPath}/sim/testbench.v`;
            tbSourcePath = `${opeParam.rootPath}/../lib/src_lib/Hardware/testbench.v`;
        } else if (select == "vhdl") {
            tbFilePath   = `${opeParam.currentSrcPath}/sim/testbench.vhd`;
            tbSourcePath = `${opeParam.rootPath}/../lib/src_lib/Hardware/testbench.vhd`;
        }
        if (!fs.existsSync(tbFilePath)) {
            let tb_template = fs.readFileSync(tbSourcePath, 'utf8');
            filesys.dirs.mkdir(fspath.dirname(tbSourcePath));
            fs.writeFileSync(tbFilePath, tb_template, 'utf8');
        } else {
            vscode.window.showWarningMessage("testbench file already exists !!!");
        }
    });
}
exports.generatetbFile = generatetbFile;

class iverilogSimulate {
    constructor(opeParam) {
        this.opeParam = opeParam;
        this.simLibRootPath = "";
        this.LibPath  = "";
        this.GlblPath = "";
        this.setting  = vscode.workspace.getConfiguration();
        this.getConfig();
        vscode.workspace.onDidChangeConfiguration(function () {
            this.getConfig();
        });
    }

    getConfig() {
        this.installPath = this.setting.get('TOOL.iverilog.install.path');
        this.runFilePath = this.setting.get('HDL.linting.runFilePath');
    }

    getInstmoduleFilePathList(indexer, module, instmoduleFilePathList) {
        for (let i = 0; i < indexer.HDLparam.length; i++) {
            const unitModule = indexer.HDLparam[i];
            if (unitModule.moduleName == module) {
                for (let i = 0; i < unitModule.instances.length; i++) {
                    const instanceModule = unitModule.instances[i];
                    instmoduleFilePathList.push(instanceModule.instModPath);
                    this.getInstmoduleFilePathList(indexer, instanceModule.instModule, instmoduleFilePathList);
                }
                break;
            }         
        }
    }

    simulate(indexer) {
        this.getConfig();
        let editor = vscode.window.activeTextEditor;
        if (!editor) {
            return;
        }

        // 获取当前文件的模块名和模块数 选择要仿真的模块
        let moduleNameList = [];
        for (let i = 0; i < indexer.HDLparam.length; i++) {
            const element = indexer.HDLparam[i];
            if (element.modulePath == editor.document.fileName.replace(/\\/g,"\/").replace("//","/")) {
                moduleNameList.push(element.moduleName);
            }
        }

        if (moduleNameList.length == 0) {
            vscode.window.showWarningMessage("There is no module in this file");
        }
        else {
            if (moduleNameList.length == 1) {
                this.execSimulation(editor, moduleNameList[0]);
            } else {
                vscode.window.showQuickPick(moduleNameList, {placeHolder:"Which type you want to generate?"}).then((module) => {
                    this.execSimulation(editor, module);
                });
            }
        }         
    }

    execSimulation(editor, module) {
        let rtlFilePath  = "";    
        // 获取运行时的路径
        if (this.runFilePath == "") {
            this.runFilePath = `${this.opeParam.workspacePath}prj/simulation/iVerilog`
            filesys.dirs.mkdir(this.runFilePath);
        }

        // 获取运行工具的路径
        let vvpPath      = "vvp";
        let gtkwavePath  = "gtkwave";
        let iVerilogPath = "iverilog";
        if (this.installPath != "") {
            vvpPath = this.installPath + "vvp.exe";
            iVerilogPath = this.installPath + "iverilog.exe";
        }
        if (gtkwaveInstallPath != "") {
            gtkwavePath = gtkwaveInstallPath + "gtkwave.exe";
        }

        // 获取对应厂商的仿真库路径
        if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
            if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {
                this.xilinxLibPath();
            }				
        }         

        // 获取所有例化模块所在文件的路径
        let instmoduleFilePathList = [];
        this.getInstmoduleFilePathList(indexer, module, instmoduleFilePathList);
        instmoduleFilePathList = this.removeDuplicates(instmoduleFilePathList);
        instmoduleFilePathList.forEach(element => {
            rtlFilePath = rtlFilePath + element + " ";
        });
        
        let command = `${iVerilogPath} -g2012 -o ${this.runFilePath}/out.vvp -s ${module} ` + 
        `${editor.document.fileName} `.replace(/\\/g,"\/").replace("//","/") + 
        `${rtlFilePath} `.replace(/\\/g,"\/").replace("//","/") + 
        `${this.GlblPath} ` + 
        `${this.LibPath}`;

        let currentRunFilePath = this.runFilePath;
        let waveImagePath = parser.utils.getWaveImagePath(editor.document.getText());
        child.exec(command, { cwd: currentRunFilePath }, function (error, stdout, stderr) {
            vscode.window.showInformationMessage(stdout);
            if (error !== null) {
                vscode.window.showErrorMessage(stderr);
            } else {
                vscode.window.showInformationMessage("iVerilog simulates successfully!!!");
                if (waveImagePath != '') {
                    let Exists_flag = false;
                    var vvp = null;
                    vscode.window.terminals.forEach(element => {
                        if (element.name == "vvp") {
                            vvp = element;
                            Exists_flag = true;
                            return;
                        }
                    });
                    if (!Exists_flag) {
                        vvp = vscode.window.createTerminal({ name: 'vvp' });
                    }
                    let waveImageExtname = waveImagePath.split('.');
                    let cmd = `${vvpPath} ${currentRunFilePath}/out.vvp -${waveImageExtname[waveImageExtname.length-1]}`;
                    vvp.show(true);
                    vvp.sendText(cmd);
                    vvp.sendText(`${gtkwavePath} ${waveImagePath}`);
                } else {
                    vscode.window.showWarningMessage("There is no wave image path in this testbench");
                }
            }
        });
    }

    xilinxLibPath() {
        this.simLibRootPath = this.setting.get('SIM.Xilinx.LIB.path');
        if (this.simLibRootPath != "") {
            this.GlblPath = this.simLibRootPath + "/glbl.v ";
            this.LibPath  = "-y " + this.simLibRootPath + "/xeclib ";
            this.LibPath  = this.LibPath + "-y " + this.simLibRootPath + "/unisims ";
            this.LibPath  = this.LibPath + "-y " + this.simLibRootPath + "/unimacro ";
            this.LibPath  = this.LibPath + "-y " + this.simLibRootPath + "/unifast ";
            this.LibPath  = this.LibPath + "-y " + this.simLibRootPath + "/retarget ";
        } else {
            vscode.window.showInformationMessage("SIM.Xilinx.LIB.path is empty");
        }
    }

    removeDuplicates(arry) {
        let r = [];
        for(var i = 0, l = arry.length; i < l; i++) {
            for(var j = i + 1; j < l; j++)
            if (arry[i] === arry[j]) j = ++i;
            r.push(arry[i]);
        }
        return r;
    }
}
exports.iverilogSimulate = iverilogSimulate;
