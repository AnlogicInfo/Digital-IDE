"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });

const fs     = require("fs");
const fspath = require("path");
const vscode = require("vscode");
const parser = require("HDLparser");

function Overwrite_tb(opeParam) {
    const path = `${opeParam.rootPath}/.TOOL/.Data/testbench.v`;
    const options = {
        preview: false,
        viewColumn: vscode.ViewColumn.Active
    };
    vscode.window.showTextDocument(vscode.Uri.file(path), options);
}
exports.Overwrite_tb = Overwrite_tb;


function iverilogSimulate(opeParam, HDLparam) {
    let editor = vscode.window.activeTextEditor;
    if (!editor) {
        return;
    }
    // 获取运行时的路径
    if (this.runFilePath == "") {
        this.runFilePath = `${opeParam.workspacePath}prj/simulation/iVerilog`
        this.folder.mkdir(this.runFilePath);
    }

    // 获取运行工具的路径
    let vvpPath      = "vvp";
    let gtkwavePath  = "gtkwave";
    let iVerilogPath = "iverilog";
    if (this.installPath != "") {
        vvpPath = iVerilogInstallPath + "vvp.exe";
        iVerilogPath = iVerilogInstallPath + "iverilog.exe";
    }
    if (gtkwaveInstallPath != "") {
        gtkwavePath = gtkwaveInstallPath + "gtkwave.exe";
    }

    // 获取对应厂商的仿真库路径
    let LibPath = "";
    let GlblPath = "";
    let simLibRootPath = "";
    if (opeParam.propertyPath != '') {
        if (this.property.getFpgaVersion(opeParam.propertyPath) == "xilinx") {					
            simLibRootPath = vscode.workspace.getConfiguration().get('TOOL.xilinx.install.path');
            if (simLibRootPath != "") {                
                simLibRootPath = simLibRootPath + "/Vivado/2018.3/data/verilog/src";
                GlblPath = simLibRootPath + "/glbl.v ";
                LibPath  = "-y " + simLibRootPath + "/xeclib ";
                LibPath = LibPath + "-y " + simLibRootPath + "/unisims ";
                LibPath = LibPath + "-y " + simLibRootPath + "/unimacro ";
                LibPath = LibPath + "-y " + simLibRootPath + "/unifast ";
                LibPath = LibPath + "-y " + simLibRootPath + "/retarget ";
            } else {
                vscode.window.showInformationMessage("TOOL.xilinx.install.path is empty");
            }
        }
    }

    // 获取当前文件的模块名和模块数
    let moduleNameList = [];
    HDLparam.forEach(element => {
        if (element.modulePath == editor.document.fileName) {
            moduleNameList.push(element.moduleName);
        }
    });
    if (moduleNameList.length != 0) {
        // 选择要仿真的模块
        let simModuleName = '';
        if (moduleNameList.length >= 2) {
            vscode.window.showInformationMessage("There are multiple modules, please select one of them");
            simModuleName = __awaiter(this, void 0, void 0, function* () {
                vscode.window.showQuickPick(moduleNameList).then(selection => {
                    if (!selection) {
                        return null;
                    } else {
                        return selection;
                    }
                });
            });
        }
        else {
            simModuleName = moduleNameList[0];
        }
        let rtlFilePath  = "";
        let iverilogPath = "";
        iverilogPath = opeParam.workspacePath + "prj/simulation/iVerilog/" + simModuleName;
        iverilogPath = editor.document.fileName;                    

        // 获取所有例化模块所在文件的路径
        let instmoduleFilePathList = [];
        HDLparam.forEach(unitModule => {     
            if (unitModule.moduleName == simModuleName) {
                unitModule.instmodule.forEach(instanceModule => {
                    instmoduleFilePathList.push(instanceModule.instModPath);
                });
            }          
        });
        instmoduleFilePathList = this.array.removeDuplicates(instmoduleFilePathList);
        instmoduleFilePathList.forEach(element => {
            rtlFilePath = rtlFilePath + element + " ";
        });
    
        let command = `${iVerilogPath} -g2012 -o ${iverilogPath} ${editor.document.fileName} ${rtlFilePath} ${GlblPath} ${LibPath}`;

        let waveImagePath = this.parse.getWaveImagePath(editor.document.text);
        child.exec(command, { cwd: this.runFilePath }, function (error, stdout, stderr) {
            vscode.window.showInformationMessage(stdout);
            if (error !== null) {
                vscode.window.showErrorMessage(stderr);
            } else {
                vscode.window.showInformationMessage("iVerilog simulates successfully!!!");
                if (waveImagePath != '') {
                    let waveImageExtname = waveImagePath.split('.');
                    let Simulate = vscode.window.createTerminal({ name: 'Simulate' });
                    Simulate.show(true);
                    Simulate.sendText(`${vvpPath} ${iverilogPath} -${waveImageExtname[waveImageExtname.length-1]}`);
                    let gtkwave = vscode.window.createTerminal({ name: 'gtkwave' });
                    gtkwave.show(true);
                    gtkwave.sendText(`${gtkwavePath} ${waveImagePath}`);

                } else {
                    vscode.window.showWarningMessage("There is no wave image path in this testbench");
                }
            }
        });
    }         
    else {
        vscode.window.showWarningMessage("There is no module in this file")
    }
}

class netlist_manager {
    constructor(context) {
        this.panel = undefined;
        this.context = context;
    }
    open_viewer() {
        return __awaiter(this, void 0, void 0, function* () {
            this.create_viewer();
        });
    }
    create_viewer() {
        return __awaiter(this, void 0, void 0, function* () {
            // Create panel
            this.panel = vscode.window.createWebviewPanel('netlist_viewer', 'Schematic viewer', vscode.ViewColumn.Two, {
                enableScripts: true
            });
            this.panel.onDidDispose(() => {
                // When the panel is closed, cancel any future updates to the webview content
                this.panel = undefined;
            }, null, this.context.subscriptions);
            // Handle messages from the webview
            this.panel.webview.onDidReceiveMessage(message => {
                switch (message.command) {
                    case 'export':
                        this.export_as(message.type, message.svg);
                        return;
                    case 'html_loaded':
                        this.update_viewer_last_code();
                        return;
                }
            }, undefined, this.context.subscriptions);
            let previewHtml = this.getWebviewContent(this.context);
            this.panel.webview.html = previewHtml;
            let code = yield this.get_code(undefined);
            if (code !== undefined) {
                this.code = code;
            }
        });
    }
    show_export_message(path_full) {
        vscode.window.showInformationMessage(`Schematic saved in ${path_full} 😊`);
    }
    export_as(type, svg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (type === "svg") {
                let filter = { 'svg': ['svg'] };
                vscode.window.showSaveDialog({ filters: filter }).then(fileInfos => {
                    if ((fileInfos === null || fileInfos === void 0 ? void 0 : fileInfos.path) !== undefined) {
                        let path_full = this.normalize_path(fileInfos === null || fileInfos === void 0 ? void 0 : fileInfos.path);
                        fs.writeFileSync(path_full, svg);
                        this.show_export_message(path_full);
                    }
                });
            }
            else {
                console.log("Error export documentation.");
            }
        });
    }
    normalize_path(path) {
        if (path[0] === '/' && require('os').platform() === 'win32') {
            return path.substring(1);
        }
        else {
            return path;
        }
    }
    send_code(code) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let filename = this.document.fileName;
            if (code !== undefined) {
                yield ((_a = this.panel) === null || _a === void 0 ? void 0 : _a.webview.postMessage({ command: "update", code: code, filename: filename }));
            }
        });
    }
    get_code(document_trigger) {
        return __awaiter(this, void 0, void 0, function* () {
            let document = document_trigger;
            if (document_trigger === undefined) {
                let active_editor = vscode.window.activeTextEditor;
                if (!active_editor) {
                    return; // no editor
                }
                document = active_editor.document;
            }
            let language_id = document.languageId;
            let code = document.getText();
            if (language_id !== "verilog" && language_id !== 'systemverilog') {
                return;
            }
            this.document = document;
            return code;
        });
    }
    update_viewer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.panel !== undefined) {
                let code = yield this.get_code(undefined);
                this.code = code;
                yield this.send_code(code);
            }
        });
    }
    update_viewer_last_code() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.panel !== undefined) {
                yield this.send_code(this.code);
            }
        });
    }
    update_visible_viewer(e) {
        return __awaiter(this, void 0, void 0, function* () {
            if (e.length !== 1) {
                return;
            }
            let document = e[0].document;
            if (this.panel !== undefined) {
                let code = yield this.get_code(document);
                this.code = code;
                yield this.send_code(code);
            }
        });
    }
    getWebviewContent(context) {
        const resource_path = fspath.dirname(`${__dirname}`) + fspath.sep + 'build' + fspath.sep  + 'synth' + fspath.sep + 'netlist_viewer.html';
        const dir_path = fspath.dirname(resource_path);
        let html = fs.readFileSync(resource_path, 'utf-8');
        html = html.replace(/(<link.+?href="|<script.+?src="|<img.+?src=")(.+?)"/g, (m, $1, $2) => {
            return $1 + vscode.Uri.file(fspath.resolve(dir_path, $2)).with({ scheme: 'vscode-resource' }).toString() + '"';
        });
        return html;
    }
}
exports.netlist_manager = netlist_manager;