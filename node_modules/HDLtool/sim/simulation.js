"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });

const fs      = require("fs");
const child   = require("child_process");
const fspath  = require("path");
const vscode  = require("vscode");
const parser  = require("HDLparser");
const filesys = require("HDLfilesys");

let gtkwaveInstallPath = vscode.workspace.getConfiguration().get('TOOL.gtkwave.install.path');

function Overwrite_tb(opeParam) {
    let tbSourcePath = "";
    vscode.window.showInformationMessage("Which type you want to Overwrite?",'vlog','vhdl').then(function(select){
        if (select == "vlog") {
            tbSourcePath = `${opeParam.rootPath}/../lib/src_lib/Hardware/testbench.v`;
        } else if (select == "vhdl") {
            tbSourcePath = `${opeParam.rootPath}/../lib/src_lib/Hardware/testbench.vhd`;
        }
    });
    const options = {
        preview: false,
        viewColumn: vscode.ViewColumn.Active
    };
    vscode.window.showTextDocument(vscode.Uri.file(tbSourcePath), options);
}
exports.Overwrite_tb = Overwrite_tb;

function generatetbFile(opeParam) {
    let tbFilePath = "";
    let tbSourcePath = "";
    vscode.window.showInformationMessage("Which type you want to generate?",'vlog','vhdl').then(function(select){
        if (select == "vlog") {
            tbFilePath   = `${opeParam.currentSrcPath}testbench.v`;
            tbSourcePath = `${opeParam.rootPath}/../lib/src_lib/Hardware/testbench.v`;
        } else if (select == "vhdl") {
            tbFilePath   = `${opeParam.currentSrcPath}testbench.vhd`;
            tbSourcePath = `${opeParam.rootPath}/../lib/src_lib/Hardware/testbench.vhd`;
        }
    });
    if (!fs.existsSync(tbFilePath)) {
        let tb_template = fs.readFileSync(tbSourcePath, 'utf8');
        fs.writeFileSync(tbFilePath, tb_template, 'utf8');
    } else {
        vscode.window.showWarningMessage("testbench file already exists !!!");
    }
}
exports.generatetbFile = generatetbFile;

class iverilogSimulate {
    constructor(opeParam, HDLparam) {
        this.opeParam = opeParam;
        this.HDLparam = HDLparam;
        this.setting  = vscode.workspace.getConfiguration();
        vscode.workspace.onDidChangeConfiguration(function () {
            this.getConfig();
        });
    }
    getConfig() {
        this.installPath  = this.setting.get('TOOL.iVerilog.install.path');
        this.runFilePath  = this.setting.get('HDL.linting.runFilePath');
        this.iverilogArgs = this.setting.get('HDL.linting.iverilog.arguments');
    }
    simulate() {
        let editor = vscode.window.activeTextEditor;
        if (!editor) {
            return;
        }
        // 获取运行时的路径
        if (this.runFilePath == "") {
            this.runFilePath = `${this.opeParam.workspacePath}prj/simulation/iVerilog`
            filesys.dirs.mkdir(this.runFilePath);
        }

        // 获取运行工具的路径
        let vvpPath      = "vvp";
        let gtkwavePath  = "gtkwave";
        let iVerilogPath = "iverilog";
        if (this.installPath != "") {
            vvpPath = iVerilogInstallPath + "vvp.exe";
            iVerilogPath = iVerilogInstallPath + "iverilog.exe";
        }
        if (gtkwaveInstallPath != "") {
            gtkwavePath = gtkwaveInstallPath + "gtkwave.exe";
        }

        // 获取对应厂商的仿真库路径
        let LibPath = "";
        let GlblPath = "";
        let simLibRootPath = "";
        if (this.opeParam.propertyPath != '') {
            if (this.property.getFpgaVersion(this.opeParam.propertyPath) == "xilinx") {					
                simLibRootPath = vscode.workspace.getConfiguration().get('TOOL.xilinx.install.path');
                if (simLibRootPath != "") {                
                    simLibRootPath = simLibRootPath + "/Vivado/2018.3/data/verilog/src";
                    GlblPath = simLibRootPath + "/glbl.v ";
                    LibPath  = "-y " + simLibRootPath + "/xeclib ";
                    LibPath = LibPath + "-y " + simLibRootPath + "/unisims ";
                    LibPath = LibPath + "-y " + simLibRootPath + "/unimacro ";
                    LibPath = LibPath + "-y " + simLibRootPath + "/unifast ";
                    LibPath = LibPath + "-y " + simLibRootPath + "/retarget ";
                } else {
                    vscode.window.showInformationMessage("TOOL.xilinx.install.path is empty");
                }
            }
        }

        // 获取当前文件的模块名和模块数 选择要仿真的模块
        let simModule = parser.simParser.selectCurrentFileModule(this.HDLparam,editor.document);
        if (simModule != null) {
            let rtlFilePath  = "";
            let iverilogPath = "";
            iverilogPath = editor.document.fileName;                    

            // 获取所有例化模块所在文件的路径
            let instmoduleFilePathList = [];
            HDLparam.forEach(unitModule => {     
                if (unitModule.moduleName == simModuleName) {
                    unitModule.instmodule.forEach(instanceModule => {
                        instmoduleFilePathList.push(instanceModule.instModPath);
                    });
                }          
            });
            instmoduleFilePathList = this.array.removeDuplicates(instmoduleFilePathList);
            instmoduleFilePathList.forEach(element => {
                rtlFilePath = rtlFilePath + element + " ";
            });
        
            let command = `${iVerilogPath} -g2012 -o ${iverilogPath} ${editor.document.fileName} ${rtlFilePath} ${GlblPath} ${LibPath}`;

            let waveImagePath = parser.simParser.getWaveImagePath(editor.document.text);
            child.exec(command, { cwd: this.runFilePath }, function (error, stdout, stderr) {
                vscode.window.showInformationMessage(stdout);
                if (error !== null) {
                    vscode.window.showErrorMessage(stderr);
                } else {
                    vscode.window.showInformationMessage("iVerilog simulates successfully!!!");
                    if (waveImagePath != '') {
                        let waveImageExtname = waveImagePath.split('.');
                        let Simulate = vscode.window.createTerminal({ name: 'Simulate' });
                        Simulate.show(true);
                        Simulate.sendText(`${vvpPath} ${iverilogPath} -${waveImageExtname[waveImageExtname.length-1]}`);
                        let gtkwave = vscode.window.createTerminal({ name: 'gtkwave' });
                        gtkwave.show(true);
                        gtkwave.sendText(`${gtkwavePath} ${waveImagePath}`);

                    } else {
                        vscode.window.showWarningMessage("There is no wave image path in this testbench");
                    }
                }
            });
        }         
        else {
            vscode.window.showWarningMessage("There is no module in this file")
        }
    }
}
exports.iverilogSimulate = iverilogSimulate;
