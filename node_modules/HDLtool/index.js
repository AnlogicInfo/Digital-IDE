"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const vscode = require("vscode");

const soc    = require("./soc/soc");
const tree   = require("./tree/tree");
const build  = require("./build/build");
const debug  = require("./debug/debug");
const xilinx = require("./build/xilinx");

const lspAlignment  = require("./lsp/alignment");
const lspProvider   = require("./lsp/provider");
const lspCompletion = require("./lsp/completion");

const simulation   = require("./sim/simulation");
const simInstance  = require("./sim/Instance");
const simTestbench = require("./sim/Testbench");

exports.tree    = tree;
exports.build   = build;
exports.xilinx  = xilinx;
exports.lspAlignment  = lspAlignment;
exports.lspProvider   = lspProvider;
exports.lspCompletion = lspCompletion;
exports.simulation    = simulation;
exports.simInstance   = simInstance;
exports.simTestbench  = simTestbench;

function registerLspServer(context, indexer, vlogComplete) {
    
    context.subscriptions.push(vscode.commands.registerCommand('TOOL.alignment', lspAlignment.smartIndent));
    // Configure Provider manager
    const HDL_lsp = [
        { scheme: 'file', language: 'systemverilog' }, 
        { scheme: 'file', language: 'verilog' },
        { scheme: 'file', language: 'vhdl' }
    ];
    
    // VHDL Language sever
    vscode.languages.setLanguageConfiguration(HDL_lsp[2].language, {
        indentationRules: {
            increaseIndentPattern: /^.*(begin|then|loop|is)$/,
            decreaseIndentPattern: /^end\s+\w*$/
        },
        wordPattern: /(-?\d*\.\d\w*)|([^\`\~\!\@\#\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g,
    });
    vscode.languages.registerCompletionItemProvider(
        HDL_lsp[2], 
        new lspCompletion.vhdlCompletion(), 
        ['.', '\"']);
    vscode.languages.registerCompletionItemProvider(
        HDL_lsp[1], 
        vlogComplete, 
        '.');
    vscode.languages.registerCompletionItemProvider(
        { scheme: 'file', language: 'json' }, 
        new lspCompletion.jsonCompletion(),
        '/');
    // Providers
    const hovProvider = new lspProvider.HoverProvider();
    const numProvider = new lspProvider.numberHoverProvider();
    const docProvider = new lspProvider.DocumentSymbolProvider(indexer);
    const symProvider = new lspProvider.WorkspaceSymbolProvider(indexer);
    const defProvider = new lspProvider.DefinitionProvider(symProvider);
    context.subscriptions.push(vscode.languages.registerHoverProvider(HDL_lsp, hovProvider));
    context.subscriptions.push(vscode.languages.registerHoverProvider(HDL_lsp, numProvider));
	context.subscriptions.push(vscode.languages.registerWorkspaceSymbolProvider(symProvider));
    context.subscriptions.push(vscode.languages.registerDefinitionProvider(HDL_lsp, defProvider));
    context.subscriptions.push(vscode.languages.registerDocumentSymbolProvider(HDL_lsp, docProvider));
}
exports.registerLspServer = registerLspServer;

function registerSimServer(indexer, opeParam){
    var simulate = new simulation.iverilogSimulate(opeParam);
    vscode.commands.registerCommand('TOOL.simulate', () => {
        simulate.simulate(indexer);
    });
    vscode.commands.registerCommand('TOOL.instance', () => {
        simInstance.instantiateModuleInteract(indexer);
    });
    vscode.commands.registerCommand('TOOL.testbench', () => {
        simTestbench.genInstancetoTbFile(indexer);
    });
    vscode.commands.registerCommand('TOOL.Generate_tb', () => {
        simulation.generatetbFile(opeParam);
    });
    vscode.commands.registerCommand('TOOL.Overwrite_tb', () => {
        simulation.Overwrite_tb(opeParam);
    });
}
exports.registerSimServer = registerSimServer;

function registerTreeServer(opeParam){
    // // Tree View
    vscode.window.registerTreeDataProvider('TOOL.sdk_tree' , new tree.sdkTreeDataProvider(opeParam));
    vscode.window.registerTreeDataProvider('TOOL.fpga_tree', new tree.fpgaTreeDataProvider(opeParam));
    vscode.window.registerTreeDataProvider('TOOL.Tool_tree', new tree.toolTreeDataProvider(opeParam));
}
exports.registerTreeServer = registerTreeServer;

function registerBuildServer(context, indexer, opeParam){
    let netlist_viewer_manager = new build.synthNetlist(context, opeParam);
    context.subscriptions.push(vscode.commands.registerCommand('FPGA.netlist', () => __awaiter(this, void 0, void 0, function* () {
        yield netlist_viewer_manager.open_viewer();
    })), vscode.workspace.onDidOpenTextDocument((e) => netlist_viewer_manager.update_viewer()), vscode.workspace.onDidSaveTextDocument((e) => netlist_viewer_manager.update_viewer()), vscode.window.onDidChangeVisibleTextEditors((e) => netlist_viewer_manager.update_visible_viewer(e)));
    
    let xilinxBuild = new build.fpgaRegister(context, opeParam);
    //TODO 缺少sim
    vscode.commands.registerCommand('FPGA.Launch', () => {
        xilinxBuild.Launch();
    });
    vscode.commands.registerCommand('FPGA.Refresh', () => {
        xilinxBuild.Refresh();
    });
    vscode.commands.registerCommand('FPGA.Top', () => {
        xilinxBuild.Top(indexer);
    });
    vscode.commands.registerCommand('FPGA.Simulate', () => {
        xilinxBuild.Simulation();
    });
    vscode.commands.registerCommand('FPGA.Build', () => {
        xilinxBuild.Build();
    });
    vscode.commands.registerCommand('FPGA.Synth', () => {
        xilinxBuild.Synth();
    });
    vscode.commands.registerCommand('FPGA.Impl', () => {
        xilinxBuild.Impl();
    });
    vscode.commands.registerCommand('FPGA.Gen_Bit', () => {
        xilinxBuild.Gen_Bit();
    });
    vscode.commands.registerCommand('FPGA.Program', () => {
        xilinxBuild.Program();
    });
    vscode.commands.registerCommand('FPGA.GUI', () => {
        xilinxBuild.GUI();
    });
    vscode.commands.registerCommand('FPGA.Exit', () => {
        xilinxBuild.Exit();
    });
    
}
exports.registerBuildServer = registerBuildServer;

function registerDebugDesigner(opeParam) {
    let toolRegister = new debug.toolRegister(opeParam);
    vscode.commands.registerCommand('TOOL.SerialPort', () => {
        toolRegister.serialPort();
    });
}
exports.registerDebugDesigner = registerDebugDesigner;

function registerSocDesigner(opeParam) {
    let socRegister = new soc.socRegister(opeParam);
    vscode.commands.registerCommand('SDK.Launch', () => {
        socRegister.SDK_Launch();
    });
    vscode.commands.registerCommand('SDK.Build', () => {
        socRegister.SDK_Build();
    });
    vscode.commands.registerCommand('SDK.Download', () => {
        socRegister.SDK_Download();
    });
}
exports.registerSocDesigner = registerSocDesigner;

function registerXilinxDesigner(opeParam) {
    vscode.commands.registerCommand('FPGA.Overwrite_bd', () => {
        xilinx.Overwrite_bd(opeParam);
    });
    vscode.commands.registerCommand('FPGA.Add_bd', () => {
        xilinx.Add_bd(opeParam);
    });
    vscode.commands.registerCommand('FPGA.Delete_bd', () => {
        xilinx.Delete_bd(opeParam);
    });
}
exports.registerXilinxDesigner = registerXilinxDesigner;
