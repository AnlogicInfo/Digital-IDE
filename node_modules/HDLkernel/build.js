var fs = require("fs");
var fspath = require("path");
// init
var synth = require("./kernel");

function showSynthHelpLog(moduel) {
    moduel.ccall('run', '', ['string'], ["help"]);
    let message = moduel.ccall('prompt', 'string', [], []);
    return message;
}

synth().then((Module) => {
    Module.ccall('run', '', ['string'], ["help"]);
    console.log(Module.TTY.message);
    let out = Module.ccall('prompt', 'string', [], []);
    console.log(out);
});

function synthSystemMkdir(path) {
    if (synth.FS.findObject(`/${path}`) != null) {
        return true;
    } else {
        if (synthSystemMkdir(fspath.dirname(path))) {
            synth.FS.mkdir(`/${path}`);
        }
        return true;
    }
}

function synthSystemWriteFile(src, des) {
    let desDir = fspath.dirname(des);
    let content = fs.readFileSync(src, "utf-8");
    if (synth.FS.findObject(`/${desDir}`) != null) {
        synth.FS.writeFile(`/${des}`, content, { encoding: 'utf8' });
    } else {
        synthSystemMkdir(`/${desDir}`);
        synth.FS.writeFile(`/${des}`, content, { encoding: 'utf8' });
    }
}

function synthSystemReadFile(path) {
    if (synth.FS.findObject(`/${path}`) != null) {
        let content = synth.FS.readFile(`/${path}`, { encoding: 'utf8' });
        return content;
    } else {
        console.log(`ERROR: The ${path} is not at this synth system.`);
    }
}

function synthRun(command) {
    synth.ccall('run', '', ['string'], [command]);
}

function synthSimulate(vcd_path) {
    synth.ccall('run', '', ['string'], ["sim -vcd /simulation.vcd -clock sys_clk -reset sys_rst -zinit -n 10000"]);
    fs.writeFileSync(vcd_path, synthSystemReadFile("simulation.vcd"), "utf-8");
}

/*
default : do not use MUXF[78] resources to implement LUTs larger than LUT6s
    -top <module>
        use the specified module as top module

    -family {xcup|xcu|xc7|xc6s}
        run synthesis for the specified Xilinx architecture
        generate the synthesis netlist for the specified family.
        default: xc7

    -edif <file>
        write the design to the specified edif file. writing of an output file
        is omitted if this parameter is not specified.

    -blif <file>
        write the design to the specified BLIF file. writing of an output file
        is omitted if this parameter is not specified.

    -vpr
        generate an output netlist (and BLIF file) suitable for VPR
        (this feature is experimental and incomplete)

    -nobram
        disable inference of block rams

    -nodram
        disable inference of distributed rams

    -nosrl
        disable inference of shift registers

    -nocarry
        do not use XORCY/MUXCY/CARRY4 cells in output netlist

    -run <from_label>:<to_label>
        only run the commands between the labels (see below). an empty
        from label is synonymous to 'begin', and empty to label is
        synonymous to the end of the command list.

    -flatten
        flatten design before synthesis 
*/
function synthXilinx(arg, edif_path, blif_path) {
    if (edif_path != undefined) {
        arg = arg + ` -edif /TOP.edif`;
    }
    if (blif_path != undefined) {
        arg = arg + ` -blif /TOP.blif`;
    }
    synth.ccall('run', '', ['string'], [`synth_xilinx -nowidelut ${arg}`]);
    if (edif_path != undefined) {
        fs.writeFileSync(edif_path, synthSystemReadFile("/TOP.edif"), "utf-8");
    }
    if (blif_path != undefined) {
        fs.writeFileSync(edif_path, synthSystemReadFile("/TOP.blif"), "utf-8");
    }
}

function pickAllFile(file_path, extname, output_list) {
    let file_list = fs.readdirSync(file_path);
    for (let i = 0; i < file_list.length; i++) {
        const element = file_list[i];
        if (fs.statSync(`${file_path}/${element}`).isDirectory()) {
            pickAllFile(`${file_path}/${element}`, extname, output_list);
        } else {
            if (extname.includes(fspath.extname(element).toLowerCase())) {
                output_list.push(`${file_path}/${element}`.replace("//", "/").replace(/\\/g, "\/"));
            }
        }
    }
}
function synthLoadFile(path, parent) {
    let verilogFiles = [];
    pickAllFile(path, [".v", ".V", ".vh", ".vl"], verilogFiles);
    synth.TTY.message = "";
    for (let index = 0; index < verilogFiles.length; index++) {
        const verilogFile = verilogFiles[index];
        const synthSysPath = verilogFile.replace(parent, "");
        synthSystemWriteFile(verilogFile, synthSysPath);
        synth.ccall('run', '', ['string'], [`read_verilog /${synthSysPath}`]);
    }
    return synth.TTY.message;
}

// synthLoadFile("D:/project/Code/Javascript/yosysjs/verilog", "D:/project/Code/Javascript/");
// console.log(synth.TTY.message);
// synthXilinx("-top demo -family xc6s", "D:/project/Code/Javascript/yosysjs/verilog/demo.edif");

function synthSystemRemoveFile(path) {
    synth.FS.unlink(`/${path}`);
}

function synthSystemRemoveDir(path) {
    let files = [];
    if (synth.FS.findObject(`/${path}`) != null) {
        files = synth.FS.readdir(`/${path}`);
        for (let index = 2; index < files.length; index++) {
            const element = files[index];
            let curPath = synth.PATH.join(`/${path}`, element).replace(/\\/g, "\/");
            let value = synth.FS.isDir(synth.FS.stat(curPath).mode);
            if (value) {
                synthSystemRemoveDir(curPath);
            } else {
                synth.FS.unlink(curPath);
            }
        }
        synth.FS.rmdir(`/${path}`); //清除文件夹
    }
}

// synthSystemWriteFile("D:/project/Code/Javascript/yosysjs/verilog/test.v", "prj/Code/Javascript/yosysjs/verilog/test.v")
// console.log(synth.FS.readdir("/"));
// synthSystemRemoveDir("prj");
// console.log(synth.FS.readdir("/"));
// synthSystemMkdir(`prj/verilog`);
// synth.FS.writeFile("/prj/verilog/demo.v", "test", { encoding: 'utf8' });
// synth.ccall('run', '', ['string'], ["design -reset; read_verilog /demo.v"]);

// let json_test = synth.FS.readFile("/demo.vcd", { encoding: 'utf8' });
// fs.writeFileSync("./demo.vcd", json_test, "utf-8");


// synth.ccall('run', '', ['string'], ["proc; write_json /json/Cordic.json"]);
// let json_test = synth.FS.readFile("/json/Cordic.json", { encoding: 'utf8' });
// fs.writeFileSync("./Cordic.json", json_test, "utf-8");

// synth.ccall('run', '', ['string'], ["synth -run coarse; synth -run fine; show -stretch"]);
// let show_test = synth.FS.readFile("show.dot", { encoding: 'utf8' });
// console.log(show_test);