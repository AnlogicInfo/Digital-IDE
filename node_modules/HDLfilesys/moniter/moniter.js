"use strict";

const fs     = require("fs");
const fspath = require("path");
const vscode = require("vscode");
const watch  = require("./watch");
const dir    = require("../operation/dirs");
const prjs   = require("../operation/prjs");
const files  = require("../operation/files");

let fsWait      = false;
let threadState = true;

function threadMonitor(outputChannel, opeParam) {
    watch.createMonitor(`${opeParam.rootPath}/../resources/tool`, { interval: 1 }, function (monitor) {
        monitor.on("changed", function (f) {
            if (filepath.indexOf("THREAD") != -1) {                
                if (threadState == true) { 
                    threadState = false;               
                    let thread = fs.readFileSync(`${opeParam.rootPath}/../resources/tool/THREAD`, "utf-8");
                    let lines = thread.split('\n');
                    if (opeParam.propertyPath != "") {
                        let prjInfo = files.pullJsonInfo(opeParam.propertyPath);
                        let synthPath   = `${opeParam.workspacePath}prj/xilinx/` + prjInfo.PRJ_NAME.FPGA + ".runs/synth_1/runme.log";
                        let implPath    = `${opeParam.workspacePath}prj/xilinx/` + prjInfo.PRJ_NAME.FPGA + ".runs/impl_1/runme.log";
                        let simvlogPath = `${opeParam.workspacePath}prj/xilinx/` + prjInfo.PRJ_NAME.FPGA + ".sim/sim_1/behav/xsim/xvlog.log";
                        let simelabPath = `${opeParam.workspacePath}prj/xilinx/` + prjInfo.PRJ_NAME.FPGA + ".sim/sim_1/behav/xsim/elaborate.log";
                        if (lines[1] == "true") {
                            let log = showlog(synthPath);
                            if (log != "") {
                                outputChannel.show(true);
                                outputChannel.appendLine(log);
                            }
                            lines[1] = "false";
                        }
                        if (lines[3] == "true") {
                            let log = showlog(implPath);
                            if (log != "") {
                                outputChannel.show(true);
                                outputChannel.appendLine(log);
                            }
                            lines[3] = "false";
                        }
                        if (lines[5] == "true") {
                            let log = showlog(simvlogPath);
                            if (log != "") {
                                outputChannel.show(true);
                                outputChannel.appendLine(log);
                            }
                            log = showlog(simelabPath);
                            if (log != "") {
                                outputChannel.show(true);
                                outputChannel.appendLine(log);
                            }
                            lines[5] = "false";
                        }
                    }
                    thread = "";
                    for (let i = 0; i < lines.length - 1; i++) {
                        const element = lines[i];
                        thread = thread + element + "\n";
                    }
                    fs.writeFileSync(`${opeParam.rootPath}/../resources/tool/THREAD`, thread, "utf-8");
                } else {
                    threadState = true;
                }
            }
        });
    });
}
exports.threadMonitor = threadMonitor;

function showlog(path) {
    let log = "";
    let content = fs.readFileSync(path, "utf-8");
    let lines   = content.split('\n');
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.indexOf("ERROR:") != -1) {
            log = log + line + "\n";
        } else if (line.indexOf("CRITICAL WARNING:") != -1) {
            log = log + line + "\n";
        }
    }
    return log;
}

function monitor (path, opeParam, indexer, callback) {
    let watcher = vscode.workspace.createFileSystemWatcher("**/*.{json,v,sv,vhl}", false, false, false);
    watcher.onDidChange((uri) => { 
        if (fspath.basename(uri.fsPath) == "property.json") {
            if (fsWait) return;
            fsWait = setTimeout(() => {
                fsWait = false;
                propertyPrecess(indexer, opeParam, callback);
            }, 100);
            fsWait = true;
        } else {
            HDLFilePrecess(filepath, indexer, opeParam, callback);
        }
    });
    watcher.onDidDelete((uri) => { 
        if (fspath.basename(uri.fsPath) == "property.json") {
            opeParam.propertyPath = "";
        }
    });
    watch.createMonitor(path, { interval: 1 }, function (monitor) {
        monitor.on("created",  function (f) {
            // TODO 测试延时触发的效果
            // onCreate(f, indexer, opeParam, callback);
            onCreate(opeParam, indexer, callback);
        });
        monitor.on("removed", (f) => {
            onDelete(opeParam, indexer, callback);
        });
    });
}
exports.monitor = monitor;

function onCreate(opeParam, indexer, callback) {
    fsWait = setTimeout(() => {
        fsWait = false;
        console.log("remove");
        let HDLFileList = prjs.getLibParam(opeParam);
        prjs.refreshPrjFiles(opeParam.workspacePath, HDLFileList);
        indexer.HDLparam = []
        indexer.build_index(HDLFileList).then(() => {
            callback();
        });
    }, 1000);
    fsWait = true;
}

function onDelete(opeParam, indexer, callback) {
    if (fsWait) return;
    fsWait = setTimeout(() => {
        fsWait = false;
        console.log("remove");
        let HDLFileList = prjs.getLibParam(opeParam);
        prjs.refreshPrjFiles(opeParam.workspacePath, HDLFileList);
        indexer.HDLparam = []
        indexer.build_index(HDLFileList).then(() => {
            callback();
        });
    }, 1000);
    fsWait = true;
}

function HDLFilePrecess(filepath, indexer, opeParam, callback) {
    let HDLFileList = [];
    if (prjs.refreshPrjFiles(filepath, HDLFileList) > 0) {
        HDLFileList = prjs.getLibParam(opeParam);
        prjs.refreshPrjFiles(opeParam.workspacePath, HDLFileList);
        indexer.HDLparam = []
        indexer.build_index(HDLFileList).then(() => {
            callback();
        });
    }
}


function propertyPrecess(indexer, opeParam, callback) {
    prjs.refreshPrjFolder(opeParam);
    let HDLFileList = prjs.getLibParam(opeParam);
    prjs.refreshPrjFiles(opeParam.workspacePath, HDLFileList);
    indexer.HDLparam = []
    indexer.build_index(HDLFileList).then(() => {
        callback();
    });
}