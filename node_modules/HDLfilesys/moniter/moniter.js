"use strict";

const fs     = require("fs");
const fspath = require("path");
const vscode = require("vscode");
const watch  = require("./watch");
const dir    = require("../operation/dirs");
const prjs   = require("../operation/prjs");
const files  = require("../operation/files");

let fsWait   = false;

function showlog(path) {
    let log = "";
    let content = fs.readFileSync(path, "utf-8");
    let lines   = content.split('\n');
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.indexOf("ERROR:") != -1) {
            log = log + line + "\n";
        } else if (line.indexOf("CRITICAL WARNING:") != -1) {
            log = log + line + "\n";
        }
    }
    return log;
}

function monitor (path, opeParam, indexer, outputChannel, callback) {
    let watcher = vscode.workspace.createFileSystemWatcher("**/*.{log,json,v,sv,vhl}", false, false, false);
    watcher.onDidChange((uri) => { 
        if (opeParam.propertyPath != "") {
            var prjInfo = files.pullJsonInfo(opeParam.propertyPath);
            var synthPath   = `${opeParam.workspacePath}prj/xilinx/` + prjInfo.PRJ_NAME.FPGA + ".runs/synth_1/runme.log";
            var implPath    = `${opeParam.workspacePath}prj/xilinx/` + prjInfo.PRJ_NAME.FPGA + ".runs/impl_1/runme.log";
            var simvlogPath = `${opeParam.workspacePath}prj/xilinx/` + prjInfo.PRJ_NAME.FPGA + ".sim/sim_1/behav/xsim/xvlog.log";
            var simelabPath = `${opeParam.workspacePath}prj/xilinx/` + prjInfo.PRJ_NAME.FPGA + ".sim/sim_1/behav/xsim/elaborate.log";
        }
        if (uri.fsPath.replace("//","/").replace(/\\/g,"\/").indexOf("synth_1/runme.log") != -1) {
            let log = showlog(synthPath);
            if (log != "") {
                outputChannel.show(true);
                outputChannel.appendLine(log);
            }
        } else if (uri.fsPath.replace("//","/").replace(/\\/g,"\/").indexOf("impl_1/runme.log") != -1) {
            let log = showlog(implPath);
            if (log != "") {
                outputChannel.show(true);
                outputChannel.appendLine(log);
            }
        } else if (uri.fsPath.replace("//","/").replace(/\\/g,"\/").indexOf("xsim/xvlog.log") != -1
                || uri.fsPath.replace("//","/").replace(/\\/g,"\/").indexOf("xsim/elaborate.log") != -1) {
            let simvlog = showlog(simvlogPath);
            if (simvlog != "") {
                outputChannel.show(true);
                outputChannel.appendLine(simvlog);
            }
            let simelab = showlog(simelabPath);
            if (simelab != "") {
                outputChannel.show(true);
                outputChannel.appendLine(simelab);
            }
        } else if (fspath.basename(uri.fsPath) == "property.json") {
            if (fsWait) return;
            fsWait = setTimeout(() => {
                fsWait = false;
                propertyPrecess(indexer, opeParam, callback);
            }, 1000);
            fsWait = true;
        } else {
            HDLFilePrecess(uri.fsPath.replace("//","/").replace(/\\/g,"\/"), indexer, opeParam, callback);
        }
    });
    watcher.onDidDelete((uri) => { 
        if (fspath.basename(uri.fsPath) == "property.json") {
            opeParam.propertyPath = "";
        }
    });
    watch.createMonitor(path, { interval: 1 }, function (monitor) {
        monitor.on("created",  function (f) {
            // TODO 测试延时触发的效果
            onCreate(opeParam, indexer, callback);
        });
        monitor.on("removed", (f) => {
            onDelete(opeParam, indexer, callback);
        });
    });
}
exports.monitor = monitor;

function onCreate(opeParam, indexer, callback) {
    fsWait = setTimeout(() => {
        fsWait = false;
        console.log("remove");
        let HDLFileList = prjs.getLibParam(opeParam);
        prjs.refreshPrjFiles(opeParam, HDLFileList);
        indexer.HDLparam = []
        indexer.build_index(HDLFileList).then(() => {
            indexer.updateMostRecentSymbols(undefined);
            callback();
        });
    }, 1000);
    fsWait = true;
}

function onDelete(opeParam, indexer, callback) {
    if (fsWait) return;
    fsWait = setTimeout(() => {
        fsWait = false;
        console.log("remove");
        let HDLFileList = prjs.getLibParam(opeParam);
        prjs.refreshPrjFiles(opeParam, HDLFileList);
        indexer.HDLparam = []
        indexer.build_index(HDLFileList).then(() => {
            indexer.updateMostRecentSymbols(undefined);
            callback();
        });
    }, 1000);
    fsWait = true;
}

function HDLFilePrecess(filepath, indexer, opeParam, callback) {
    let HDLFileList = [];
    if (prjs.refreshHDLFiles(filepath, HDLFileList) > 0) {
        HDLFileList = prjs.getLibParam(opeParam);
        prjs.refreshPrjFiles(opeParam, HDLFileList);
        indexer.HDLparam = []
        indexer.build_index(HDLFileList).then(() => {
            indexer.updateMostRecentSymbols(undefined);
            callback();
        });
    }
}

function propertyPrecess(indexer, opeParam, callback) {
    prjs.refreshPrjFolder(opeParam);
    let HDLFileList = prjs.getLibParam(opeParam);
    prjs.refreshPrjFiles(opeParam, HDLFileList);
    indexer.HDLparam = []
    indexer.build_index(HDLFileList).then(() => {
        indexer.updateMostRecentSymbols(undefined);
        callback();
    });
}