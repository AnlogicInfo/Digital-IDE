"use strict";

const fs       = require("fs");
const fspath   = require("path");
const chokidar = require("chokidar");
const dir      = require("../operation/dirs");
const prjs     = require("../operation/prjs");
const files    = require("../operation/files");

function monitor (path, opeParam, indexer, outputChannel, callback) {
    const watcher = chokidar.watch(path, {
        persistent:    true,
        usePolling:    false,
        ignoreInitial: true,
    });
      
    // 添加监听事件
    watcher.on('add', (path) => {
        console.log(`File ${path} has been added`);
    });
    watcher.on('change', (path) => {
        console.log(`File ${(path)} has been changed`);
    });
    watcher.on('unlink', (path) => {
        console.log(`File ${path} has been removed`);
    });

    // 监听新的文件.
    // watcher.add(['new-file-2', 'new-file-3', '**/other-file*']);
    // 禁止监听指定的文件
    // watcher.unwatch('new-file*');
    // 其他可能用到的事件
    // watcher
    // .on('addDir', path => log(`Directory ${path} has been added`))
    // .on('unlinkDir', path => log(`Directory ${path} has been removed`))
    // .on('error', error => log(`Watcher error: ${error}`))
    // .on('ready', () => log('Initial scan complete. Ready for changes'))
    // .on('raw', (event, path, details) => {
    // log('Raw event info:', event, path, details);
    // });
}
exports.monitor = monitor;

function onCreate(opeParam, indexer, callback) {
    let HDLFileList = prjs.getLibParam(opeParam);
    prjs.refreshPrjFiles(opeParam, HDLFileList);
    indexer.HDLparam = []
    indexer.build_index(HDLFileList).then(() => {
        indexer.updateMostRecentSymbols(undefined);
        callback();
    });
}

function onDelete(opeParam, indexer, callback) {
    let HDLFileList = prjs.getLibParam(opeParam);
    prjs.refreshPrjFiles(opeParam, HDLFileList);
    indexer.HDLparam = []
    indexer.build_index(HDLFileList).then(() => {
        indexer.updateMostRecentSymbols(undefined);
        callback();
    });
}

function HDLFilePrecess(filepath, indexer, opeParam, callback) {
    let vlogExtensions = [".v",".V",".vh",".vl",".sv",".SV"];
    let vhdlExtensions = [".vhd",".vhdl",".vho",".vht"];
    let extname = fspath.extname(element).toLowerCase();
    let HDLFileList = [];
    if (prjs.refreshHDLFiles(filepath, HDLFileList) > 0) {
        HDLFileList = prjs.getLibParam(opeParam);
        prjs.refreshPrjFiles(opeParam, HDLFileList);
        indexer.HDLparam = []
        indexer.build_index(HDLFileList).then(() => {
            indexer.updateMostRecentSymbols(undefined);
            callback();
        });
    }
}

function propertyPrecess(indexer, opeParam, callback) {
    // TODO: 刷新property在opeParam中的文件地址信息
    prjs.refreshPrjFolder(opeParam);
    let HDLFileList = prjs.getLibParam(opeParam);
    prjs.refreshPrjFiles(opeParam, HDLFileList);
    indexer.HDLparam = []
    indexer.build_index(HDLFileList).then(() => {
        indexer.updateMostRecentSymbols(undefined);
        callback();
    });
}

function xExecShowLog(path, outputChannel) {
    let logPathList = ["runme.log", "xvlog.log", "elaborate.log"];
    let fileName = fspath.basename(path);
    if (logPathList.indexOf(fileName) != -1){
        let log = "";
        let content = fs.readFileSync(path, "utf-8");
        let lines   = content.split('\n');
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (line.indexOf("ERROR:") != -1) {
                log = log.replace("ERROR:", "[ERROR] :") + line + "\n";
            } else if (line.indexOf("CRITICAL WARNING:") != -1) {
                log = log.replace("CRITICAL WARNING:", "[CRITICAL WARNING] :") + line + "\n";
            }
        }
        if (log != "") {
            outputChannel.show(true);
            outputChannel.appendLine(log);
        }
    }
}