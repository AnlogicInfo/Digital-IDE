"use strict";

const fs     = require("fs");
const fspath = require("path");
const vscode = require("vscode");

const dirs  = require("./dirs");
const files = require("./files");

var prjParam;
exports.prjParam = prjParam;

function getOpeParam(currentDirName, opeParam) {
    opeParam.os = process.platform;
    opeParam.rootPath = currentDirName.replace(/\\/g,"\/");
    if (vscode.workspace.workspaceFolders.length != 0) {
        var folder = vscode.workspace.workspaceFolders[0].uri.toString();
    } else {
        var folder = '';
    }
	folder = folder.substr(8, folder.length);
	folder += "/";
	var Drive = folder[0];
	folder = folder.substr(4, folder.length);
    opeParam.prjInfo       = null;
    opeParam.workspacePath = Drive + ":" + folder;
    opeParam.workspacePath = opeParam.workspacePath.replace(/\\/g,"\/");
    opeParam.prjInitParam  = `${opeParam.rootPath}/../prjInitParam.json`
    opeParam.propertyPath  = `${opeParam.workspacePath}.vscode/property.json`;
    if (!fs.existsSync(opeParam.propertyPath)) {
        if (!fs.existsSync(`${opeParam.workspacePath}property.json`)) {
            opeParam.prjInfo        = null;
            opeParam.propertyPath   = "";
            opeParam.currentSrcPath = `${opeParam.workspacePath}`;
        } else{
            opeParam.propertyPath = `${opeParam.workspacePath}property.json`;
        }
    }
    if (opeParam.propertyPath != "") {
        opeParam.prjInfo = files.pullJsonInfo(opeParam.propertyPath);
        if (opeParam.prjInfo.SOC_MODE.soc != "none") {
            opeParam.currentSrcPath = `${opeParam.workspacePath}user/Hardware`;
        } else {
            opeParam.currentSrcPath = `${opeParam.workspacePath}user`;
        }
        if (files.isHasAttr(opeParam.prjInfo,"HardwareSrc")) {
            opeParam.currentSrcPath = `${opeParam.prjInfo.HardwareSrc}`;
        }
    }
}
exports.getOpeParam = getOpeParam;

function generatePropertyFile(opeParam) {
    if (opeParam.propertyPath == "") {
        opeParam.propertyPath = `${opeParam.workspacePath}.vscode/property.json`;
        vscode.window.showInformationMessage("Where you want to generate?",'.vscode','root').then(function(select){
            if (select == ".vscode") {
                opeParam.propertyPath = `${opeParam.workspacePath}.vscode/property.json`;
            } else if (select == "root") {
                opeParam.propertyPath = `${opeParam.workspacePath}property.json`;
            }
            files.pushJsonInfo(opeParam.propertyPath, files.pullJsonInfo(opeParam.prjInitParam));
        });
    } else {
        vscode.window.showWarningMessage("property file already exists !!!");
    }
}
exports.generatePropertyFile = generatePropertyFile;

function refreshPrjFiles(path, HDLFileList) {
    let HDLExtensions = [".v",".V",".vh",".vl",".sv",".SV",".vhd",".vhdl",".vho",".vht"];
    if (fs.existsSync(path)) {
        if (fs.statSync(path).isDirectory()) {       
            for (let i = 0; i < HDLExtensions.length; i++) {
                const element = HDLExtensions[i];
                files.pickAllFile(path, element, HDLFileList);
            }
        } else {
            for (let i = 0; i < HDLExtensions.length; i++) {
                const extname = HDLExtensions[i];
                if (fspath.extname(path).toLowerCase() === extname) {
                    HDLFileList.push(vscode.Uri.file(path.replace("//","/").replace(/\\/g,"\/")));
                    break;
                }
            }
        }
    }
    return HDLFileList.length;
}
exports.refreshPrjFiles = refreshPrjFiles;

function refreshPrjFolder(opeParam) {
    if (opeParam.propertyPath != "") {        
        let prj_info = files.pullJsonInfo(opeParam.propertyPath);
        dirs.mkdir(`${opeParam.workspacePath}prj/xilinx`);
        dirs.mkdir(`${opeParam.workspacePath}prj/intel`);
        dirs.mkdir(`${opeParam.workspacePath}prj/simulation`);
        if (prj_info.SOC_MODE.soc == "none") {
            if (fs.existsSync(`${opeParam.workspacePath}user/Software`)) {   
                if (vscode.workspace.getConfiguration().get("PRJ.file.structure.notice")) {                    
                    vscode.window.showWarningMessage("Software will be deleted.",'Yes','No').then(function(select){
                        if (select == "Yes") {
                            dirs.deleteDir(`${opeParam.workspacePath}user/Software`);
                        }
                    });
                } else { 
                    dirs.deleteDir(`${opeParam.workspacePath}user/Software`);
                }             
            }
            if (fs.existsSync(`${opeParam.workspacePath}user/Hardware`)) {
                let fileList = fs.readdirSync(`${opeParam.workspacePath}user/Hardware`);
                for (let i = 0; i < fileList.length; i++) {
                    const element = fileList[i];
                    dirs.movedir(`${opeParam.workspacePath}user/Hardware/${element}`,`${opeParam.workspacePath}user`);
                }
                dirs.deleteDir(`${opeParam.workspacePath}user/Hardware`);
            } else {
                dirs.mkdir(`${opeParam.workspacePath}user/src`);
                dirs.mkdir(`${opeParam.workspacePath}user/sim`);
                dirs.mkdir(`${opeParam.workspacePath}user/data`);
            }
        } else {
            if (fs.existsSync(`${opeParam.workspacePath}user`)) {
                let fileList = fs.readdirSync(`${opeParam.workspacePath}user`);
                if (!dirs.mkdir(`${opeParam.workspacePath}user/Hardware`)) {  
                    for (let i = 0; i < fileList.length; i++) {
                        const element = fileList[i];
                        dirs.movedir(`${opeParam.workspacePath}user/${element}`,`${opeParam.workspacePath}user/Hardware`);
                    }
                }
            } else {
                dirs.mkdir(`${opeParam.workspacePath}user/Hardware/src`);
                dirs.mkdir(`${opeParam.workspacePath}user/Hardware/sim`);
                dirs.mkdir(`${opeParam.workspacePath}user/Hardware/data`);
            }
            dirs.mkdir(`${opeParam.workspacePath}user/Software/data`);
            dirs.mkdir(`${opeParam.workspacePath}user/Software/src`);
        }
    }
}
exports.refreshPrjFolder = refreshPrjFolder;

function refreshPrjInfo(opeParam) {
    if (opeParam.propertyPath != "") {
        opeParam.prjInfo = files.pullJsonInfo(opeParam.propertyPath);
        if (opeParam.prjInfo.SOC_MODE.soc != "none") {
            opeParam.currentSrcPath = `${opeParam.workspacePath}user/Hardware`;
        }else{
            opeParam.currentSrcPath = `${opeParam.workspacePath}user`;
        }
        let xip_repo_path  = vscode.workspace.getConfiguration().get('PRJ.xilinx.IP.repo.path');
        let CONFIG_content = "xip_repo_path\n";
        CONFIG_content += xip_repo_path + '\n';
        CONFIG_content += "FPGA_VERSION\n";
        CONFIG_content += opeParam.prjInfo.FPGA_VERSION + '\n';
        CONFIG_content += "PRJ_NAME.FPGA\n";
        CONFIG_content += opeParam.prjInfo.PRJ_NAME.FPGA + '\n';
        CONFIG_content += "PRJ_NAME.SOC\n";
        CONFIG_content += opeParam.prjInfo.PRJ_NAME.SOC + '\n';
        CONFIG_content += "SOC_MODE.soc\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.soc + '\n';
        CONFIG_content += "SOC_MODE.bd_file\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.bd_file + '\n';
        CONFIG_content += "SOC_MODE.os\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.os + '\n';
        CONFIG_content += "SOC_MODE.app\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.app + '\n';
        CONFIG_content += "enableShowlog\n";
        CONFIG_content += opeParam.prjInfo.enableShowlog + '\n';
        CONFIG_content += "Device\n";
        CONFIG_content += opeParam.prjInfo.Device + '\n';
    
        fs.writeFileSync(`${opeParam.rootPath}/../resources/tool/CONFIG`,CONFIG_content);
        return opeParam.prjInfo;
    }else{
        return null;
    }
}
exports.refreshPrjInfo = refreshPrjInfo;

function getLibParam(opeParam) {
    let libFileList = [];
    getOpeParam(opeParam.rootPath, opeParam);
    prjParam = refreshPrjInfo(opeParam);
    let customerLibPath = vscode.workspace.getConfiguration().get("PRJ.customer.Lib.repo.path");
    if (files.isHasAttr(prjParam,"HardwareLIB.Common")) {
        for (let i = 0; i < prjParam.HardwareLIB.Common.length; i++) {
            const element = prjParam.HardwareLIB.Common[i];
            refreshPrjFiles(`${opeParam.rootPath}/../lib/src_lib/Hardware/${element}`,libFileList);
        }
    }
    if (files.isHasAttr(prjParam,"HardwareLIB.Customer")) {
        if (fs.existsSync(customerLibPath)) {            
            for (let i = 0; i < prjParam.Customer.length; i++) {
                const element = prjParam.Customer[i];
                refreshPrjFiles(`${customerLibPath}/${element}`,libFileList);
            }
        }
    }
    let array = [];
    for(var i = 0, l = libFileList.length; i < l; i++) {
        for(var j = i + 1; j < l; j++)
        if (libFileList[i].path === libFileList[j].path) j = ++i;
        array.push(libFileList[i]);
    }
    libFileList = array;
    if (files.isHasValue(prjParam,"HardwareLIB.State","real")) {
        //TODO 删除没有lib的文件
        for (let i = 0; i < libFileList.length; i++) {
            const element = libFileList[i];
            let src  = element.fsPath.replace("//","/").replace(/\\/g,"\/");
            let dist = src.replace(`${opeParam.rootPath}/../lib/src_lib/Hardware/`,"");
            if (!fs.statSync(src).isDirectory()) {        
                dist = dist.replace(`/${fspath.basename(dist)}`,"");
            }
            if (src.indexOf(customerLibPath) != -1 && customerLibPath != "") {
                dist = src.replace(`${customerLibPath}/`,"");
            }
            if (prjParam.SOC_MODE.soc != "none") {
                dist = opeParam.workspacePath + "user/Hardware/src/lib/" + dist;
            } else {
                dist = opeParam.workspacePath + "user/src/lib/" + dist;
            }
            if (!fs.existsSync(dist)) {
                files.copyFile(src,dist);
            }
        }
        libFileList = [];
    } else if (files.isHasValue(prjParam,"HardwareLIB.State","virtual")) {
        let dist = '';
        if (prjParam.SOC_MODE.soc != "none") {
            dist = opeParam.workspacePath + "user/Hardware/src/lib";
        } else {
            dist = opeParam.workspacePath + "user/src/lib";
        }
        if (prjParam.FPGA_VERSION =="xilinx") {
            xilinxAddLibFiles(libFileList, opeParam);
        }
        if (fs.existsSync(dist)) {
            if (vscode.workspace.getConfiguration().get("PRJ.file.structure.notice")) {                    
                vscode.window.showWarningMessage("src/lib will be deleted.",'Yes','No').then(function(select){
                    if (select == "Yes") {
                        dirs.deleteDir(dist);
                    }
                });
            } else { 
                dirs.deleteDir(dist);
            }  
        }
    }
    return libFileList;
}
exports.getLibParam = getLibParam;

function addDevice(opeParam) {
    let propertyParam = files.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    vscode.window.showInputBox({
        password:false, 
        ignoreFocusOut:true,
        placeHolder:'Please input the name of device', }).then((Device) => {
        if (propertyParam.properties.Device.enum.indexOf(Device) == -1) {
            propertyParam.properties.Device.enum.push(Device);
            files.pushJsonInfo(`${opeParam.rootPath}/../property.json`,propertyParam);
            vscode.window.showInformationMessage(`Add the ${Device} successfully!!!`)
        }
        else {
            vscode.window.showWarningMessage("The device already exists")
        }
    });
}
exports.addDevice = addDevice;

function delDevice(opeParam) {
    let propertyParam = files.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    vscode.window.showQuickPick(propertyParam.properties.Device.enum).then(Device => {
        if (!Device) {
            return;
        }
        for(var index = 0; index < propertyParam.properties.Device.enum.length; index++){
            if(Device == propertyParam.properties.Device.enum[index]){
                propertyParam.properties.Device.enum.splice(index,1);
            }
        }
        files.pushJsonInfo(`${opeParam.rootPath}/../property.json`,propertyParam);
        vscode.window.showInformationMessage(`Delete the ${Device} successfully!!!`)
    });
}
exports.delDevice = delDevice;

function overwriteInitProperty(opeParam) {
    let initPropertyPath = `${opeParam.rootPath}/../prjInitParam.json`
    const options = {
        preview: false,
        viewColumn: vscode.ViewColumn.Active
    };
    vscode.window.showTextDocument(vscode.Uri.file(initPropertyPath), options);
}
exports.overwriteInitProperty = overwriteInitProperty;

function removeDuplicates(arry) {
    let r = [];
    for(var i = 0, l = arry.length; i < l; i++) {
        for(var j = i + 1; j < l; j++)
        if (arry[i] === arry[j]) j = ++i;
        r.push(arry[i]);
    }
    return r;
}

function xilinxAddLibFiles(libFileList, opeParam) {
    let content = "";
    for (let i = 0; i < libFileList.length; i++) {
        const element = libFileList[i].fsPath.replace("//","/").replace(/\\/g,"\/");
        content = content + `add_file ${element}` + "\n";
    }
    fs.writeFileSync(`${opeParam.rootPath}/../resources/tool/Xilinx/Script/Vivado/library.tcl`, content, "utf8");
    vscode.commands.executeCommand('FPGA.Refresh');
}