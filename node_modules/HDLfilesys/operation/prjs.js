"use strict";

const fs = require("fs");
const fspath = require("path");
const vscode = require("vscode");

const dirs = require("./dirs");
const files = require("./files");

/**
 * the class of HDL file process
 * 
 */
class processLib {
    constructor(opeParam, watcher) {
        this.opeParam = opeParam;
        this.watcher  = watcher;
        this.localLibPath = fspath.dirname(opeParam.rootPath) + "/lib";
        // All are represented in the form of library paths and no workspace paths
        this.oldLibFileList = [];
        this.newLibFileList = [];
    }

    /**
     * Remove duplicate element form the array
     * @param {*} array the array need to be removed duplicate element
     * @returns 
     */
    removeDuplicates(array) {
        let r = [];
        for (var i = 0, l = array.length; i < l; i++) {
            for (var j = i + 1; j < l; j++)
                if (array[i] === array[j]) j = ++i;
            r.push(array[i]);
        }
        return r;
    }

    /**
     * get all the lib files from Common, xilinx, intel, Customer
     * @returns all the lib files from property.json
     */
    getLibFiles() {
        let libFileList = [];
        if (this.opeParam.propertyPath != "") {
            // Gets the path to the user-defined library
            let customerlocalLibPath = vscode.workspace.getConfiguration().get("PRJ.customer.Lib.repo.path");
            // Get the HDL file of the local library and put it in libFileList
            if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Common")) {
                for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Common.length; i++) {
                    const element = this.opeParam.prjInfo.HardwareLIB.Common[i];
                    getHDLFiles(`${this.localLibPath}/src_lib/Hardware/${element}`, libFileList);
                }
            }
            // Get the HDL file of the local Xilinx library and put it in libFileList
            if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Xilinx_lib")) {
                for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Xilinx_lib.length; i++) {
                    const element = this.opeParam.prjInfo.HardwareLIB.Xilinx_lib[i];
                    getHDLFiles(`${this.localLibPath}/Xilinx_lib/src/${element}`, libFileList);
                }
            }
            // Get the HDL file of the local Intel library and put it in libFileList
            if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Intel_lib")) {
                for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Intel_lib.length; i++) {
                    const element = this.opeParam.prjInfo.HardwareLIB.Intel_lib[i];
                    getHDLFiles(`${this.localLibPath}/Intel_lib/src/${element}`, libFileList);
                }
            }
            // Get the HDL file of the user-defined library and place it in libFileList
            if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Customer")) {
                if (fs.existsSync(customerlocalLibPath)) {
                    for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Customer.length; i++) {
                        const element = this.opeParam.prjInfo.HardwareLIB.Customer[i];
                        getHDLFiles(`${customerlocalLibPath}/${element}`, libFileList);
                    }
                } else {
                    vscode.window.showErrorMessage(`The PRJ.customer.Lib.repo.path ${PRJ.customer.Lib.repo.path} do not exist.`);
                }
            }
            // Remove duplicate HDL files
            libFileList = this.removeDuplicates(libFileList);
            this.newLibFileList = libFileList;
            return libFileList;
        }
    }

    /**
     * delete the lib file from old lib file list
     * @returns The lib file to delete
     */
    get_del_LibFileList() {
        let delLibFileList = [];
        for (let i = 0; i < this.oldLibFileList.length; i++) {
            const oldLibFileElement = this.oldLibFileList[i];
            if (!this.newLibFileList.includes(oldLibFileElement)) {
                delLibFileList.push(oldLibFileElement);
            }
        }
        return delLibFileList;
    }

    ensureTerminalExists(name) {
        for (let index = 0; index < vscode.window.terminals.length; index++) {
            const terminalElement = vscode.window.terminals[index];
            if (terminalElement.name == name) {
                return terminalElement;
            }
        }
        return null;
    }

    /**
     * add the lib file from new lib file list
     * @returns The lib file to add
     */
    get_add_LibFileList() {
        let addLibFileList = [];
        for (let i = 0; i < this.newLibFileList.length; i++) {
            const newLibFileElement = this.newLibFileList[i];
            if (!this.oldLibFileList.includes(newLibFileElement)) {
                addLibFileList.push(newLibFileElement);
            }
        }
        return addLibFileList;
    }

    turn_local_to_lib(localLibPath, localLibFiles) {
        let libFiles = [];
        let customerlocalLibPath = vscode.workspace.getConfiguration().get("PRJ.customer.Lib.repo.path");
        getHDLFiles(localLibPath, localLibFiles);
        for (let i = 0; i < localLibFiles.length; i++) {
            const localLibElement = localLibFiles[i];
            if (localLibElement.indexOf("Customer") != -1) {
                libFiles.push(localLibElement.replace(`${localLibPath}Customer`, customerlocalLibPath));
            } else {
                libFiles.push(localLibElement.replace(localLibPath, `${this.localLibPath}/`));
            }
        }
        return libFiles;
    }

    turn_lib_to_local(localLibPath, libFiles, callback) {
        let localLibFiles = [];
        let customerlocalLibPath = vscode.workspace.getConfiguration().get("PRJ.customer.Lib.repo.path");
        for (let i = 0; i < libFiles.length; i++) {
            const libFileElement = libFiles[i];
            let dist = "";
            if (libFileElement.indexOf(customerlocalLibPath) != -1) {
                dist = libFileElement.replace(customerlocalLibPath, `${localLibPath}Customer`);
                localLibFiles.push(dist);
            } 
            else if (libFileElement.indexOf(`${this.localLibPath}/`) != -1) {
                dist = libFileElement.replace(`${this.localLibPath}/`, localLibPath);
                localLibFiles.push(dist);
            }
            let src  = libFileElement;
            callback(src, dist);
        }
    }

    addLibFiles(libFileList) {
        let content  = "";
        let terminal = this.ensureTerminalExists("StartFPGA");
        for (let i = 0; i < libFileList.length; i++) {
            const libFileElement = libFileList[i].replace("//", "/").replace(/\\/g, "\/");
            if (terminal != null) {
                terminal.sendText(`add_file ${libFileElement}`);
            } else {
                content = content + `add_file ${libFileElement}` + "\n";
            }
        }
        return content;
    }

    delLibFiles(libFileList) {
        let content  = "";
        let terminal = this.ensureTerminalExists("StartFPGA");
        for (let i = 0; i < libFileList.length; i++) {
            const libFileElement = libFileList[i].replace("//", "/").replace(/\\/g, "\/");
            if (terminal != null) {
                terminal.sendText(`remove_files ${libFileElement}`);
            } else {
                content = content + `remove_files ${libFileElement}` + "\n";
            }
        }
        return content;
        // fs.writeFileSync(`${opeParam.rootPath}/../resources/tool/Xilinx/Script/Vivado/library.tcl`, content, "utf8");
    }

    processLibFiles() {
        let localLibPath   = "";
        let script_content = "";
        let delLibFileList = [];
        let addLibFileList = [];
        if (this.opeParam.prjInfo.SOC_MODE.soc != "none") {
            localLibPath = this.opeParam.workspacePath + "user/Hardware/src/lib/";
        } else {
            localLibPath = this.opeParam.workspacePath + "user/src/lib/";
        }

        if (files.isHasValue(this.opeParam.prjInfo, "HardwareLIB.State", "real")) {
            
            this.oldLibFileList = [];
            this.turn_local_to_lib(localLibPath, this.oldLibFileList);
            delLibFileList = this.get_del_LibFileList();
            addLibFileList = this.get_add_LibFileList();
            this.turn_lib_to_local(localLibPath, delLibFileList, (src, dist) => {
                if (fs.existsSync(dist)) {
                    fs.unlinkSync(dist);
                }
            })
            delLibFileList = [];

            this.turn_lib_to_local(localLibPath, addLibFileList, (src, dist) => {
                files.copyFile(src, dist);
            })
            addLibFileList = [];
        }
        else if (files.isHasValue(this.opeParam.prjInfo, "HardwareLIB.State", "virtual")) {
            delLibFileList = this.get_del_LibFileList();
            addLibFileList = this.get_add_LibFileList();
            this.watcher.add(addLibFileList);
            this.watcher.unwatch(delLibFileList);
            if (filesys.files.isHasAttr(this.opeParam.prjInfo, "FPGA_VERSION")) {
                if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {
                    script_content = script_content + this.addLibFiles(addLibFileList);
                    script_content = script_content + this.delLibFiles(delLibFileList);
                }				
            }
            if (fs.existsSync(localLibPath)) {
                if (vscode.workspace.getConfiguration().get("PRJ.file.structure.notice")) {
                    vscode.window.showWarningMessage("src/lib will be deleted.", 'Yes', 'No').then(function (select) {
                        if (select == "Yes") {
                            dirs.deleteDir(localLibPath);
                        }
                        return;
                    });
                } else {
                    dirs.deleteDir(localLibPath);
                }
            }
        }
        this.oldLibFileList = this.newLibFileList;
        return {
            "add" : addLibFileList,
            "del" : delLibFileList
        }
    }
}
exports.processLib = processLib;

function getOpeParam(currentDirName, opeParam) {
    // 获取当前平台运行的系统
    opeParam.os = process.platform;
    // 获取当前根路径
    opeParam.rootPath = currentDirName.replace(/\\/g, "\/");
    // 获取当前工作区路径
    if (vscode.workspace.workspaceFolders != undefined &&
        vscode.workspace.workspaceFolders.length != 0) {
        opeParam.workspacePath = vscode.workspace.workspaceFolders[0].uri.fsPath;
    } else {
        opeParam.workspacePath = '';
        return null;
    }
    opeParam.workspacePath = opeParam.workspacePath.replace(/\\/g, "\/");
    console.log(opeParam.workspacePath);
    // 初始化工程参数与信息
    getPropertyInfo(opeParam);
    return opeParam;
}
exports.getOpeParam = getOpeParam;

function getPropertyInfo(opeParam) {
    opeParam.prjInfo = null;
    opeParam.prjInitParam = `${opeParam.rootPath}/../prjInitParam.json`;
    opeParam.propertyPath = `${opeParam.workspacePath}/.vscode/property.json`;
    if (!fs.existsSync(opeParam.propertyPath)) {
        if (!fs.existsSync(`${opeParam.workspacePath}/property.json`)) {
            opeParam.prjInfo = null;
            opeParam.propertyPath = "";
            opeParam.currentHDLPath = [`${opeParam.workspacePath}`];
        } else {
            opeParam.propertyPath = `${opeParam.workspacePath}/property.json`;
        }
    }
    if (opeParam.propertyPath != "") {
        opeParam.prjInfo = files.pullJsonInfo(opeParam.propertyPath);
        if (files.isHasAttr(opeParam.prjInfo, "SOC_MODE.soc")) {
            if (opeParam.prjInfo.SOC_MODE.soc != "none") {
                opeParam.currentHDLPath = [
                    `${opeParam.workspacePath}/user/Hardware/src`,
                    `${opeParam.workspacePath}/user/Hardware/sim`,
                ];
            } else {
                opeParam.currentHDLPath = [
                    `${opeParam.workspacePath}/user/src`,
                    `${opeParam.workspacePath}/user/sim`,
                ];
            }
        }
        if (files.isHasAttr(opeParam.prjInfo, "HardwareSrc")) {
            opeParam.currentHDLPath = opeParam.prjInfo.HardwareSrc;
        }
    }
}
exports.getPropertyInfo = getPropertyInfo;

function generatePropertyFile(opeParam) {
    if (opeParam.propertyPath == "") {
        opeParam.propertyPath = `${opeParam.workspacePath}/.vscode/property.json`;

        vscode.window.showQuickPick(['.vscode', 'root'], { placeHolder: "Where you want to generate?" }).then(function (select) {
            // "Where you want to generate?"
            if (select == ".vscode") {
                opeParam.propertyPath = `${opeParam.workspacePath}/.vscode/property.json`;
            } else if (select == "root") {
                opeParam.propertyPath = `${opeParam.workspacePath}/property.json`;
            }
            files.pushJsonInfo(opeParam.propertyPath, files.pullJsonInfo(opeParam.prjInitParam));
        });
    } else {
        vscode.window.showWarningMessage("property file already exists !!!");
    }
}
exports.generatePropertyFile = generatePropertyFile;

function getHDLFiles(path, HDLFileList) {
    let HDLFileExtnames = [
        // verilog
        ".v", ".V", ".vh", ".vl", 
        // systemverilog
        ".sv", ".SV", 
        // vhdl
        ".vhd", ".vhdl", ".vho", ".vht"];
    files.pickAllFile(path, HDLFileExtnames, HDLFileList);
}

function getPrjFiles(opeParam, HDLFileList) {
    for (let index = 0; index < opeParam.currentHDLPath.length; index++) {
        const HDLFileElement = opeParam.currentHDLPath[index].replace("${workspce}", opeParam.workspacePath);
        getHDLFiles(HDLFileElement, HDLFileList);
    }
    if (opeParam.prjInfo != null) {
        if (files.isHasAttr(opeParam.prjInfo, "FPGA_VERSION")) {
            // 获取xilinx下bd数据
            if (opeParam.prjInfo.FPGA_VERSION == "xilinx") {
                let bd_path = `${opeParam.currentHDLPath}/bd`;
                if (fs.existsSync(bd_path)) {
                    let bd_list = fs.readdirSync(bd_path);
                    for (let i = 0; i < bd_list.length; i++) {
                        const element = bd_list[i];
                        getHDLFiles(`${bd_path}/${element}/hdl`, HDLFileList);
                        getHDLFiles(`${bd_path}/${element}/synth`, HDLFileList);
                        let ip_path = `${bd_path}/${element}/ip`;
                        if (fs.existsSync(ip_path)) {
                            let ip_list = fs.readdirSync(ip_path);
                            for (let i = 0; i < ip_list.length; i++) {
                                const element = ip_list[i];
                                getHDLFiles(`${ip_path}/${element}/synth`, HDLFileList);
                            }
                        }
                    }
                }
            }
        }
    }
}
exports.getPrjFiles = getPrjFiles;

function refreshPrjFolder(opeParam) {
    if (opeParam.prjInfo != null) {
        dirs.mkdir(`${opeParam.workspacePath}/prj/xilinx`);
        dirs.mkdir(`${opeParam.workspacePath}/prj/intel`);
        dirs.mkdir(`${opeParam.workspacePath}/prj/simulation`);
        if (files.isHasAttr(opeParam.prjInfo, "SOC_MODE.soc")) {
            if (opeParam.prjInfo.SOC_MODE.soc == "none") {
                if (fs.existsSync(`${opeParam.workspacePath}/user/Software`)) {
                    if (vscode.workspace.getConfiguration().get("PRJ.file.structure.notice")) {
                        vscode.window.showWarningMessage("Software will be deleted.", 'Yes', 'No').then(function (select) {
                            if (select == "Yes") {
                                dirs.deleteDir(`${opeParam.workspacePath}/user/Software`);
                            }
                        });
                    } else {
                        dirs.deleteDir(`${opeParam.workspacePath}/user/Software`);
                    }
                }
                if (fs.existsSync(`${opeParam.workspacePath}/user/Hardware`)) {
                    let fileList = fs.readdirSync(`${opeParam.workspacePath}/user/Hardware`);
                    for (let i = 0; i < fileList.length; i++) {
                        const element = fileList[i];
                        dirs.movedir(`${opeParam.workspacePath}/user/Hardware/${element}`, `${opeParam.workspacePath}/user`);
                    }
                    dirs.deleteDir(`${opeParam.workspacePath}/user/Hardware`);
                } else {
                    dirs.mkdir(`${opeParam.workspacePath}/user/src`);
                    dirs.mkdir(`${opeParam.workspacePath}/user/sim`);
                    dirs.mkdir(`${opeParam.workspacePath}/user/data`);
                }
            } else {
                if (fs.existsSync(`${opeParam.workspacePath}/user`)) {
                    let fileList = fs.readdirSync(`${opeParam.workspacePath}/user`);
                    if (!fs.existsSync(`${opeParam.workspacePath}/user/Hardware`)) {
                        dirs.mkdir(`${opeParam.workspacePath}/user/Hardware`);
                        for (let i = 0; i < fileList.length; i++) {
                            const element = fileList[i];
                            dirs.movedir(`${opeParam.workspacePath}/user/${element}`, `${opeParam.workspacePath}/user/Hardware`);
                        }
                    }
                } else {
                    dirs.mkdir(`${opeParam.workspacePath}/user/Hardware/src`);
                    dirs.mkdir(`${opeParam.workspacePath}/user/Hardware/sim`);
                    dirs.mkdir(`${opeParam.workspacePath}/user/Hardware/data`);
                }
                dirs.mkdir(`${opeParam.workspacePath}/user/Software/data`);
                dirs.mkdir(`${opeParam.workspacePath}/user/Software/src`);
            }
        }
    }
}
exports.refreshPrjFolder = refreshPrjFolder;

function refreshPrjInfo(opeParam) {
    if (opeParam.prjInfo != null) {
        let xip_repo_path = vscode.workspace.getConfiguration().get('PRJ.xilinx.IP.repo.path');
        let CONFIG_content = "xip_repo_path\n";
        CONFIG_content += xip_repo_path + '\n';
        CONFIG_content += "FPGA_VERSION\n";
        CONFIG_content += opeParam.prjInfo.FPGA_VERSION + '\n';
        CONFIG_content += "PRJ_NAME.FPGA\n";
        CONFIG_content += opeParam.prjInfo.PRJ_NAME.FPGA + '\n';
        CONFIG_content += "PRJ_NAME.SOC\n";
        CONFIG_content += opeParam.prjInfo.PRJ_NAME.SOC + '\n';
        CONFIG_content += "SOC_MODE.soc\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.soc + '\n';
        CONFIG_content += "SOC_MODE.bd_file\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.bd_file + '\n';
        CONFIG_content += "SOC_MODE.os\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.os + '\n';
        CONFIG_content += "SOC_MODE.app\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.app + '\n';
        CONFIG_content += "enableShowlog\n";
        CONFIG_content += opeParam.prjInfo.enableShowlog + '\n';
        CONFIG_content += "Device\n";
        CONFIG_content += opeParam.prjInfo.Device + '\n';

        fs.writeFileSync(`${opeParam.rootPath}/../resources/tool/CONFIG`, CONFIG_content);
        return opeParam.prjInfo;
    } else {
        return null;
    }
}
exports.refreshPrjInfo = refreshPrjInfo;

function addDevice(opeParam) {
    let propertyParam = files.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    vscode.window.showInputBox({
        password: false,
        ignoreFocusOut: true,
        placeHolder: 'Please input the name of device',
    }).then((Device) => {
        if (propertyParam.properties.Device.enum.indexOf(Device) == -1) {
            propertyParam.properties.Device.enum.push(Device);
            files.pushJsonInfo(`${opeParam.rootPath}/../property.json`, propertyParam);
            vscode.window.showInformationMessage(`Add the ${Device} successfully!!!`)
        }
        else {
            vscode.window.showWarningMessage("The device already exists")
        }
    });
}
exports.addDevice = addDevice;

function delDevice(opeParam) {
    let propertyParam = files.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    vscode.window.showQuickPick(propertyParam.properties.Device.enum).then(Device => {
        if (!Device) {
            return;
        }
        for (var index = 0; index < propertyParam.properties.Device.enum.length; index++) {
            if (Device == propertyParam.properties.Device.enum[index]) {
                propertyParam.properties.Device.enum.splice(index, 1);
            }
        }
        files.pushJsonInfo(`${opeParam.rootPath}/../property.json`, propertyParam);
        vscode.window.showInformationMessage(`Delete the ${Device} successfully!!!`)
    });
}
exports.delDevice = delDevice;

function overwriteInitProperty(opeParam) {
    let initPropertyPath = `${opeParam.rootPath}/../prjInitParam.json`
    const options = {
        preview: false,
        viewColumn: vscode.ViewColumn.Active
    };
    vscode.window.showTextDocument(vscode.Uri.file(initPropertyPath), options);
}
exports.overwriteInitProperty = overwriteInitProperty;

