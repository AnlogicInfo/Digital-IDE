"use strict";

const fs = require("fs");
const fspath = require("path");
const vscode = require("vscode");

const dirs = require("./dirs");
const files = require("./files");

var prjParam;
exports.prjParam = prjParam;

class processLib {
    constructor(opeParam, watcher) {
        this.opeParam = opeParam;
        this.watcher  = watcher;
        // 全部以库路径的形式表示而不含工作区路径
        this.oldLibFileList = [];
        this.newLibFileList = [];
    }

    getLibParam() {
        let libFileList = [];
        if (this.opeParam.propertyPath != "") {
            // 获取用户自定义库路径
            let customerlocalLibPath = vscode.workspace.getConfiguration().get("PRJ.customer.Lib.repo.path");
            // 获取本地库的HDL文件 并存放到 libFileList
            if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Common")) {
                for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Common.length; i++) {
                    const element = this.opeParam.prjInfo.HardwareLIB.Common[i];
                    refreshHDLFiles(`${this.opeParam.rootPath}/../lib/src_lib/Hardware/${element}`, libFileList);
                }
            }
            // 获取本地XILINX库的HDL文件 并存放到 libFileList
            if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Xilinx_lib")) {
                for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Xilinx_lib.length; i++) {
                    const element = this.opeParam.prjInfo.HardwareLIB.Xilinx_lib[i];
                    refreshHDLFiles(`${this.opeParam.rootPath}/../lib/Xilinx_lib/src/${element}`, libFileList);
                }
            }
            // 获取本地Intel库的HDL文件 并存放到 libFileList
            if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Intel_lib")) {
                for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Intel_lib.length; i++) {
                    const element = this.opeParam.prjInfo.HardwareLIB.Intel_lib[i];
                    refreshHDLFiles(`${this.opeParam.rootPath}/../lib/Intel_lib/src/${element}`, libFileList);
                }
            }
            // 获取用户自定义库的HDL文件 并存放到 libFileList
            if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Customer")) {
                if (fs.existsSync(customerlocalLibPath)) {
                    for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Customer.length; i++) {
                        const element = this.opeParam.prjInfo.HardwareLIB.Customer[i];
                        refreshHDLFiles(`${customerlocalLibPath}/${element}`, libFileList);
                    }
                } else {
                    vscode.window.showErrorMessage(`The PRJ.customer.Lib.repo.path ${PRJ.customer.Lib.repo.path} do not exist.`);
                }
            }
            // 去除重复的HDL文件
            libFileList = removeDuplicates(libFileList);
            this.newLibFileList = libFileList;
            return libFileList;
        }
    }

    get_del_LibFileList() {
        let delLibFileList = [];
        for (let i = 0; i < this.oldLibFileList.length; i++) {
            const oldLibFileElement = this.oldLibFileList[i];
            if (!this.newLibFileList.includes(oldLibFileElement)) {
                delLibFileList.push(oldLibFileElement);
            }
        }
        return delLibFileList;
    }

    get_add_LibFileList() {
        let addLibFileList = [];
        for (let i = 0; i < this.newLibFileList.length; i++) {
            const newLibFileElement = this.newLibFileList[i];
            if (!this.oldLibFileList.includes(newLibFileElement)) {
                addLibFileList.push(newLibFileElement);
            }
        }
        return addLibFileList;
    }

    turn_local_to_lib(localLibPath, localLibFiles) {
        let libFiles = [];
        let customerlocalLibPath = vscode.workspace.getConfiguration().get("PRJ.customer.Lib.repo.path");
        refreshHDLFiles(localLibPath, localLibFiles);
        for (let i = 0; i < localLibFiles.length; i++) {
            const localLibElement = localLibFiles[i];
            if (localLibElement.indexOf("Customer") != -1) {
                libFiles.push(localLibElement.replace(`${localLibPath}Customer`, customerlocalLibPath));
            } else {
                libFiles.push(localLibElement.replace(localLibPath, `${this.opeParam.rootPath}/../lib/`));
            }
        }
        return libFiles;
    }

    turn_lib_to_local(localLibPath, libFiles, callback) {
        let localLibFiles = [];
        let customerlocalLibPath = vscode.workspace.getConfiguration().get("PRJ.customer.Lib.repo.path");
        for (let i = 0; i < libFiles.length; i++) {
            const libFileElement = libFiles[i];
            let dist = "";
            if (libFileElement.indexOf(customerlocalLibPath) != -1) {
                dist = libFileElement.replace(customerlocalLibPath, `${localLibPath}Customer`);
                localLibFiles.push(dist);
            } 
            else if (libFileElement.indexOf(`${this.opeParam.rootPath}/../lib/`) != -1) {
                dist = libFileElement.replace(`${this.opeParam.rootPath}/../lib/`, localLibPath);
                localLibFiles.push(dist);
            }
            let src  = libFileElement;
            callback(src, dist);
        }
    }

    processLibParam() {
        let localLibPath = '';
        let delLibFileList = [];
        let addLibFileList = [];
        if (this.opeParam.prjInfo.SOC_MODE.soc != "none") {
            localLibPath = this.opeParam.workspacePath + "user/Hardware/src/lib/";
        } else {
            localLibPath = this.opeParam.workspacePath + "user/src/lib/";
        }

        if (files.isHasValue(this.opeParam.prjInfo, "HardwareLIB.State", "real")) {
            
            this.oldLibFileList = [];
            this.turn_local_to_lib(localLibPath, this.oldLibFileList);
            delLibFileList = this.get_del_LibFileList();
            addLibFileList = this.get_add_LibFileList();
            this.turn_lib_to_local(localLibPath, delLibFileList, (src, dist) => {
                if (fs.existsSync(dist)) {
                    fs.unlinkSync(dist);
                }
            })
            delLibFileList = [];

            this.turn_lib_to_local(localLibPath, addLibFileList, (src, dist) => {
                files.copyFile(src, dist);
            })
            addLibFileList = [];
        }
        else if (files.isHasValue(this.opeParam.prjInfo, "HardwareLIB.State", "virtual")) {
            delLibFileList = this.get_del_LibFileList();
            addLibFileList = this.get_add_LibFileList();
            this.watcher.add(addLibFileList);
            this.watcher.unwatch(delLibFileList);
            if (this.opeParam.prjInfo.FPGA_VERSION == "xilinx") {
                xilinxAddLibFiles(addLibFileList, this.opeParam);
                xilinxDelLibFiles(delLibFileList, this.opeParam);
            }
            if (fs.existsSync(localLibPath)) {
                if (vscode.workspace.getConfiguration().get("PRJ.file.structure.notice")) {
                    vscode.window.showWarningMessage("src/lib will be deleted.", 'Yes', 'No').then(function (select) {
                        if (select == "Yes") {
                            dirs.deleteDir(localLibPath);
                        }
                        return;
                    });
                } else {
                    dirs.deleteDir(localLibPath);
                }
            }
        }
        this.oldLibFileList = this.newLibFileList;
        return {
            "add" : addLibFileList,
            "del" : delLibFileList
        }
    }
}
exports.processLib = processLib;

function getOpeParam(currentDirName, opeParam) {
    // 获取当前平台运行的系统
    opeParam.os = process.platform;
    // 获取当前根路径
    opeParam.rootPath = currentDirName.replace(/\\/g, "\/");
    // 获取当前工作区路径
    if (vscode.workspace.workspaceFolders != undefined &&
        vscode.workspace.workspaceFolders.length != 0) {
        opeParam.workspacePath = vscode.workspace.workspaceFolders[0].uri.fsPath;
    } else {
        opeParam.workspacePath = '';
    }
    opeParam.workspacePath = opeParam.workspacePath.replace(/\\/g, "\/") + "/";
    console.log(opeParam.workspacePath);
    // 初始化工程参数与信息
    refreshPropertyInfo(opeParam);
}
exports.getOpeParam = getOpeParam;

function generatePropertyFile(opeParam) {
    if (opeParam.propertyPath == "") {
        opeParam.propertyPath = `${opeParam.workspacePath}.vscode/property.json`;

        vscode.window.showQuickPick(['.vscode', 'root'], { placeHolder: "Where you want to generate?" }).then(function (select) {
            // "Where you want to generate?"
            if (select == ".vscode") {
                opeParam.propertyPath = `${opeParam.workspacePath}.vscode/property.json`;
            } else if (select == "root") {
                opeParam.propertyPath = `${opeParam.workspacePath}property.json`;
            }
            files.pushJsonInfo(opeParam.propertyPath, files.pullJsonInfo(opeParam.prjInitParam));
        });
    } else {
        vscode.window.showWarningMessage("property file already exists !!!");
    }
}
exports.generatePropertyFile = generatePropertyFile;

function refreshPropertyInfo(opeParam) {
    opeParam.prjInfo = null;
    opeParam.prjInitParam = `${opeParam.rootPath}/../prjInitParam.json`;
    opeParam.propertyPath = `${opeParam.workspacePath}.vscode/property.json`;
    if (!fs.existsSync(opeParam.propertyPath)) {
        if (!fs.existsSync(`${opeParam.workspacePath}property.json`)) {
            opeParam.prjInfo = null;
            opeParam.propertyPath = "";
            opeParam.currentSrcPath = `${opeParam.workspacePath}`;
        } else {
            opeParam.propertyPath = `${opeParam.workspacePath}property.json`;
        }
    }
    if (opeParam.propertyPath != "") {
        opeParam.prjInfo = files.pullJsonInfo(opeParam.propertyPath);
        if (opeParam.prjInfo.SOC_MODE.soc != "none") {
            opeParam.currentSrcPath = `${opeParam.workspacePath}user/Hardware`;
        } else {
            opeParam.currentSrcPath = `${opeParam.workspacePath}user`;
        }
        if (files.isHasAttr(opeParam.prjInfo, "HardwareSrc")) {
            opeParam.currentSrcPath = `${opeParam.prjInfo.HardwareSrc}`;
        }
    }
}
exports.refreshPropertyInfo = refreshPropertyInfo;

function refreshHDLFiles(path, HDLFileList) {
    let HDLExtensions = [".v", ".V", ".vh", ".vl", ".sv", ".SV", ".vhd", ".vhdl", ".vho", ".vht"];
    if (fs.existsSync(path)) {
        if (fs.statSync(path).isDirectory()) {
            for (let i = 0; i < HDLExtensions.length; i++) {
                const element = HDLExtensions[i];
                files.pickAllFile(path, element, HDLFileList);
            }
        } else {
            for (let i = 0; i < HDLExtensions.length; i++) {
                const extname = HDLExtensions[i];
                if (fspath.extname(path).toLowerCase() === extname) {
                    HDLFileList.push(path.replace("//", "/").replace(/\\/g, "\/"));
                    break;
                }
            }
        }
    }
    return HDLFileList.length;
}
exports.refreshHDLFiles = refreshHDLFiles;

function refreshPrjFiles(opeParam, HDLFileList) {
    if (opeParam.prjInfo != null) {
        refreshHDLFiles(`${opeParam.currentSrcPath}/src`, HDLFileList);
        refreshHDLFiles(`${opeParam.currentSrcPath}/sim`, HDLFileList);
        if (opeParam.prjInfo.FPGA_VERSION == "xilinx") {
            // 获取xilinx下bd数据
            let bd_path = `${opeParam.currentSrcPath}/bd`;
            if (fs.existsSync(bd_path)) {
                let bd_list = fs.readdirSync(bd_path);
                for (let i = 0; i < bd_list.length; i++) {
                    const element = bd_list[i];
                    refreshHDLFiles(`${bd_path}/${element}/hdl`, HDLFileList);
                    refreshHDLFiles(`${bd_path}/${element}/synth`, HDLFileList);
                    let ip_path = `${bd_path}/${element}/ip`;
                    if (fs.existsSync(ip_path)) {
                        let ip_list = fs.readdirSync(ip_path);
                        for (let i = 0; i < ip_list.length; i++) {
                            const element = ip_list[i];
                            refreshHDLFiles(`${ip_path}/${element}/synth`, HDLFileList);
                        }
                    }
                }
            }
        }
    } else {
        refreshHDLFiles(`${opeParam.currentSrcPath}`, HDLFileList);
    }
}
exports.refreshPrjFiles = refreshPrjFiles;

function refreshPrjFolder(opeParam) {
    if (opeParam.propertyPath != "") {
        let prj_info = files.pullJsonInfo(opeParam.propertyPath);
        dirs.mkdir(`${opeParam.workspacePath}prj/xilinx`);
        dirs.mkdir(`${opeParam.workspacePath}prj/intel`);
        dirs.mkdir(`${opeParam.workspacePath}prj/simulation`);
        if (prj_info.SOC_MODE.soc == "none") {
            if (fs.existsSync(`${opeParam.workspacePath}user/Software`)) {
                if (vscode.workspace.getConfiguration().get("PRJ.file.structure.notice")) {
                    vscode.window.showWarningMessage("Software will be deleted.", 'Yes', 'No').then(function (select) {
                        if (select == "Yes") {
                            dirs.deleteDir(`${opeParam.workspacePath}user/Software`);
                        }
                    });
                } else {
                    dirs.deleteDir(`${opeParam.workspacePath}user/Software`);
                }
            }
            if (fs.existsSync(`${opeParam.workspacePath}user/Hardware`)) {
                let fileList = fs.readdirSync(`${opeParam.workspacePath}user/Hardware`);
                for (let i = 0; i < fileList.length; i++) {
                    const element = fileList[i];
                    dirs.movedir(`${opeParam.workspacePath}user/Hardware/${element}`, `${opeParam.workspacePath}user`);
                }
                dirs.deleteDir(`${opeParam.workspacePath}user/Hardware`);
            } else {
                dirs.mkdir(`${opeParam.workspacePath}user/src`);
                dirs.mkdir(`${opeParam.workspacePath}user/sim`);
                dirs.mkdir(`${opeParam.workspacePath}user/data`);
            }
        } else {
            if (fs.existsSync(`${opeParam.workspacePath}user`)) {
                let fileList = fs.readdirSync(`${opeParam.workspacePath}user`);
                if (!fs.existsSync(`${opeParam.workspacePath}user/Hardware`)) {
                    dirs.mkdir(`${opeParam.workspacePath}user/Hardware`);
                    for (let i = 0; i < fileList.length; i++) {
                        const element = fileList[i];
                        dirs.movedir(`${opeParam.workspacePath}user/${element}`, `${opeParam.workspacePath}user/Hardware`);
                    }
                }
            } else {
                dirs.mkdir(`${opeParam.workspacePath}user/Hardware/src`);
                dirs.mkdir(`${opeParam.workspacePath}user/Hardware/sim`);
                dirs.mkdir(`${opeParam.workspacePath}user/Hardware/data`);
            }
            dirs.mkdir(`${opeParam.workspacePath}user/Software/data`);
            dirs.mkdir(`${opeParam.workspacePath}user/Software/src`);
        }
    }
}
exports.refreshPrjFolder = refreshPrjFolder;

function refreshPrjInfo(opeParam) {
    if (opeParam.propertyPath != "") {
        opeParam.prjInfo = files.pullJsonInfo(opeParam.propertyPath);
        if (opeParam.prjInfo.SOC_MODE.soc != "none") {
            opeParam.currentSrcPath = `${opeParam.workspacePath}user/Hardware`;
        } else {
            opeParam.currentSrcPath = `${opeParam.workspacePath}user`;
        }
        let xip_repo_path = vscode.workspace.getConfiguration().get('PRJ.xilinx.IP.repo.path');
        let CONFIG_content = "xip_repo_path\n";
        CONFIG_content += xip_repo_path + '\n';
        CONFIG_content += "FPGA_VERSION\n";
        CONFIG_content += opeParam.prjInfo.FPGA_VERSION + '\n';
        CONFIG_content += "PRJ_NAME.FPGA\n";
        CONFIG_content += opeParam.prjInfo.PRJ_NAME.FPGA + '\n';
        CONFIG_content += "PRJ_NAME.SOC\n";
        CONFIG_content += opeParam.prjInfo.PRJ_NAME.SOC + '\n';
        CONFIG_content += "SOC_MODE.soc\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.soc + '\n';
        CONFIG_content += "SOC_MODE.bd_file\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.bd_file + '\n';
        CONFIG_content += "SOC_MODE.os\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.os + '\n';
        CONFIG_content += "SOC_MODE.app\n";
        CONFIG_content += opeParam.prjInfo.SOC_MODE.app + '\n';
        CONFIG_content += "enableShowlog\n";
        CONFIG_content += opeParam.prjInfo.enableShowlog + '\n';
        CONFIG_content += "Device\n";
        CONFIG_content += opeParam.prjInfo.Device + '\n';

        fs.writeFileSync(`${opeParam.rootPath}/../resources/tool/CONFIG`, CONFIG_content);
        return opeParam.prjInfo;
    } else {
        return null;
    }
}
exports.refreshPrjInfo = refreshPrjInfo;

function addDevice(opeParam) {
    let propertyParam = files.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    vscode.window.showInputBox({
        password: false,
        ignoreFocusOut: true,
        placeHolder: 'Please input the name of device',
    }).then((Device) => {
        if (propertyParam.properties.Device.enum.indexOf(Device) == -1) {
            propertyParam.properties.Device.enum.push(Device);
            files.pushJsonInfo(`${opeParam.rootPath}/../property.json`, propertyParam);
            vscode.window.showInformationMessage(`Add the ${Device} successfully!!!`)
        }
        else {
            vscode.window.showWarningMessage("The device already exists")
        }
    });
}
exports.addDevice = addDevice;

function delDevice(opeParam) {
    let propertyParam = files.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    vscode.window.showQuickPick(propertyParam.properties.Device.enum).then(Device => {
        if (!Device) {
            return;
        }
        for (var index = 0; index < propertyParam.properties.Device.enum.length; index++) {
            if (Device == propertyParam.properties.Device.enum[index]) {
                propertyParam.properties.Device.enum.splice(index, 1);
            }
        }
        files.pushJsonInfo(`${opeParam.rootPath}/../property.json`, propertyParam);
        vscode.window.showInformationMessage(`Delete the ${Device} successfully!!!`)
    });
}
exports.delDevice = delDevice;

function overwriteInitProperty(opeParam) {
    let initPropertyPath = `${opeParam.rootPath}/../prjInitParam.json`
    const options = {
        preview: false,
        viewColumn: vscode.ViewColumn.Active
    };
    vscode.window.showTextDocument(vscode.Uri.file(initPropertyPath), options);
}
exports.overwriteInitProperty = overwriteInitProperty;

function xilinxAddLibFiles(libFileList, opeParam) {
    let content = "";
    for (let i = 0; i < libFileList.length; i++) {
        const element = libFileList[i].replace("//", "/").replace(/\\/g, "\/");
        content = content + `add_file ${element}` + "\n";
    }
    fs.writeFileSync(`${opeParam.rootPath}/../resources/tool/Xilinx/Script/Vivado/library.tcl`, content, "utf8");
}

function xilinxDelLibFiles(libFileList, opeParam) {
    let content = "";
    for (let i = 0; i < libFileList.length; i++) {
        const element = libFileList[i].replace("//", "/").replace(/\\/g, "\/");
        content = content + `remove_files ${element}` + "\n";
    }
    fs.writeFileSync(`${opeParam.rootPath}/../resources/tool/Xilinx/Script/Vivado/library.tcl`, content, "utf8");
}

function removeDuplicates(arry) {
    let r = [];
    for (var i = 0, l = arry.length; i < l; i++) {
        for (var j = i + 1; j < l; j++)
            if (arry[i] === arry[j]) j = ++i;
        r.push(arry[i]);
    }
    return r;
}
