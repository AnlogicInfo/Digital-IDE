"use strict";

const fs     = require("fs");
const fspath = require("path");
const vscode = require("vscode");

const dirs  = require("./dirs");
const files = require("./files");

var prj_param;
exports.prjInfo = prj_param;

function getOpeParam(currentDirName, opeParam) {
    opeParam.os = process.platform;
    opeParam.rootPath = currentDirName.replace(/\\/g,"\/");
    var folder = vscode.workspace.workspaceFolders[0].uri.toString();
	folder = folder.substr(8, folder.length);
	folder += "/";
	var Drive = folder[0];
	folder = folder.substr(4, folder.length);
    opeParam.workspacePath = Drive + ":" + folder;
    opeParam.workspacePath = opeParam.workspacePath.replace(/\\/g,"\/");
    opeParam.prjInitParam = `${opeParam.rootPath}/../prjInitParam.json`
    opeParam.propertyPath = `${opeParam.workspacePath}.vscode/property.json`;
    if (!fs.existsSync(opeParam.propertyPath)) {
        if (!fs.existsSync(`${opeParam.workspacePath}property.json`)) {
            opeParam.propertyPath = "";
            opeParam.currentSrcPath = `${opeParam.workspacePath}`;
        }
        else{
            opeParam.propertyPath = `${opeParam.workspacePath}property.json`;
            let prjInfo = files.pullJsonInfo(opeParam.propertyPath);
            if (prjInfo.SOC_MODE.soc != "none") {
                opeParam.currentSrcPath = `${opeParam.workspacePath}user/Hardware/src/`;
            } else {
                opeParam.currentSrcPath = `${opeParam.workspacePath}user/src/`;
            }
        }
    }
}
exports.getOpeParam = getOpeParam;

function generatePropertyFile(opeParam) {
    if (opeParam.propertyPath == "") {
        vscode.window.showInformationMessage("Where you want to generate?",'.vscode','root').then(function(select){
            if (select == ".vscode") {
                opeParam.propertyPath = `${opeParam.currentSrcPath}.vscode/property.json`;
            } else if (select == "root") {
                opeParam.propertyPath = `${opeParam.currentSrcPath}property.json`;
            }
            files.pushJsonInfo(opeParam.propertyPath, files.pullJsonInfo(opeParam.prjInitParam));
        });
    } else {
        vscode.window.showWarningMessage("property file already exists !!!");
    }
}
exports.generatePropertyFile = generatePropertyFile;

function refreshPrjFiles(path, HDLFileList) {
    let HDLExtensions = [".v",".V",".vh",".vl",".sv",".SV",".vhd",".vhdl",".vho",".vht"];
    if (fs.existsSync(path)) {
        if (fs.statSync(path).isDirectory()) {       
            for (let i = 0; i < HDLExtensions.length; i++) {
                const element = HDLExtensions[i];
                files.pickAllFile(path, element, HDLFileList);
            }
        } else {
            for (let i = 0; i < HDLExtensions.length; i++) {
                const extname = HDLExtensions[i];
                if (fspath.extname(path).toLowerCase() === extname) {
                    HDLFileList.push(vscode.Uri.file(path.replace("//","/").replace(/\\/g,"\/")));
                    break;
                }
            }
        }
    }
    return HDLFileList.length;
}
exports.refreshPrjFiles = refreshPrjFiles;

function refreshPrjFolder(opeParam) {
    if (opeParam.propertyPath != "") {        
        let prj_info = files.pullJsonInfo(opeParam.propertyPath);
        dirs.mkdir(`${opeParam.workspacePath}prj/xilinx`);
        dirs.mkdir(`${opeParam.workspacePath}prj/intel`);
        dirs.mkdir(`${opeParam.workspacePath}prj/simulation`);
        if (prj_info.SOC_MODE.soc == "none") {
            dirs.deleteDir(`${opeParam.workspacePath}user/Software`);
            dirs.movedir(`${opeParam.workspacePath}user/Hardware/IP`  ,`${opeParam.workspacePath}user`);
            dirs.movedir(`${opeParam.workspacePath}user/Hardware/bd`  ,`${opeParam.workspacePath}user`);
            dirs.movedir(`${opeParam.workspacePath}user/Hardware/src` ,`${opeParam.workspacePath}user`);
            dirs.movedir(`${opeParam.workspacePath}user/Hardware/sim` ,`${opeParam.workspacePath}user`);
            dirs.movedir(`${opeParam.workspacePath}user/Hardware/data`,`${opeParam.workspacePath}user`);
            dirs.deleteDir(`${opeParam.workspacePath}user/Hardware`);
        } else {
            dirs.mkdir(`${opeParam.workspacePath}user/Software/data`);
            dirs.mkdir(`${opeParam.workspacePath}user/Software/src`);
            dirs.mkdir(`${opeParam.workspacePath}user/Hardware`);
            dirs.movedir(`${opeParam.workspacePath}user/IP`  ,`${opeParam.workspacePath}user/Hardware`);
            dirs.movedir(`${opeParam.workspacePath}user/bd`  ,`${opeParam.workspacePath}user/Hardware`);
            dirs.movedir(`${opeParam.workspacePath}user/src` ,`${opeParam.workspacePath}user/Hardware`);
            dirs.movedir(`${opeParam.workspacePath}user/data`,`${opeParam.workspacePath}user/Hardware`);
            dirs.movedir(`${opeParam.workspacePath}user/sim` ,`${opeParam.workspacePath}user/Hardware`);
        }
    }
}
exports.refreshPrjFolder = refreshPrjFolder;

function refreshPrjInfo(opeParam) {
    if (opeParam.propertyPath != "") {
        prj_param = files.pullJsonInfo(opeParam.propertyPath);
        if (prj_param.SOC_MODE.soc != "none") {
            opeParam.currentSrcPath = `${opeParam.workspacePath}user/Hardware/src/`;
        }else{
            opeParam.currentSrcPath = `${opeParam.workspacePath}user/src/`;
        }
        let xip_repo_path  = vscode.workspace.getConfiguration().get('PRJ.xilinx.IP.repo.path');
        let CONFIG_content = "xip_repo_path\n";
        CONFIG_content += xip_repo_path + '\n';
        CONFIG_content += "FPGA_VERSION\n";
        CONFIG_content += prj_param.FPGA_VERSION + '\n';
        CONFIG_content += "PRJ_NAME.FPGA\n";
        CONFIG_content += prj_param.PRJ_NAME.FPGA + '\n';
        CONFIG_content += "PRJ_NAME.SOC\n";
        CONFIG_content += prj_param.PRJ_NAME.SOC + '\n';
        CONFIG_content += "SOC_MODE.soc\n";
        CONFIG_content += prj_param.SOC_MODE.soc + '\n';
        CONFIG_content += "SOC_MODE.bd_file\n";
        CONFIG_content += prj_param.SOC_MODE.bd_file + '\n';
        CONFIG_content += "SOC_MODE.os\n";
        CONFIG_content += prj_param.SOC_MODE.os + '\n';
        CONFIG_content += "SOC_MODE.app\n";
        CONFIG_content += prj_param.SOC_MODE.app + '\n';
        CONFIG_content += "enableShowlog\n";
        CONFIG_content += prj_param.enableShowlog + '\n';
        CONFIG_content += "Device\n";
        CONFIG_content += prj_param.Device + '\n';
    
        fs.writeFileSync(`${opeParam.rootPath}/../resources/tool/CONFIG`,CONFIG_content);
        return prj_param;
    }
}
exports.refreshPrjInfo = refreshPrjInfo;

function addDevice(opeParam) {
    let propertyParam = files.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    vscode.window.showInputBox({
        password:false, 
        ignoreFocusOut:true,
        placeHolder:'Please input the name of device', }).then((Device) => {
        if (propertyParam.properties.Device.enum.indexOf(Device) == -1) {
            propertyParam.properties.Device.enum.push(Device);
            files.pushJsonInfo(`${opeParam.rootPath}/../property.json`,propertyParam);
            vscode.window.showInformationMessage(`Add the ${Device} successfully!!!`)
        }
        else {
            vscode.window.showWarningMessage("The device already exists")
        }
    });
}
exports.addDevice = addDevice;

function delDevice(opeParam) {
    let propertyParam = files.pullJsonInfo(`${opeParam.rootPath}/../property.json`);
    vscode.window.showQuickPick(propertyParam.properties.Device.enum).then(Device => {
        if (!Device) {
            return;
        }
        for(var index = 0; index < propertyParam.properties.Device.enum.length; index++){
            if(Device == propertyParam.properties.Device.enum[index]){
                propertyParam.properties.Device.enum.splice(index,1);
            }
        }
        files.pushJsonInfo(`${opeParam.rootPath}/../property.json`,propertyParam);
        vscode.window.showInformationMessage(`Delete the ${Device} successfully!!!`)
    });
}
exports.delDevice = delDevice;
