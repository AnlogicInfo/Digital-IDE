"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const vscode = require("vscode");

const simParser  = require("./Parser/simParser");
const vlogParser = require("./Parser/vlogParser");
const vhdlParser = require("./Parser/vhdlParser");

exports.simParser  = simParser;
exports.vlogParser = vlogParser;
exports.vhdlParser = vhdlParser;

/* Symbol */
/**
 * Creates a new symbol information object.
 */
class HDLSymbol {
    constructor () {
        this.symbols = [];
    }
    /**
     * set a symbol information object.
     *
     * @param  name The name of the symbol.
     * @param  type The name of the symbol.
     * @param  containerName The name of the symbol containing the symbol.
     * @param  location The location of the symbol.
     * @return The object of the SymbolInformation.
     */
    setSymbolInformation(match, containerName, document, offset){
        let location = new vscode.Location(
            document.uri, 
            new vscode.Range(
                document.positionAt(match.index + offset), 
                document.positionAt(match.index + match[0].length + offset)));
        return vscode.SymbolInformation(
            match.groups.name,
            this.getSymbolKind(match.groups.type),
            containerName,
            location);
    }
    /**
     * get a symbol Kind.
     *
     * @param name The name of the symbol.
     * @return     The SymbolKind of the symbol's name.
     */
    getSymbolKind(name) {
        if (name === undefined || name === '') { // Ports may be declared without type
            return vscode.SymbolKind.Variable;
        } else if (name.indexOf('[') != -1) {
            return vscode.SymbolKind.Array;
        }
        switch (name) {
            case 'module':      return vscode.SymbolKind.Package;
            case 'package':     return vscode.SymbolKind.Package;
            case 'import':      return vscode.SymbolKind.Package;
            case 'program':     return vscode.SymbolKind.Package;
            case 'begin':       return vscode.SymbolKind.Operator;
    
            case 'task':        return vscode.SymbolKind.Method;
            case 'function':    return vscode.SymbolKind.Function;
    
            case 'assert':
            case 'event':       return vscode.SymbolKind.Event;
    
            case 'time':        return vscode.SymbolKind.TypeParameter;
            case 'define':      return vscode.SymbolKind.TypeParameter;
            case 'typedef':     return vscode.SymbolKind.TypeParameter;
            case 'generate':    return vscode.SymbolKind.Operator;
            case 'enum':        return vscode.SymbolKind.Enum;
            case 'modport':     return vscode.SymbolKind.Null;
            case 'property':    return vscode.SymbolKind.property;

            // port 
            case 'interface':   return vscode.SymbolKind.Interface;

            // synth param    
            case 'parameter':   return vscode.SymbolKind.Constant;
            case 'localparam':  return vscode.SymbolKind.Constant;
            case 'integer':     return vscode.SymbolKind.Constant;
            case 'char':        return vscode.SymbolKind.Constant;
            case 'float':       return vscode.SymbolKind.Constant;
            case 'int':         return vscode.SymbolKind.Constant;

            // unsynth param
            case 'string':      return vscode.SymbolKind.String;
            case 'struct':      return vscode.SymbolKind.Struct;
            case 'class':       return vscode.SymbolKind.Class;
            
            case 'logic':       return vscode.SymbolKind.Variable;
            case 'wire':        return vscode.SymbolKind.Variable;
            case 'reg':         return vscode.SymbolKind.Variable;
            case 'bit':         return vscode.SymbolKind.Variable;
            default:            return vscode.SymbolKind.Field;
        }
        /* Unused/Free SymbolKind icons
            return SymbolKind.Number;
            return SymbolKind.Enum;
            return SymbolKind.EnumMember;
            return SymbolKind.Operator;
            return SymbolKind.Array;
        */
    }
}
exports.HDLSymbol = HDLSymbol;

class index {
    constructor(statusbar, HDLparam) {
        this.building  = false;
        this.NUM_FILES = 250;
        this.FileExtensions = ["vhd","vhdl","vho","vht","v","V","vh","vl","sv","SV","svh"];
        this.globPattern    = "**/*.{" + this.FileExtensions.join(",") + "}";

        this.HDLparam  = HDLparam;
        this.HDLSymbol = new HDLSymbol();
        this.statusbar = statusbar;

        this.symbols   = new Map();
        this.symbolsCount = 0;
        this.settings = vscode.workspace.getConfiguration();
    };
    getFileParam(document, type, offset = 0, parent, HDLparam, HDLSymbol) {
        let symbolList;
        if (document.languageId == "systemverilog" || document.languageId == "verilog") {
            symbolList = vlogParser.getFileParam(document, type, offset, parent, HDLparam, HDLSymbol);
        } else if (document.languageId == "vhdl") {
            symbolList = vhdlParser.getFileParam(document, type, offset, parent, HDLparam, HDLSymbol);
        }
        // simParser.refreshInstModulePath(HDLparam);
        return symbolList;
    }
    /**
        Processes one file and updates this.symbols with an entry if symbols exist in the file.

        @param uri uri to the document
        @param total_files total number of files to determine parse-precision
    */
    processFile(uri, total_files = 0, HDLparam) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                resolve(vscode.workspace.openTextDocument(uri).then(doc => {
                    return this.getFileParam(doc, null, 0, null, HDLparam, this.HDLSymbol);
                }));
            })).then((output) => {
                if (output.length > 0) {
                    if (this.symbols.has(uri.fsPath)) {
                        this.symbolsCount += output.length - this.symbols.get(uri.fsPath).length;
                    }
                    else {
                        this.symbolsCount += output.length;
                    }
                    this.symbols.set(uri.fsPath, output);
                    if (total_files == 0) { // If total files is 0, it is being used onChange
                        this.statusbar.text = 'HDL: ' + this.symbolsCount + ' indexed objects';
                    }
                }
            }).catch((error) => {
                if (this.symbols.has(uri.fsPath)) {
                    this.symbolsCount -= this.symbols.get(uri.fsPath).length;
                    this.symbols.delete(uri.fsPath);
                }
                return undefined;
            });
        });
    }
    /**
        Scans the `workspace` for HDL,
        Looks up all the `symbols` that it exist on the queried files,
        and saves the symbols as `HDLSymbol` objects to `this.symbols`.

        @return status message when indexing is successful or failed with an error.
    */
    build_index() {
        return __awaiter(this, void 0, void 0, function* () {
            var  cancelled = false;
            this.building  = true;
            this.symbolsCount = 0;
            this.statusbar.text = "HDL: Indexing..";
            let parallelProcessing = this.settings.get('HDL.parallelProcessing');
            let exclude = this.settings.get('HDL.excludeIndexing');
            if (exclude == "insert globPattern here") {
                exclude = undefined;
            }
            return yield vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: "HDL Indexing...",
                cancellable: true
            }, (_progress, token) => __awaiter(this, void 0, void 0, function* () {
                this.symbols = new Map();
                let uris = yield Promise.resolve(vscode.workspace.findFiles(this.globPattern, exclude, undefined, token));

                for (var filenr = 0; filenr < uris.length; filenr += parallelProcessing) {
                    let subset = uris.slice(filenr, filenr + parallelProcessing);
                    if (token.isCancellationRequested) {
                        cancelled = true;
                        break;
                    }
                    yield Promise.all(subset.map(uri => {
                        return this.processFile(uri, uris.length, this.HDLparam);
                    }));
                }
            })).then(() => {
                this.building = false;
                simParser.refreshInstModulePath(this.HDLparam);
                if (cancelled) {
                    this.statusbar.text = "HDL: Indexing cancelled";
                }
                else {
                    this.statusbar.text = 'HDL: ' + this.symbolsCount + ' indexed objects';
                }
            });
        });
    }
    /**
        Updates `mostRecentSymbols` with the most recently used symbols
        When `mostRecentSymbols` is undefined, add the top `this.NUM_FILES` symbol from `this.symbols`
        When `mostRecentSymbols` is defined, add the symbols in `recentSymbols` one by one to the top of the array

        @param recentSymbols the recent symbols
    */
    updateMostRecentSymbols(recentSymbols) {
        if (this.mostRecentSymbols) {
            if (!recentSymbols) {
                return;
            }
            while (recentSymbols.length > 0) {
                let currentSymbol = recentSymbols.pop();
                //if symbol already exists, remove it
                for (let i = 0; i < this.mostRecentSymbols.length; i++) {
                    let symbol = this.mostRecentSymbols[i];
                    if (symbol == currentSymbol) {
                        this.mostRecentSymbols.splice(i, 1);
                        break;
                    }
                }
                //if the array has reached maximum capacity, remove the last element
                if (this.mostRecentSymbols.length >= this.NUM_FILES) {
                    this.mostRecentSymbols.pop();
                }
                //add the symbol to the top of the array
                this.mostRecentSymbols.unshift(currentSymbol);
            }
        }
        else {
            let maxSymbols = new Array();
            //collect the top symbols in `this.symbols`
            for (var list of this.symbols.values()) {
                if (maxSymbols.length + list.length >= this.NUM_FILES) {
                    let limit = this.NUM_FILES - maxSymbols.length;
                    maxSymbols = maxSymbols.concat(list.slice(-1 * limit));
                    break;
                }
                else {
                    maxSymbols = maxSymbols.concat(list);
                }
            }
            this.mostRecentSymbols = maxSymbols;
        }
    }
}
exports.index = index;