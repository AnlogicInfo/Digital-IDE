"use strict";

const vscode  = require("vscode");

const utils   = require("./utils/utils");
exports.utils = utils;

const vlogParser = require("./parser_RegExp/vlogParser");
const vhdlParser = require("./parser_RegExp/vhdlParser");
exports.vlogParser = vlogParser;
exports.vhdlParser = vhdlParser;

/* Symbol */
/**
 * Creates a new symbol information object.
 */
class HDLSymbol {
    constructor () {
        // project global symbol
        this.symbols = [];
    }
    /**
     * set a symbol information object.
     *
     * @param  symbol The name of the symbol.
     * @param  containerName The name of the symbol containing the symbol.
     * @param  document The document of the symbol.
     * @return The object of the SymbolInformation.
     */
     setSymbolInformation(symbol, containerName, document){
        let location = new vscode.Location(
            document.uri, 
            new vscode.Range(
                document.positionAt(symbol.startIndex), 
                document.positionAt(symbol.lastIndex)));

        // <--Debug here-->
        if (symbol.name == "" || symbol.name == null) {
            console.log(document.uri.fsPath);
            symbol.name = "undefined"
        }

        return vscode.SymbolInformation(
            symbol.name,
            this.getSymbolKind(symbol.type),
            containerName,
            location
        );
    }
    /**
     * get a symbol Kind.
     *
     * @param name The name of the symbol.
     * @return     The SymbolKind of the symbol's name.
     */
    getSymbolKind(name) {
        if (name === undefined || name === '') { // Ports may be declared without type
            return vscode.SymbolKind.Variable;
        } else if (name.indexOf('[') != -1) {
            return vscode.SymbolKind.Array;
        }
        switch (name) {
            case 'module':      return vscode.SymbolKind.Module;
            case 'program':     return vscode.SymbolKind.Module;
            case 'package':     return vscode.SymbolKind.Package;
            case 'import':      return vscode.SymbolKind.Package;
            case 'always':      return vscode.SymbolKind.Operator;
            case 'processe':    return vscode.SymbolKind.Operator;
    
            case 'task':        return vscode.SymbolKind.Method;
            case 'function':    return vscode.SymbolKind.Function;
    
            case 'assert':      return vscode.SymbolKind.Boolean;
            case 'event':       return vscode.SymbolKind.Event;
            case 'instance':    return vscode.SymbolKind.Event;
    
            case 'time':        return vscode.SymbolKind.TypeParameter;
            case 'define':      return vscode.SymbolKind.TypeParameter;
            case 'typedef':     return vscode.SymbolKind.TypeParameter;
            case 'generate':    return vscode.SymbolKind.Operator;
            case 'enum':        return vscode.SymbolKind.Enum;
            case 'modport':     return vscode.SymbolKind.Boolean;
            case 'property':    return vscode.SymbolKind.Property;

            // port 
            case 'interface':   return vscode.SymbolKind.Interface;
            case 'buffer':      return vscode.SymbolKind.Interface;
            case 'output':      return vscode.SymbolKind.Interface;
            case 'input':       return vscode.SymbolKind.Interface;
            case 'inout':       return vscode.SymbolKind.Interface;

            // synth param    
            case 'localparam':  return vscode.SymbolKind.Constant;
            case 'parameter':   return vscode.SymbolKind.Constant;
            case 'integer':     return vscode.SymbolKind.Number;
            case 'char':        return vscode.SymbolKind.Number;
            case 'float':       return vscode.SymbolKind.Number;
            case 'int':         return vscode.SymbolKind.Number;

            // unsynth param
            case 'string':      return vscode.SymbolKind.String;
            case 'struct':      return vscode.SymbolKind.Struct;
            case 'class':       return vscode.SymbolKind.Class;
            
            case 'logic':       return vscode.SymbolKind.Constant;
            case 'wire':        return vscode.SymbolKind.Constant;
            case 'reg':         return vscode.SymbolKind.Constant;
            case 'bit':         return vscode.SymbolKind.Boolean;
            default:            return vscode.SymbolKind.Field;
        }
        /* Unused/Free SymbolKind icons
            return SymbolKind.Number;
            return SymbolKind.Enum;
            return SymbolKind.EnumMember;
            return SymbolKind.Operator;
            return SymbolKind.Array;
        */
    }
}
exports.HDLSymbol = HDLSymbol;

class indexer {
    constructor() {
        this.HDLSymbol = new HDLSymbol();
        this.symbols   = new Map();
        this.HDLparam  = [];
    };

    getFileParam(document, HDLSymbol, mode) {
        let HDLparam = this.HDLparam;
        if (mode == "symbol") {
            HDLparam = null;
        }
        let symbolList;
        
        if (document.languageId == "systemverilog" || document.languageId == "verilog") {
            symbolList = vlogParser.getFileParam(document, HDLSymbol, HDLparam);
        } 
        else if (document.languageId == "vhdl") {
            symbolList = vhdlParser.getFileParam(document, HDLSymbol, HDLparam);
        }
        return symbolList;
    }

    removeCurrentFileParam(currentFilePath) {
        for (let index = 0; index < this.HDLparam.length; ) {
            const HDLelement = this.HDLparam[index];
            if (HDLelement.modulePath == currentFilePath) {
                this.HDLparam.splice(index,1);
            } else{
                index++;
            }
        }
    }

    /**
     * 更新所有模块下所例化模块的路径
    */
    refreshInstModulePath() {
        let len = this.HDLparam.length;
        for (let i = 0; i < len; i++) {
            // 每个模块
            const unitMoudule = this.HDLparam[i];
            let instLen = unitMoudule.instances.length;
            for (let x = 0; x < instLen; x++) {
                // 每个模块下的例化模块
                const unitInstanceModule = unitMoudule.instances[x];

                // 首先遍历include文件
                let isExistInclude = false;
                for (let y = 0; y < unitMoudule.includes.length; y++) {
                    const unitInclude = unitMoudule.includes[y];
                    const includeModule = utils.findModuleFromPath(this.HDLparam, unitInclude, "moduleName");
                    if (includeModule.includes(unitInstanceModule.instModule)) {
                        unitInstanceModule.instModPath = unitInclude;
                        isExistInclude = true;
                        break;
                    }
                }

                // 如果不在include中则进行全局遍历
                let isExist = false;
                if (!isExistInclude) {
                    for (let z = 0; z < len; z++) {
                        const unitHDLFileElement = this.HDLparam[z];
                        if (unitInstanceModule.instModule == unitHDLFileElement.moduleName) {
                            unitInstanceModule.instModPath = unitHDLFileElement.modulePath;
                            isExist = true;
                            break;
                        }
                    }
                }

                // 如果全局还不存在则设置为空
                if (!isExist && !isExistInclude) {
                    unitInstanceModule.instModPath = '';
                }
            }
        }
    }

    async processFile(uri) {
        let document = await vscode.workspace.openTextDocument(uri);
        let symbol = this.getFileParam(document, this.HDLSymbol);
        this.symbols.set(uri.fsPath.replace(/\\/g, "\/"), symbol);
    }

    async build_index(FileList) {
        await Promise.all(FileList.map((path, index) => {
            return this.processFile(vscode.Uri.file(path));
        }));
        this.refreshInstModulePath();
    }
}
exports.indexer = indexer;