"use strict";

const vscode  = require("vscode");

const utils   = require("./utils/utils");
exports.utils = utils;

const vlogParser = require("./parser_RegExp/vlogParser");
const vhdlParser = require("./parser_RegExp/vhdlParser");
exports.vlogParser = vlogParser;
exports.vhdlParser = vhdlParser;

/* Symbol */
/**
 * Creates a new symbol information object.
 */
class HDLSymbol {
    constructor () {
        // project global symbol
        this.symbols = [];
    }
    /**
     * set a symbol information object.
     *
     * @param  symbol The name of the symbol.
     * @param  containerName The name of the symbol containing the symbol.
     * @param  document The document of the symbol.
     * @return The object of the SymbolInformation.
     */
     setSymbolInformation(symbol, containerName, document){
        let location = new vscode.Location(
            document.uri, 
            new vscode.Range(
                document.positionAt(symbol.startIndex), 
                document.positionAt(symbol.lastIndex)));
        return vscode.SymbolInformation(
            symbol.name,
            this.getSymbolKind(symbol.type),
            containerName,
            location);
    }
    /**
     * get a symbol Kind.
     *
     * @param name The name of the symbol.
     * @return     The SymbolKind of the symbol's name.
     */
    getSymbolKind(name) {
        if (name === undefined || name === '') { // Ports may be declared without type
            return vscode.SymbolKind.Variable;
        } else if (name.indexOf('[') != -1) {
            return vscode.SymbolKind.Array;
        }
        switch (name) {
            case 'module':      return vscode.SymbolKind.Module;
            case 'program':     return vscode.SymbolKind.Module;
            case 'package':     return vscode.SymbolKind.Package;
            case 'import':      return vscode.SymbolKind.Package;
            case 'always':      return vscode.SymbolKind.Operator;
            case 'processe':    return vscode.SymbolKind.Operator;
    
            case 'task':        return vscode.SymbolKind.Method;
            case 'function':    return vscode.SymbolKind.Function;
    
            case 'assert':      return vscode.SymbolKind.Boolean;
            case 'event':       return vscode.SymbolKind.Event;
            case 'instance':    return vscode.SymbolKind.Event;
    
            case 'time':        return vscode.SymbolKind.TypeParameter;
            case 'define':      return vscode.SymbolKind.TypeParameter;
            case 'typedef':     return vscode.SymbolKind.TypeParameter;
            case 'generate':    return vscode.SymbolKind.Operator;
            case 'enum':        return vscode.SymbolKind.Enum;
            case 'modport':     return vscode.SymbolKind.Boolean;
            case 'property':    return vscode.SymbolKind.Property;

            // port 
            case 'interface':   return vscode.SymbolKind.Interface;
            case 'buffer':      return vscode.SymbolKind.Interface;
            case 'output':      return vscode.SymbolKind.Interface;
            case 'input':       return vscode.SymbolKind.Interface;
            case 'inout':       return vscode.SymbolKind.Interface;

            // synth param    
            case 'localparam':  return vscode.SymbolKind.Constant;
            case 'parameter':   return vscode.SymbolKind.Constant;
            case 'integer':     return vscode.SymbolKind.Number;
            case 'char':        return vscode.SymbolKind.Number;
            case 'float':       return vscode.SymbolKind.Number;
            case 'int':         return vscode.SymbolKind.Number;

            // unsynth param
            case 'string':      return vscode.SymbolKind.String;
            case 'struct':      return vscode.SymbolKind.Struct;
            case 'class':       return vscode.SymbolKind.Class;
            
            case 'logic':       return vscode.SymbolKind.Constant;
            case 'wire':        return vscode.SymbolKind.Constant;
            case 'reg':         return vscode.SymbolKind.Constant;
            case 'bit':         return vscode.SymbolKind.Boolean;
            default:            return vscode.SymbolKind.Field;
        }
        /* Unused/Free SymbolKind icons
            return SymbolKind.Number;
            return SymbolKind.Enum;
            return SymbolKind.EnumMember;
            return SymbolKind.Operator;
            return SymbolKind.Array;
        */
    }
}
exports.HDLSymbol = HDLSymbol;

class indexer {
    constructor(HDLparam) {
        this.HDLSymbol   = new HDLSymbol();

        this.HDLparam    = HDLparam;

        this.symbols      = new Map();
        
        this.settings = vscode.workspace.getConfiguration();
        this.getConfig();
        vscode.workspace.onDidChangeConfiguration(function () {
            this.getConfig();
        });
    };

    getConfig() {
        this.parallelProcessing = this.settings.get('HDL.parallelProcessing');
    }

    getFileParam(document, HDLparam, HDLSymbol) {
        let symbolList;
        if (document.languageId == "systemverilog" || document.languageId == "verilog") {
            symbolList = vlogParser.getFileParam(document, HDLSymbol, HDLparam);
        } 
        else if (document.languageId == "vhdl") {
            symbolList = vhdlParser.getFileParam(document, HDLSymbol, HDLparam);
        }
        return symbolList;
    }

    removeCurrentFileParam (currentFilePath) {
        for (let index = 0; index < this.HDLparam.length; ) {
            const HDLelement = this.HDLparam[index];
            if (HDLelement.modulePath == currentFilePath) {
                this.HDLparam.splice(index,1);
            } else{
                index++;
            }
        }
    }

    /**
     * 更新所有模块下所例化模块的路径
     * 
     * @param  HDLparam         匹配的文本
    */
    refreshInstModulePath (HDLparam) {
        // 遍历所有模块
        for (let i = 0; i < HDLparam.length; i++) {
            const unitMoudule = HDLparam[i];
            // 遍历每个模块下的所有例化模块
            for (let x = 0; x < unitMoudule.instances.length; x++) {
                const unitInstanceModule = unitMoudule.instances[x];
                // 从HDLparam中找到每个例化模块的路径
                for (let z = 0; z < HDLparam.length; z++) {
                    const unitHDLFileElement = HDLparam[z];
                    if (unitInstanceModule.instModule == unitHDLFileElement.moduleName) {
                        unitInstanceModule.instModPath = unitHDLFileElement.modulePath;
                        break;
                    }
                }
            }
        }
    }

    async processFile(uri, HDLparam) {
        let document = await vscode.workspace.openTextDocument(uri);
        let symbol = this.getFileParam(document, HDLparam, this.HDLSymbol);
        this.symbols.set(uri.fsPath.replace(/\\/g, "\/"), symbol);
    }

    async build_index(FileList) {
        await Promise.all(FileList.map((uri) => {
            return this.processFile(vscode.Uri.file(uri), this.HDLparam);
        }));
        this.refreshInstModulePath(this.HDLparam);
    }
}
exports.indexer = indexer;