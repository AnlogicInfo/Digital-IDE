"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const vscode = require("vscode");
// import fs from 'fs';
// import { WASI } from 'wasi';
const utils      = require("./utils/utils");
exports.utils  = utils;

// const vlogParser = require("./parser_RegExp/vlogParser");
// const vhdlParser = require("./parser_RegExp/vhdlParser");
// exports.vlogParser = vlogParser;
// exports.vhdlParser = vhdlParser;

const fsm_parser   = require("HDLparser/fsm_parser/fsm_parser");
exports.fsm_parser = fsm_parser;

const ParserLib   = require("./utils/factory");
exports.ParserLib = ParserLib;

/* Symbol */
/**
 * Creates a new symbol information object.
 */
class HDLSymbol {
    constructor () {
        // project global symbol
        this.symbols = [];
    }
    /**
     * set a symbol information object.
     *
     * @param  name The name of the symbol.
     * @param  type The name of the symbol.
     * @param  containerName The name of the symbol containing the symbol.
     * @param  location The location of the symbol.
     * @return The object of the SymbolInformation.
     */
     setSymbolInformationWithRegExp(match, containerName, document, offset){
        let location = new vscode.Location(
            document.uri, 
            new vscode.Range(
                document.positionAt(match.index + offset), 
                document.positionAt(match.index + match[0].length + offset)));
        return vscode.SymbolInformation(
            match.groups.name,
            this.getSymbolKind(match.groups.type),
            containerName,
            location);
    }
    /**
     * set a symbol information object.
     *
     * @param  name The name of the symbol.
     * @param  type The name of the symbol.
     * @param  containerName The name of the symbol containing the symbol.
     * @param  location The location of the symbol.
     * @return The object of the SymbolInformation.
     */
     setSymbolInformationWithTreeSitter(symbol, containerName, document){
        let location = new vscode.Location(
            document.uri, 
            new vscode.Range(
                document.positionAt(symbol.start_index), 
                document.positionAt(symbol.last_index)));
        return vscode.SymbolInformation(
            symbol.name,
            this.getSymbolKind(symbol.type),
            containerName,
            location);
    }
    /**
     * get a symbol Kind.
     *
     * @param name The name of the symbol.
     * @return     The SymbolKind of the symbol's name.
     */
    getSymbolKind(name) {
        if (name === undefined || name === '') { // Ports may be declared without type
            return vscode.SymbolKind.Variable;
        } else if (name.indexOf('[') != -1) {
            return vscode.SymbolKind.Array;
        }
        switch (name) {
            case 'module':      return vscode.SymbolKind.Module;
            case 'package':     return vscode.SymbolKind.Package;
            case 'import':      return vscode.SymbolKind.Package;
            case 'program':     return vscode.SymbolKind.Module;
            case 'always':      return vscode.SymbolKind.Operator;
    
            case 'task':        return vscode.SymbolKind.Method;
            case 'function':    return vscode.SymbolKind.Function;
    
            case 'assert':      return vscode.SymbolKind.Variable;
            case 'event':       return vscode.SymbolKind.Event;
            case 'instance':    return vscode.SymbolKind.Event;
    
            case 'time':        return vscode.SymbolKind.TypeParameter;
            case 'define':      return vscode.SymbolKind.TypeParameter;
            case 'typedef':     return vscode.SymbolKind.TypeParameter;
            case 'generate':    return vscode.SymbolKind.Operator;
            case 'enum':        return vscode.SymbolKind.Enum;
            case 'modport':     return vscode.SymbolKind.Boolean;
            case 'property':    return vscode.SymbolKind.Property;

            // port 
            case 'interface':   return vscode.SymbolKind.Interface;
            case 'output':      return vscode.SymbolKind.Interface;
            case 'input':       return vscode.SymbolKind.Interface;
            case 'inout':       return vscode.SymbolKind.Interface;

            // synth param    
            case 'localparam':  return vscode.SymbolKind.Constant;
            case 'parameter':   return vscode.SymbolKind.Constant;
            case 'integer':     return vscode.SymbolKind.Number;
            case 'char':        return vscode.SymbolKind.Number;
            case 'float':       return vscode.SymbolKind.Number;
            case 'int':         return vscode.SymbolKind.Number;

            // unsynth param
            case 'string':      return vscode.SymbolKind.String;
            case 'struct':      return vscode.SymbolKind.Struct;
            case 'class':       return vscode.SymbolKind.Class;
            
            case 'logic':       return vscode.SymbolKind.Boolean;
            case 'wire':        return vscode.SymbolKind.Constant;
            case 'reg':         return vscode.SymbolKind.Constant;
            case 'bit':         return vscode.SymbolKind.Boolean;
            default:            return vscode.SymbolKind.Field;
        }
        /* Unused/Free SymbolKind icons
            return SymbolKind.Number;
            return SymbolKind.Enum;
            return SymbolKind.EnumMember;
            return SymbolKind.Operator;
            return SymbolKind.Array;
        */
    }
}
exports.HDLSymbol = HDLSymbol;

class indexer {
    constructor(statusbar, HDLparam, vlogParser) {

        this.statusbar   = statusbar;
        this.HDLSymbol   = new HDLSymbol();

        this.HDLparam    = HDLparam;
        this.vlogParser  = vlogParser;

        this.symbols      = new Map();
        
        this.settings = vscode.workspace.getConfiguration();
        this.getConfig();
        vscode.workspace.onDidChangeConfiguration(function () {
            this.getConfig();
        });
    };
    getConfig() {
        this.parallelProcessing = this.settings.get('HDL.parallelProcessing');
    }
    getFileParam(document, HDLparam, HDLSymbol) {
        let symbolList;
        if (document.languageId == "systemverilog" || document.languageId == "verilog") {
            symbolList = this.vlogParser.getFileParam(document.getText(), document, HDLSymbol, HDLparam);
        } 
        // else if (document.languageId == "vhdl") {
        //     symbolList = vhdlParser.getFileParam(document, type, offset, parent, HDLparam, HDLSymbol);
        // }
        return symbolList;
    }
    removeCurrentFileParam (currentFilePath) {
        let newHDLparam = [];
        this.HDLparam.forEach(element => {
            if (element.modulePath != currentFilePath) {
                newHDLparam.push(element);
            }
        });
        return newHDLparam;
    }
    refreshInstModulePath () {
        // 遍历所有模块
        this.HDLparam.forEach(unitMoudule => {
            // 遍历每个模块下的所有例化模块
            unitMoudule.instmodule.forEach(unitInstanceModule => {
                // 从HDLparam中找到每个例化模块的路径
                this.HDLparam.forEach(element => {
                    if (element.moduleName == unitInstanceModule.instModule) {
                        unitInstanceModule.instModPath = element.modulePath;
                    }
                }); 
            });
        });
    }
    async processFile(uri, HDLparam) {
        let document = await vscode.workspace.openTextDocument(uri);
        let symbol = this.getFileParam(document, HDLparam, this.HDLSymbol);
        this.symbols.set(uri.fsPath, symbol)
    }
    async build_index(FileList) {
        this.statusbar.text = "HDL: Indexing..";
        await Promise.all(FileList.map((uri) => {
            return this.processFile(vscode.Uri.file(uri), this.HDLparam);
        }));
        // for (let index = 0; index < FileList.length; index++) {
        //     const element = FileList[index];
        //     await this.processFile(vscode.Uri.file(element), this.HDLparam);
        // }
        utils.refreshInstModulePath(this.HDLparam);
    }
}
exports.indexer = indexer;