"use strict";

const path = require('path');
const Tree_sitter = require('../tree-sitter/tree-sitter');
const base_parser = require('./base_parser');

class Parser extends base_parser.base_parser {
    // constructor(parser, comment_symbol) {
    constructor(comment_symbol) {
        super();
        // this.parser = parser;
        this.loaded_wasm = false;
        this.comment_symbol = comment_symbol;
    }

    async init() {
        this.code = '';
        await Tree_sitter.init();
        this.parser = new Tree_sitter();
        let Lang = await Tree_sitter.Language.load(path.join(path.dirname(__dirname), path.sep +
            "resources" + path.sep + "tree-sitter" + path.sep + "tree-sitter-verilog.wasm"));
        this.parser.setLanguage(Lang);
        this.loaded_wasm = true;
    }

    getFileParam(sourceCode, document, HDLSymbol, HDLparam, comment_symbol) {
        if (comment_symbol !== undefined) {
            this.comment_symbol = comment_symbol;
        }
        try {
            if (document.fileName == "d:\\project\\Code\\.prj\\Plug\\My_Plug\\FPGA_Support\\lib\\src_lib\\Hardware\\Driver\\SDRAM_driver\\core\\sdrc_bank_ctl.v") {
                console.log("");
            }
            let lines = this.fileLines(sourceCode);
            let tree = this.parser.parse(sourceCode);

            //comments
            // let comments = this.get_comments(tree.rootNode, lines);
            HDLSymbol.symbols = [];
            let moduleArray = this.search_multiple_in_tree(tree.rootNode, 'module_declaration');
            for (let index = 0; index < moduleArray.length; index++) {
                const elementChildren = moduleArray[index];
                let structure = this.get_module(elementChildren, lines, HDLSymbol, document)
                if (HDLparam != null) {
                    HDLparam.push(structure);
                }
            }
            return HDLSymbol.symbols;
        }
        catch (error) {
            console.log(error);
            return undefined;
        }
    }
    //////////////////////////my api///////////////////////////////////////
    
    //--------module block--------//
    get_module(tree, lines, HDLSymbol, document) {
        let module_name = this.search_multiple_in_tree(tree, 'module_identifier', ["module_instantiation"]);
        
        let item = {
            "name" : module_name[0].text,
            "type" : "module",
            "start_index": tree.startIndex,
            "last_index" : tree.endIndex
        }
        let symbolInfo = HDLSymbol.setSymbolInformationWithTreeSitter(item, null, document);
        HDLSymbol.symbols.push(symbolInfo);

        this.get_generates(tree, lines, module_name[0].text, HDLSymbol, document);
        this.get_processes(tree, lines, module_name[0].text, HDLSymbol, document, ["generate_region"]);
        this.get_functions(tree, lines, module_name[0].text, HDLSymbol, document, ["generate_region"]);
        this.get_constants(tree, lines, module_name[0].text, HDLSymbol, document, ["generate_region"]);
        
        let ports     = this.get_ports(tree, lines, module_name[0].text, HDLSymbol, document);
        let signals   = this.get_signals(tree, lines, module_name[0].text, HDLSymbol, document, ["generate_region"]);
        let generics  = this.get_generics(tree, lines, module_name[0].text, HDLSymbol, document, ["generate_region"]);
        let instance  = this.get_instantiations(tree, lines, module_name[0].text, HDLSymbol, document, ["generate_region"]);

        let structure = {};
        structure = {
            "moduleName": module_name[0].text, // module
            "modulePath": document.fileName.replace(/\\/g, "\/"),
            "instmodule": instance,
            "signals" : signals,
            "param": generics, 
            "ports": ports,
            "port" : this.get_port_sort(ports)
        };
        // console.log(structure);
        return structure;
    }

    //--------generate block--------//
    get_generates(tree, lines, parent, HDLSymbol, document, ignore_title) {
        let items = [];
        let item = {};
        //Inputs
        let generateArr = this.search_multiple_in_tree(tree, 'generate_region', ignore_title);
        for (let x = 0; x < generateArr.length; ++x) {
            item = {
                "name": this.get_element_property(generateArr[x], lines, 'generate_block_identifier'),
                "type": "generate",
                "start_index": generateArr[x].startIndex,
                "last_index" : generateArr[x].endIndex
            };
            let symbolInfo = HDLSymbol.setSymbolInformationWithTreeSitter(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
            this.get_instantiations(generateArr[x], lines, item.name, HDLSymbol, document);
            this.get_processes(generateArr[x], lines, item.name, HDLSymbol, document);
            this.get_functions(generateArr[x], lines, item.name, HDLSymbol, document);
            this.get_constants(generateArr[x], lines, item.name, HDLSymbol, document);
            this.get_generics(generateArr[x], lines, item.name, HDLSymbol, document);
            this.get_signals(generateArr[x], lines, item.name, HDLSymbol, document);
            items.push(item);
        }
        return items;
    }

    //--------method(function | task) process block--------//
    get_functions(tree, lines, parent, HDLSymbol, document, ignore_title) {
        let items = [];
        let item  = {};
        
        let functionArr = this.search_multiple_in_tree(tree, 'function_declaration', ignore_title);
        for (let x = 0; x < functionArr.length; ++x) {
            let function_name = this.get_element_property(functionArr[x], lines, 'function_identifier');
            item = {
                "name": function_name,
                "type": "function",
                "start_index": functionArr[x].startIndex,
                "last_index" : functionArr[x].endIndex,
                "start_line" : functionArr[x].startPosition.row
            };
            let symbolInfo = HDLSymbol.setSymbolInformationWithTreeSitter(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
            items.push(item);

            let tfPortArr = this.search_multiple_in_tree(tree, 'tf_port_declaration', ignore_title);
            for (let x = 0; x < tfPortArr.length; ++x) {
                item = {
                    "name": this.get_element_property(tfPortArr[x], lines, 'port_identifier'),
                    "type": "inport",
                    "start_index": tfPortArr[x].startIndex,
                    "last_index" : tfPortArr[x].endIndex,
                    "start_line" : tfPortArr[x].startPosition.row
                };
                let symbolInfo = HDLSymbol.setSymbolInformationWithTreeSitter(item, function_name, document);
                HDLSymbol.symbols.push(symbolInfo);
            }
        }
        return items;
    }

    get_tasks(tree, lines, parent, HDLSymbol, document) {
        let items = [];
        let item = {};
        //Inputs
        let arr = this.search_multiple_in_tree(tree, 'task_declaration');
        for (let x = 0; x < arr.length; ++x) {
            item = {
                "name": this.get_element_property(arr[x], lines, 'task_identifier'),
                "type": "task",
                "start_index": arr[x].startIndex,
                "last_index": arr[x].endIndex,
                "start_line": tree.startPosition.row
            };
            let symbolInfo = HDLSymbol.setSymbolInformationWithTreeSitter(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
            items.push(item);
        }
        return items;
    }

    //--------always process element--------//
    get_processes(tree, lines, parent, HDLSymbol, document, ignore_title) {
        let items = [];
        //Inputs
        let processArr = this.search_multiple_in_tree(tree, 'always_construct', ignore_title);
        for (let x = 0; x < processArr.length; ++x) {
            items.push(this.get_processes_unit(processArr[x], lines, parent, HDLSymbol, document));
        }
        return items;
    }

    get_processes_unit(tree, lines, parent, HDLSymbol, document) {
        let item = {};
        let deepProcessArr = this.get_deep_process(tree);
        let processName = this.get_process_label(deepProcessArr);
        if (processName == "unnamed") {
            processName = this.get_always_events_list(tree, lines).replace(/\s+/g, ' ')
            processName = processName.replace("@", "").replace(/\s*\(/, "(").replace(/\)\s*/, ")");
            if (processName == '') {
                processName = "always-Unconditional"
            }
        } else {
            processName = processName + ":" + this.get_always_events_list(tree, lines).replace(/\s+/g, ' ').replace("@", "");
        }
        //symbol
        item = {
            "name": processName,
            "type": "always",
            "start_index": tree.startIndex,
            "last_index": tree.endIndex
        };
        let symbolInfo = HDLSymbol.setSymbolInformationWithTreeSitter(item, parent, document);
        HDLSymbol.symbols.push(symbolInfo);
        return item;
    }

    get_process_label(tree) {
        let label_txt = '';
        let label = this.get_item_from_childs(tree, "block_identifier");
        if (label === undefined) {
            label_txt = 'unnamed';
        } else {
            label_txt = label.text;
        }
        return label_txt;
    }

    get_deep_process(tree) {
        let statement = this.get_item_from_childs(tree, 'statement');
        let statement_item = this.get_item_from_childs(statement, 'statement_item');
        let procedural_timing_control_statement = this.get_item_from_childs(statement_item, 'procedural_timing_control_statement');
        let statement_or_null = this.get_item_from_childs(procedural_timing_control_statement, 'statement_or_null');
        let statement_2 = this.get_item_from_childs(statement_or_null, 'statement');
        let statement_item_2 = this.get_item_from_childs(statement_2, 'statement_item');
        let seq_block = this.get_item_from_childs(statement_item_2, 'seq_block');
        return seq_block;
    }

    get_always_events_list(tree, lines) {
        let arr = this.search_multiple_in_tree(tree, 'event_control');
        if (arr.length === 0) {
            let name = '';
            return name;
        }
        let always_name = this.extract_data(arr[0], lines);
        return always_name;
    }

    //--------instantiation element--------//
    get_instantiations(tree, lines, parent, HDLSymbol, document, ignore_title) {
        let items = [];
        let item = {};
        //Inputs
        let arr = this.search_multiple_in_tree(tree, 'module_instantiation', ignore_title);
        for (let x = 0; x < arr.length; ++x) {
            item = {
                "name": this.get_element_property(arr[x], lines, "name_of_instance"),
                "type": "instance",
                "instName": this.get_element_property(arr[x], lines, "name_of_instance"),  // name
                "instModule": this.get_element_property(arr[x], lines, "simple_identifier"), // type
                "instModPath": "",
                "start_index": arr[x].startIndex,
                "last_index": arr[x].endIndex
            };
            let symbolInfo = HDLSymbol.setSymbolInformationWithTreeSitter(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
            items.push(item);
        }
        return items;
    }

    //--------ports element--------//
    get_ansi_ports(tree, lines, general_comments) {
        let last_comments = '';
        let last_element_position = -1;
        let ports_types = [
            'inout_declaration',
            'input_declaration',
            'output_declaration',
            'ansi_port_declaration'
        ];

        let ports = [];
        let comments = '';

        let ports_list = this.get_item_from_childs(tree, 'list_of_port_declarations');
        if (ports_list === undefined) {
            return ports;
        }

        let cursor = ports_list.walk();
        cursor.gotoFirstChild();
        do {
            if (ports_types.includes(cursor.nodeType) === true) {
                if (last_element_position === cursor.startPosition.row) {
                    comments = last_comments;
                }
                else {
                    last_comments = comments;
                }
                last_element_position = cursor.startPosition.row;

                let new_ports = this.get_ports(cursor.currentNode(), lines, general_comments);
                new_ports = this.set_description_to_array(new_ports, comments, general_comments);
                ports = ports.concat(new_ports);
                comments = '';
            }
            else if (cursor.nodeType === 'comment') {
                let txt_comment = cursor.nodeText.slice(2);
                let comment_position = cursor.startPosition.row;
                if (txt_comment[0] === this.comment_symbol && last_element_position !== comment_position) {
                    comments += txt_comment.slice(1).trim() + '\n';
                }
                else {
                    comments = '';
                }
            }
            else {
                comments = '';
            }
        } while (cursor.gotoNextSibling() !== false);
        return ports;
    }

    get_ports(tree, lines, parent, HDLSymbol, document, ignore_title) {
        var items = [];
        var element = tree;
        //Inputs
        items = this.add_port(element, 'input_declaration', 'getPortName',
            'input', 'getPortType', false, items, lines);
        //Outputs
        items = this.add_port(element, 'output_declaration', 'getPortName',
            'output', 'getPortType', false, items, lines);
        //inouts
        items = this.add_port(element, 'inout_declaration', 'getPortName',
            "inout", 'getPortType', false, items, lines);
        //ansi_port_declaration
        items = this.add_port(element, 'ansi_port_declaration', 'getPortNameAnsi',
            'getPortKind', 'getPortType', true, items, lines);

        for (let i = 0; i < items.length; i++) {
            const element = items[i];
            let symbolInfo = HDLSymbol.setSymbolInformationWithTreeSitter(element, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }

        return items;
    }

    add_port(element, key, name, direction, type, ansi, items, lines) {
        let directionVar = undefined;
        var item = {};
        var inputs = [];
        var arr = this.search_multiple_in_tree(element, key);
        inputs = arr;
        for (var x = 0; x < inputs.length; ++x) {
            var port_name;
            if (x == 11) {
                console.log("");
            }
            switch (name) {
                case 'getPortName': port_name = this.getPortName(inputs[x], lines); break;
                case 'getPortNameAnsi': port_name = this.getPortNameAnsi(inputs[x], lines); break;
                default: name = this.getPortName;
            }
            port_name = port_name.split(',');
            directionVar = this.getPortKind(inputs[x], lines);
            if (directionVar !== undefined) {
                this.last_direction = directionVar;
            }
            var typeVar;
            switch (type) {
                case 'getPortType': typeVar = this.getPortType(inputs[x], lines); break;
                default: typeVar = this.getPortType(inputs[x], lines);
            }
            
            for (var i = 0; i < port_name.length; i++) {
                if (directionVar === undefined) {
                    directionVar = this.last_direction;
                }
                let portWidth = typeVar.match(/(\[(\w|\W)+\])+/);
                item = {
                    'name' : port_name[i],
                    'type' : ((ansi === true) ? directionVar : direction),
                    'range': portWidth == null ? "" : portWidth[0],
                    "default_value": "",
                    "start_index": inputs[x].startIndex,
                    "last_index" : inputs[x].endIndex
                };
                items.push(item);
            }
        }
        return items;
    }

    getPortName(port, lines) {
        var arr = this.search_multiple_in_tree(port, 'list_of_port_identifiers');
        var port_name;
        if (arr.length === 0) {
            arr = this.search_multiple_in_tree(port, 'list_of_variable_identifiers');
        }
        if (arr.length === 0) {
            arr = this.search_multiple_in_tree(port, 'port_identifier');
        }
        for (var x = 0; x < arr.length; ++x) {
            // if (x === 0) {
            //     port_name = this.extract_data(arr[x], lines);
            // } else {
            //     port_name = port_name + ',' + this.extract_data(arr[x], lines);
            // }
            port_name = arr[x].text.replace(/\s*/g,"");
        }
        return port_name;
    }

    getPortNameAnsi(port, lines) {
        let arr = this.search_multiple_in_tree(port, 'port_identifier');
        if (arr.length === 0) {
            arr = this.search_multiple_in_tree(port, 'simple_identifier');
            let port_name = this.extract_data(arr[0], lines);
            return port_name;
        } else {
            let port_name = this.extract_data(arr[0], lines);
            let split_port_name = port_name.split(',');
            for (let x = 0; x < split_port_name.length; ++x) {
                return port_name;
            }
        }
    }

    getPortKind(port, lines) {
        var arr = this.search_multiple_in_tree(port, 'port_direction');
        if (arr[0] == null) {
            return;
        }
        var port_type = this.extract_data(arr[0], lines);
        return port_type;
    }

    getPortType(port, lines) {
        var arr = this.search_multiple_in_tree(port, 'net_port_type1');
        if (arr[0] == null) {
            arr = this.search_multiple_in_tree(port, 'packed_dimension');
        }
        if (arr[0] == null) {
            return "";
        }
        var port_type = this.extract_data(arr[0], lines);
        return port_type;
    }

    get_port_default(input, lines) {
        let arr = this.search_multiple_in_tree(input, 'list_of_interface_identifiers');
        if (arr.length === 0) {
            let name = "undefined";
            return name;
        }
        let input_name = this.extract_data(arr[0], lines);
        return input_name;
    }

    get_port_sort(ports) {
        let port = {
            "inout" : [],
            "input" : [],
            "output": []
        };
        if (ports != undefined) {
            for (let i = 0; i < ports.length; i++) {
                const portelement = ports[i];
                let portProperty = {
                    "portName" : portelement.name,
                    "portWidth": portelement.range
                };
                switch (portelement.type) {
                    case "inout":
                        port.inout.push(portProperty);
                        break;
                    case "input":
                        port.input.push(portProperty);
                        break;
                    case "output":
                        port.output.push(portProperty);
                        break;
                    default: break;
                }
            }
        }
        return port;
    }

    //--------param element--------//
    get_ansi_generics(tree, lines, general_comments) {
        let last_element_position = -1;
        let generics_types = ['parameter_port_declaration'];
        let last_comments = '';

        let generics = [];
        let comments = '';

        let generics_list = this.get_item_from_childs(tree, 'parameter_port_list');
        if (generics_list === undefined) {
            return generics;
        }

        let cursor = generics_list.walk();
        cursor.gotoFirstChild();
        do {
            if (generics_types.includes(cursor.nodeType) === true) {
                if (last_element_position === cursor.startPosition.row) {
                    comments = last_comments;
                }
                else {
                    last_comments = comments;
                }
                last_element_position = cursor.startPosition.row;

                let new_generics = this.get_generics(cursor.currentNode(), lines, general_comments, 1);
                new_generics = this.set_description_to_array(new_generics, comments, general_comments);
                generics = generics.concat(new_generics);
                comments = '';
            }
            else if (cursor.nodeType === 'comment') {
                let comment_position = cursor.startPosition.row;
                let txt_comment = cursor.nodeText.slice(2);
                if (txt_comment[0] === this.comment_symbol && last_element_position !== comment_position) {
                    comments += txt_comment.slice(1).trim() + '\n';
                }
                else {
                    comments = '';
                }
            }
            else {
                comments = '';
            }
        } while (cursor.gotoNextSibling() !== false);
        return generics;
    }

    get_generics(tree, lines, parent, HDLSymbol, document, ignore_title) {
        let items = [];
        let item = {};
        let arr = [];
        
        arr = this.search_multiple_in_tree(tree, 'parameter_declaration', ignore_title);
        // if (arr.length === 0) {
        //     arr = this.search_multiple_in_tree(tree, 'parameter_port_declaration', ignore_title);
        // }

        for (let x = 0; x < arr.length; ++x) {
            let paramtype = this.get_generic_kind(arr[x], lines);
            let paramWidth = paramtype.match(/(\[(\w|\W)+\])+/);
            item = {
                "name": this.get_generic_name(arr[x], lines),
                "type": "parameter",
                "paramName": this.get_generic_name(arr[x], lines),
                "paramWidth": paramWidth == null ? "" : paramWidth[0],
                "paramInit": this.get_generic_default(arr[x], lines)
            };
            // TODO :there is a bug
            // let symbolInfo = HDLSymbol.setSymbolInformationWithTreeSitter(item, parent, document);
            // HDLSymbol.symbols.push(symbolInfo);
            items.push(item);
        }
        return items;
    }

    get_generic_name(port, lines) {
        let arr = this.search_multiple_in_tree(port, 'parameter_identifier');
        if (arr.length === 1) {
            arr = this.search_multiple_in_tree(port, 'simple_identifier');
            let port_name = this.extract_data(arr[0], lines);
            return port_name;
        } else {
            let port_name = this.extract_data(arr[0], lines);
            let split_port_name = port_name.split(',');
            for (let x = 0; x < split_port_name.length; ++x) {
                return port_name;
            }
        }
    }

    get_generic_default(input, lines) {
        var arr = this.search_multiple_in_tree(input, 'constant_param_expression');
        if (arr.length === 0) {
            var name = "undefined";
            return name;
        }
        var input_value = this.extract_data(arr[0], lines);
        return input_value;
    }

    get_generic_kind(port, lines) {
        let arr = this.search_multiple_in_tree(port, 'data_type_or_implicit1');
        if (arr.length === 0) {
            return "";
        } else {
            let port_name = this.extract_data(arr[0], lines);
            let split_port_name = port_name.split(',');
            for (let x = 0; x < split_port_name.length; ++x) { return port_name; }
        }
    }

    //--------localparam element--------//
    get_ansi_constants(tree, lines, general_comments) {
        let last_element_position = -1;
        let constants_types = ['parameter_port_declaration'];
        let last_comments = '';

        let constants = [];
        let comments = '';

        let constants_list = this.get_item_from_childs(tree, 'parameter_port_list');
        if (constants_list === undefined) {
            return constants;
        }

        let cursor = constants_list.walk();
        cursor.gotoFirstChild();
        do {
            if (constants_types.includes(cursor.nodeType) === true) {
                if (last_element_position === cursor.startPosition.row) {
                    comments = last_comments;
                }
                else {
                    last_comments = comments;
                }
                last_element_position = cursor.startPosition.row;

                let new_constants = this.get_constants(cursor.currentNode(), lines, general_comments, 1);
                new_constants = this.set_description_to_array(new_constants, comments, general_comments);
                constants = constants.concat(new_constants);
                comments = '';
            }
            else if (cursor.nodeType === 'comment') {
                let comment_position = cursor.startPosition.row;
                let txt_comment = cursor.nodeText.slice(2);
                if (txt_comment[0] === this.comment_symbol && last_element_position !== comment_position) {
                    comments += txt_comment.slice(1).trim() + '\n';
                }
                else {
                    comments = '';
                }
            }
            else {
                comments = '';
            }
        } while (cursor.gotoNextSibling() !== false);
        return constants;
    }

    get_constants(tree, lines, parent, HDLSymbol, document, ignore_title) {
        let items = [];
        let item  = {};
        //Inputs
        let localParamArr = this.search_multiple_in_tree(tree, 'local_parameter_declaration', ignore_title);
        for (let x = 0; x < localParamArr.length; ++x) {
            let arr = this.search_multiple_in_tree(localParamArr[x], 'param_assignment');
            for (let i = 0; i < arr.length; ++i) {
                item = {
                    "name" : this.get_constant_name(arr[i], lines),
                    "type" : "localparam",
                    "range": this.get_constant_type(localParamArr[x], lines),
                    "default_value": this.get_constant_default(arr[i], lines),
                    "start_index": localParamArr[i].startIndex,
                    "last_index" : localParamArr[i].endIndex
                };
                let symbolInfo = HDLSymbol.setSymbolInformationWithTreeSitter(item, parent, document);
                HDLSymbol.symbols.push(symbolInfo);
                items.push(item);
            }
        }
        return items;
    }

    get_constant_name(input, lines) {
        let arr = this.search_multiple_in_tree(input, 'parameter_identifier');
        if (arr.length === 0) {
            let name = "undefined";
            return name;
        }
        let input_name = this.extract_data(arr[0], lines);
        return input_name;
    }

    get_constant_type(input, lines) {
        let arr = this.search_multiple_in_tree(input, 'data_type_or_implicit1');
        if (arr.length === 0) {
            let name = '';
            return name;
        }
        let input_name = this.extract_data(arr[0], lines);
        return input_name;
    }

    get_constant_default(input, lines) {
        let arr = this.search_multiple_in_tree(input, 'constant_param_expression');
        if (arr.length === 0) {
            let name = "undefined";
            return name;
        }
        let input_name = this.extract_data(arr[0], lines);
        return input_name;
    }

    //--------signal element--------//
    get_signals(tree, lines, parent, HDLSymbol, document, ignore_title) {
        let items = [];
        //Inputs
        let netArr = this.search_multiple_in_tree(tree, 'net_declaration', ignore_title);
        let dataArr = this.search_multiple_in_tree(tree, 'data_declaration', ignore_title);

        this.get_signal_array(netArr, items, lines, 'list_of_net_decl_assignments',
            'net_type', 'packed_dimension', tree);

        this.get_signal_array(dataArr, items, lines, 'list_of_variable_decl_assignments',
            'data_type_or_implicit1', 0, tree);

        for (let i = 0; i < items.length; i++) {
            const element = items[i];
            let symbolInfo = HDLSymbol.setSymbolInformationWithTreeSitter(element, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }

        return items;
    }

    get_signal_array(inputs, items, lines, name_command, type_command, type_dim, element) {
        var item = {};
        for (var x = 0; x < inputs.length; ++x) {
            let comment = "";
            var arr_signals = this.get_signal_name(inputs[x], lines, name_command);
            if (arr_signals !== 'undefined') {
                let signal_type = this.get_signal_type(inputs[x], lines, type_command);
                // if (signal_type_dim !== 'undefined') {
                //     if (signal_type !== signal_type_dim) {
                //         signal_type = signal_type_dim;
                //     }
                // }
                for (var s = 0; s < arr_signals.length; ++s) {
                    var name_signal = arr_signals[s];
                    item = {
                        "name": name_signal.trim(),
                        "type": signal_type,
                        "description": comment,
                        "start_index": inputs[x].startIndex,
                        "last_index": inputs[x].endIndex,
                        "start_line": inputs[x].startPosition.row
                    };
                    if (signal_type !== 'undefined') {
                        items.push(item);
                    }
                }
            }
        }
        return items;
    }

    get_signal_type(input, lines, command) {
        let arr = this.search_multiple_in_tree(input, 'integer_vector_type');
        if (arr.length === 0) {
            arr = this.search_multiple_in_tree(input, command);
        }
        if (arr.length === 0) {
            arr = this.search_multiple_in_tree(input, 'net_type');
        }
        if (arr.length === 0) {
            let name = "undefined";
            return name;
        }
        let always_name = this.extract_data(arr[0], lines);
        return always_name;
    }

    get_signal_name(input, lines) {
        let arr = this.search_multiple_in_tree(input, 'net_identifier');
        let names = [];
        let name;
        if (arr.length === 0) {
            name = "undefined";
        } else {
            for (let i = 0; i < arr.length; ++i) {
                let input_name = this.extract_data(arr[i], lines);
                names.push(input_name);
            }
        }
        let arr2 = this.search_multiple_in_tree(input, 'variable_identifier');
        if (arr2.length === 0 && name === "undefined") {
            name = "undefined";
            return name;
        }
        for (let i = 0; i < arr2.length; ++i) {
            let input_name = this.extract_data(arr2[i], lines);
            names.push(input_name);
        }
        return names;
    }

    /////////////////////////others api////////////////////////////////////
    get_package_declaration(tree, lines) {
        var element = tree;
        var arr = this.search_multiple_in_tree(element, 'package_identifier');
        element = arr;
        arr = this.search_multiple_in_tree(element[0], 'simple_identifier');
        var module_index = this.index(arr[0]);
        let item = {
            "name": this.extract_data(arr[0], lines),
            "description": ""
        };

        var description = "";
        var comments = this.search_multiple_in_tree(tree, 'comment');
        for (var x = 0; x < comments.length; ++x) {
            if (comments[x].startPosition.row >= module_index[0]) { break; }
            var comment_str = this.extract_data(comments[x], lines).substr(2) + '\n ';
            if (this.comment_symbol === "" || comment_str[0] === this.comment_symbol) {
                description += comment_str.substring(1);
            }
        }
        description += '\n';
        item["description"] = description;

        return item;
    }

    get_libraries() {
        return [];
    }

    get_library_name(tree, lines) {
        let arr = this.search_multiple_in_tree(tree, 'double_quoted_string');
        if (arr.length === 0) {
            let lib = this.extract_data(arr[0], lines);
            return lib;
        } else {
            let lib = this.extract_data(arr[0], lines).substr(1, this.extract_data(arr[0], lines).length - 2);
            let split_lib = lib.split(',');
            for (let x = 0; x < split_lib.length; ++x) {
                return lib;
            }
        }
    }

    get_types(tree, lines) {
        var items = [];
        var inputs = [];
        var item = {};
        var element = tree;
        let start_line = element.startPosition.row;
        //Inputs
        var arr = this.search_multiple_in_tree(element, 'interface_port_declaration'); //port_declaration
        inputs = arr;
        for (var x = 0; x < inputs.length; ++x) {
            let comment = "";
            var arr_types = this.get_type_name(inputs[x], lines);
            var split_arr_types = arr_types.split(',');
            for (var s = 0; s < split_arr_types.length; ++s) {
                var name_type = split_arr_types[s];
                item = {
                    "name": name_type.trim(),
                    "type": this.get_type_type(inputs[x], lines),
                    "description": comment,
                    "start_index": element.startIndex,
                    "last_index": element.endIndex,
                    'start_line': start_line
                };
                items.push(item);
            }
        }
        return items;
    }

    get_type_type(input, lines) {
        var arr = this.search_multiple_in_tree(input, 'interface_identifier');
        if (arr.length === 0) {
            var name = "undefined";
            return name;
        }
        var always_name = this.extract_data(arr[0], lines);
        return always_name;
    }

    get_type_type_pkg(input) {
        let arr = this.search_multiple_in_tree(input, 'data_type');
        if (arr.length === 0) {
            let name = "undefined";
            return name;
        }
        let name = arr[0].text.replace(/\/\/(.+)/gi, '');
        return name;
    }

    get_type_name(input, lines) {
        let arr = this.search_multiple_in_tree(input, 'list_of_interface_identifiers');
        if (arr.length === 0) {
            let name = "undefined";
            return name;
        }
        let input_name = this.extract_data(arr[0], lines);
        return input_name;
    }

    get_type_name_pkg(input, lines) {
        let arr = this.search_multiple_in_tree(input, 'type_identifier');
        if (arr.length === 0) {
            let name = "undefined";
            return name;
        }
        let input_name = this.extract_data(arr[0], lines);
        return input_name;
    }

    get_types_pkg(tree, lines) {
        var items = [];
        var inputs = [];
        var item = {};
        var element = tree;
        let start_line = element.startPosition.row;
        //Inputs
        var arr = this.search_multiple_in_tree(element, 'type_declaration'); //port_declaration
        inputs = arr;
        for (var x = 0; x < inputs.length; ++x) {
            let comment = "";
            let type = this.get_type_type_pkg(inputs[x], lines);
            var arr_types = this.get_type_name_pkg(inputs[x], lines);
            var split_arr_types = arr_types.split(',');
            for (var s = 0; s < split_arr_types.length; ++s) {
                var name_type = split_arr_types[s];
                item = {
                    "name": name_type.trim(),
                    "type": type,
                    "description": comment,
                    "start_index": element.startIndex,
                    "last_index": element.endIndex,
                    'start_line': start_line
                };
                if (type !== '') {
                    items.push(item);
                }
            }
        }
        return items;
    }

    //////////////////////////////////////////////////////////////////////////////
    get_element_property(tree, lines, description, ignore_title) {
        let arr = this.search_multiple_in_tree(tree, description, ignore_title);
        if (arr.length === 0) {
            let element = "undefined";
            return element;
        }
        let element = this.extract_data(arr[0], lines);
        return element;
    }

    get_comments(tree, lines) {
        var item = {};
        var inputs = [];
        var arr = this.search_multiple_in_tree(tree, 'comment');
        inputs = arr;
        for (var x = 0; x < inputs.length; ++x) {
            item[inputs[x].startPosition.row] = this.extract_data(inputs[x], lines).substr(2);
        }
        return item;
    }

    set_description_to_array(arr, txt, general_comments) {
        for (let i = 0; i < arr.length; ++i) {
            let comment_candidate = general_comments[arr[i].start_line];
            if (comment_candidate !== undefined) {
                let result = this.check_comment(comment_candidate);
                if (result.check === true) {
                    arr[i].description = result.comment;
                }
            }
            if (arr[i].description === '') {
                arr[i].description = txt;
            }
        }
        return arr;
    }

    check_comment(comment) {
        let check = false;
        let result = '';
        if (comment[0] === this.comment_symbol) {
            result = comment.slice(1).trim();
            check = true;
        }
        return { check: check, comment: result };
    }

    extract_data(node, lines) {
        // return lines[node.startPosition.row].substr(node.startPosition.column,
        //     node.endPosition.column - node.startPosition.column);
        return node.text.replace(/\s*/g,"");
    }

    index(node) {
        return [node.startPosition.row, node.startPosition.column];
    }

    fileLines(source) {
        var array = source.toString().split("\n");
        return array;
    }
    //////////////////////////////////////////////////////////////////////////////
}
module.exports = Parser;