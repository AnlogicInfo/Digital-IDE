// Copyright 2020 Teros Technology
//
// Ismael Perez Rojo
// Carlos Alberto Ruiz Naranjo
// Alfredo Saez
//
// This file is part of Colibri.
//
// Colibri is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Colibri is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Colibri.  If not, see <https://www.gnu.org/licenses/>.
const base_parser = require('../hdl_parser/base_parser');
const smcat = require("./state-machine-cat");

class Parser_sm_base extends base_parser.base_parser {
  constructor() {
    super();
  }

  check_empty_states_transitions(states) {
    let check = true;
    for (let i = 0; i < states.length; ++i) {
      if (states[i].transitions.length !== 0) {
        check = false;
      }
    }
    return check;
  }

  check_stm(stm) {
    let check = false;
    let states = stm.states;
    for (let i = 0; i < states.length; ++i) {
      let transitions = states[i].transitions;
      if (transitions.length > 0) {
        return true;
      }
    }
    return check;
  }

  json_to_svg(sm_json) {
    let stmcat = this.get_smcat(sm_json);
    let svg;
    try {
      svg = smcat.render(stmcat, { outputType: "svg" });
    }
    // eslint-disable-next-line no-console
    catch (e) { console.log(e); }
    return svg;
  }

  get_smcat(sm_json) {
    let sm_states = '';
    let sm_transitions = '';

    let states = sm_json.states;
    let state_names = [];
    for (let i = 0; i < states.length; ++i) {
      if (states[i].transitions.length === 0) {
        state_names.push(states[i].name);
      }
    }
    let emptys = [];
    for (let i = 0; i < state_names.length; ++i) {
      let empty = true;
      for (let j = 0; j < states.length; ++j) {
        for (let m = 0; m < states[j].transitions.length; ++m) {
          if (states[j].transitions[m].destination === state_names[i]) {
            empty = false;
          }
        }
      }
      if (empty === true) {
        emptys.push(state_names[i]);
      }
    }

    let gosth = [];
    state_names = [];
    for (let i = 0; i < states.length; ++i) {
      state_names.push(states[i].name);
    }
    for (let j = 0; j < states.length; ++j) {
      for (let m = 0; m < states[j].transitions.length; ++m) {
        if (state_names.includes(states[j].transitions[m].destination) === false) {
          let element = { 'name': states[j].transitions[m].destination, 'transitions': [] };
          sm_json.states.push(element);
          gosth.push(states[j].transitions[m].destination);
        }
      }
    }
    let num_states = sm_json.states.length;
    sm_json.states.forEach(function (i_state, i) {
      let transitions = i_state.transitions;
      let state_name = i_state.name;
      if (emptys.includes(state_name) === true || gosth.includes(state_name) === true) {
        sm_states += `${state_name} [color="red"]`;
      }
      else {
        sm_states += `${state_name}`;
      }
      if (i !== num_states - 1) {
        sm_states += ',';
      }
      else {
        sm_states += ';\n';
      }
      if (gosth.includes(state_name) !== true) {
        transitions.forEach(function (i_transition, j) {
          if (gosth.includes(i_transition.destination) === true) {
            sm_transitions +=
              `${state_name} => ${i_transition.destination} [color="red"] : ${i_transition.condition};\n`;
          }
          else {
            sm_transitions += `${state_name} => ${i_transition.destination} : ${i_transition.condition};\n`;
          }
        });
      }
    });
    let str_stm = sm_json.state_variable_name + "{\n" + sm_states + sm_transitions + "\n};";
    return str_stm;
  }

  only_unique(value, index, self) {
    return self.indexOf(value) === index;
  }

}

module.exports = {
  Parser_sm_base: Parser_sm_base
};