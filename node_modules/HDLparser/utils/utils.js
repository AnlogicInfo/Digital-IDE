"use strict";

const fs         = require("fs");
const fspath     = require("path");
const vscode     = require("vscode");
const vlogParser = require("../parser_RegExp/vlogParser");

const backslash = /\\/g;

function getWaveImagePath (text) {
    let waveImagePath = text.match(/\$dumpfile\s*\(\s*\"(.+){1}\"\s*\);/gi);
    waveImagePath = RegExp.$1;
    if (waveImagePath == undefined) {
        waveImagePath = "";
    }
    return waveImagePath;
}
exports.getWaveImagePath = getWaveImagePath;

/**
     * 更新所有模块下所有模块信息 : 名字 + 绝对路径
     * 
     * @param     HDLparam         匹配的文本
     * @returns   ModuleNameList   由名字 + @ + 绝对路径组成的所有模块信息
*/
function getModuleInfoList (HDLparam) {
    let ModuleNameList = [];
    HDLparam.forEach(unitMoudule => {
        let ModuleInfo = unitMoudule.moduleName + 
                         "  @  " +
                         unitMoudule.modulePath;
        ModuleNameList.push(ModuleInfo);
    });
    return ModuleNameList;
}
exports.getModuleInfoList = getModuleInfoList;

/**
     * 根据模块信息(名字 + 绝对路径)找到对应的模块参数信息
     * 通过模块的名字和所在路径进行精确定位
     * 
     * @param   HDLparam         全局HDL文件参数
     * @param   ModuleInfo       待查的模块信息由(名字 + 绝对路径)组成
     * @returns moduleInfo       输出模块的全部信息
*/
function findModuleFromInfo (HDLparam, ModuleInfo) {
    let moduleInfo = [];
    let info = ModuleInfo.split("  @  ");
    let name = info[0];
    let path = info[1];
    HDLparam.forEach(unitMoudule => {
        if (unitMoudule.moduleName == name && 
            unitMoudule.modulePath.indexOf(path) != -1) {
            moduleInfo.push(unitMoudule);
        }
    });
    return moduleInfo;
}
exports.findModuleFromInfo = findModuleFromInfo;

/**
 * 从所有模块信息(名字 + 绝对路径)中选择需要例化的模块进行返回，主要用于例化
 * @param {*} HDLparam 全局HDL文件参数
 * @returns            对应模块所有参数
 */
async function selectModuleFromAll (HDLparam) {
    let allModuleInfos = getModuleInfoList(HDLparam);
    const selectModule = await vscode.window.showQuickPick(allModuleInfos);
    if (!selectModule) {
        return null;
    } else {
        var moduleList = [];
        moduleList = findModuleFromInfo(HDLparam, selectModule);
        if (moduleList.length == 0) {
            vscode.window.showErrorMessage("The module was not found !!!");
            return null;
        } else if (moduleList.length > 1) {
            vscode.window.showErrorMessage("Multiple identical modules exist in the same file !!!");
            return null;
        } else {
            return moduleList[0];
        }
    }
}
exports.selectModuleFromAll = selectModuleFromAll;

/**
     * 根据模块名找到对应的模块属性
     * 
     * @param  HDLparam   全局HDL文件参数
     * @returns           所选模块的 property 属性，如果property为undefined则输出全属性
*/
function findModuleFromName (HDLparam, ModuleName, property) {
    let moduleParam = [];
    let len = HDLparam.length;
    for (let index = 0; index < len; index++) {
        const unitMoudule = HDLparam[index];
        if (unitMoudule.moduleName == ModuleName) {
            if (property == undefined) {
                moduleParam.push(unitMoudule);
            } else {
                moduleParam.push(unitMoudule[property]);
            }
        }
    }
    return moduleParam;
}
exports.findModuleFromName = findModuleFromName;

/**
     * 根据模块名找到对应的模块属性
     * 
     * @param  HDLparam   全局HDL文件参数
     * @returns           所选模块的 property 属性，如果property为undefined则输出全属性
*/
function findModuleFromPath (HDLparam, Path, property) {
    let moduleParam = [];
    let len = HDLparam.length;
    for (let index = 0; index < len; index++) {
        const unitMoudule = HDLparam[index];
        if (unitMoudule.modulePath == Path) {
            if (property == undefined) {
                moduleParam.push(unitMoudule);
            } else {
                moduleParam.push(unitMoudule[property]);
            }
        }
    }
    return moduleParam;
}
exports.findModuleFromPath = findModuleFromPath;

/**
 * 从当前文件中选择指定的模块，按照模块名进行选择，返回的是所选模块的所有属性。
 * @param {*} HDLparam 全局HDL文件参数
 * @param {*} doc      当前文档的属性
 * @returns   所选模块的所有属性
 */
async function selectCurrentFileModule (HDLparam, docPath) {
    docPath = docPath.replace(backslash,"\/");
    let selectModule = null;
    let moduleList = findModuleFromPath(HDLparam, docPath);
    if (moduleList.length == 0) {
        vscode.window.showErrorMessage(`There is no module in ${docPath} !!!`);
    }
    else if (moduleList.length == 1) {
        selectModule = moduleList[0];
    }
    else if (moduleList.length > 1) {
        let moduleNameList = [];
        let len = moduleList.length;
        for (let index = 0; index < len; index++) {
            const element = moduleList[index];
            moduleNameList.push(element.moduleName);
        }
        let selectModuleName = await vscode.window.showQuickPick(moduleNameList, {placeHolder:"Which module you want to select?"});
        for (let index = 0; index < len; index++) {
            const element = moduleList[index];
            if (element.moduleName == selectModuleName) {
                selectModule = element;
                break;
            }
        }
    }
    return selectModule;
}
exports.selectCurrentFileModule = selectCurrentFileModule;

/**
     * 判断是否在非法区间
     * 
     * @param  position     位置{startIndex, lastIndex}
     * @param  range        包含非法区间的数组
     * @return 返回是否在非法区间 true : 在; false : 不在
*/
function isIllegalRange (position, range) {
    let isIllegal = false;
    for (let index = 0; index < range.length; index++) {
        const element = range[index];
        if  ( (position.lastIndex <= element.end) && 
              (position.startIndex >= element.start)) {
            isIllegal = true;
            break;
        } else {
            isIllegal = false;
        }
    }
    return isIllegal;
}
exports.isIllegalRange = isIllegalRange;

function getInstmoduleFilePathList(HDLparam, module, instmoduleFilePathList) {
    let len = HDLparam.length;
    for (let i = 0; i < len; i++) {
        const unitModule = HDLparam[i];
        if (unitModule.moduleName == module.name && 
            unitModule.modulePath == module.path) {
            for (let i = 0; i < unitModule.instances.length; i++) {
                const instanceModule = unitModule.instances[i];
                instmoduleFilePathList.push(instanceModule.instModPath);
                getInstmoduleFilePathList(
                    HDLparam, 
                    {name:instanceModule.instModule, path:instanceModule.instModPath}, 
                    instmoduleFilePathList
                );
            }
            break;
        }         
    }
    instmoduleFilePathList = removeDuplicates(instmoduleFilePathList);
}

function getIncludeFilePathList(HDLparam, module, includeFilePathList) {
    let len = HDLparam.length;
    for (let i = 0; i < len; i++) {
        const unitModule = HDLparam[i];
        if (unitModule.moduleName == module.name && 
            unitModule.modulePath == module.path) {
            let len = unitModule.includes.length;
            // 将相对路径整理成绝对路径
            for (let i = 0; i < len; i++) {
                let pathElement = unitModule.includes[i];
                if (!fspath.isAbsolute(pathElement)) {
                    let parent = fspath.dirname(unitModule.modulePath);
                    pathElement = fspath.resolve(parent, pathElement);
                }
                pathElement = pathElement.replace(/\\/g,"\/").replace("//","/");
                includeFilePathList.push(pathElement);
            }
            len = unitModule.instances.length;
            // 遍历当前模块下的例化模块所在文件的include文件    
            for (let i = 0; i < len; i++) {
                const instanceModule = unitModule.instances[i];
                getIncludeFilePathList(
                    HDLparam, 
                    {name:instanceModule.instModule, path:instanceModule.instModPath}, 
                    includeFilePathList
                );
            }
            break;
        }         
    }
    includeFilePathList = removeDuplicates(includeFilePathList);
}

function getModuleDependence(HDLparam, module, type) {
    let includeFilePathList = [];
    let instmoduleFilePathList = [];

    getIncludeFilePathList(HDLparam, module, includeFilePathList);
    getInstmoduleFilePathList(HDLparam, module, instmoduleFilePathList);

    if (type == "all") {
        // 查找出所有的依赖文件用于在虚拟文件系统下搭建工程
        instmoduleFilePathList = instmoduleFilePathList.concat(includeFilePathList);
        instmoduleFilePathList = removeDuplicates(instmoduleFilePathList);
    } else {
        // 查找出去除include的依赖文件用于在当前文件系统下运行
        let len = includeFilePathList.length;
        for (let i = 0; i < len; i++) {
            let includeFilePathElement = includeFilePathList[i];
            let index = instmoduleFilePathList.indexOf(includeFilePathElement);
            if (index != -1) {
                instmoduleFilePathList.splice(index, 1);
            }
        }
    }
    return instmoduleFilePathList;
}
exports.getModuleDependence = getModuleDependence;

function getTopElement(param, currentTopElement){
    let TopElementList = [];
    let isTopElement = true;
    if (currentTopElement != undefined) {
        TopElementList.push(currentTopElement);
    }
    for (let index = 0; index < param.length; index++) {
        const currentModule = param[index];
        for (let index = 0; index < param.length; index++) {
            const unitModule = param[index];
            for (let index = 0; index < unitModule.instances.length; index++) {
                const unitInstModule = unitModule.instances[index];
                if (unitInstModule.instModule == currentModule.moduleName) {
                    isTopElement = false;
                    break;
                }
            }
            if (!isTopElement) {
                break;
            }
        }
        if (isTopElement) {
            let TopElement = {
                "name"   : "",
                "type"   : "",
                "fsPath" : ""
            };
            TopElement.name   = "";
            TopElement.type   = currentModule.moduleName;
            TopElement.fsPath = currentModule.modulePath;
            TopElementList.push(TopElement);
        } else {
            isTopElement = true;
        }
    }
    return TopElementList;
}
exports.getTopElement = getTopElement;

function getChildElement(element, HDLparam){
    let childElementList = [];
    HDLparam.forEach(unitModule => {
        if (unitModule.moduleName == element) {
            unitModule.instances.forEach(unitInstModule => {
                let childElement = {
                    "name"   : "",
                    "type"   : "",
                    "fsPath" : ""
                };
                childElement.name   = unitInstModule.instName;
                childElement.type   = unitInstModule.instModule;
                childElement.fsPath = unitInstModule.instModPath;
                childElementList.push(childElement);
            });
        }
    });
    return childElementList;
}
exports.getChildElement = getChildElement;

function getTopType(path) {
    if (path.indexOf("sim") != -1 || path.indexOf("testbench") != -1) {
        return "sim";
    } else {
        return "src";
    }
}
exports.getTopType = getTopType;

function getSrcTopElement(opeParam, HDLparam, currentSrcTopElement) {
    let srcHDLparam       = [];
    let TopElementList    = [];
    let srcTopElementList = [];
    for (let i = 0; i < HDLparam.length; i++) {
        const element = HDLparam[i];
        if (element.modulePath.replace(opeParam.workspacePath,'').indexOf("sim") == -1) {
            srcHDLparam.push(element);
        }
    }
    TopElementList = getTopElement(srcHDLparam, currentSrcTopElement);
    for (let i = 0; i < TopElementList.length; i++) {
        const element = TopElementList[i];
        let path = element.fsPath.replace(opeParam.workspacePath,'');
        if (getTopType(path) == "src") {
            srcTopElementList.push(element);
        }
    }
    let len = srcTopElementList.length;
    // 如果没有src文件则直接退出
    if (len == 0) {
        return srcTopElementList;
    }
    if (opeParam.srcTopModule.name == '') {
        // 如果没有就将第一个设置为当前顶层
        opeParam.srcTopModule = {
            name : srcTopElementList[0].type,
            path : srcTopElementList[0].fsPath,
        }
    } else {
        // 如果存在就将其设置为第一个显示
        let isExsit = false;
        for (let index = 0; index < len; index++) {
            const simTopElement = srcTopElementList[index];
            if (opeParam.srcTopModule.name == simTopElement.type &&
                opeParam.srcTopModule.path == simTopElement.fsPath) {
                // 如果在第i个为当前顶层则将其删除
                srcTopElementList.splice(index, 1);
                isExsit = true;
                break;
            }
        }
        if (isExsit) {
            let TopElement = {
                "mode"   : "src",
                "name"   : "",
                "type"   : opeParam.srcTopModule.name,
                "fsPath" : opeParam.srcTopModule.path
            };
            // 直接插入到顶层数组的第一个
            srcTopElementList.splice(0, 0, TopElement);
        } else {
            opeParam.srcTopModule = {
                name : srcTopElementList[0].type,
                path : srcTopElementList[0].fsPath,
            }
        }
    }
    return srcTopElementList;
}
exports.getSrcTopElement = getSrcTopElement;

function getSimTopElement(opeParam, HDLparam, currentTbTopElement) {
    let TopElementList    = [];
    let simTopElementList = [];
    TopElementList = getTopElement(HDLparam, currentTbTopElement);
    for (let i = 0; i < TopElementList.length; i++) {
        const element = TopElementList[i];
        let path = element.fsPath.replace(opeParam.workspacePath,'');
        if (getTopType(path) == "sim") {
            simTopElementList.push(element);
        }
    }
    let len = simTopElementList.length;
    // 如果没有sim文件则直接退出
    if (len == 0) {
        return simTopElementList;
    }
    if (opeParam.simTopModule.name == '') {
        // 如果没有就将第一个设置为当前顶层
        opeParam.simTopModule = {
            name : simTopElementList[0].type,
            path : simTopElementList[0].fsPath,
        }
    } else {
        // 如果存在就将其设置为第一个显示
        let isExsit = false;
        for (let index = 0; index < len; index++) {
            const simTopElement = simTopElementList[index];
            if (opeParam.simTopModule.name == simTopElement.type &&
                opeParam.simTopModule.path == simTopElement.fsPath) {
                // 如果在第i个为当前顶层则将其删除
                simTopElementList.splice(index, 1);
                isExsit = true
                break;
            }
        }
        if (isExsit) {
            let TopElement = {
                "mode"   : "sim",
                "name"   : "",
                "type"   : opeParam.simTopModule.name,
                "fsPath" : opeParam.simTopModule.path
            };
            // 直接插入到顶层数组的第一个
            simTopElementList.splice(0, 0, TopElement);
        } else {
            opeParam.simTopModule = {
                name : simTopElementList[0].type,
                path : simTopElementList[0].fsPath,
            }
        }
    }
    return simTopElementList;
}
exports.getSimTopElement = getSimTopElement;

function removeDuplicates(arry) {
    let r = [];
    for(var i = 0, l = arry.length; i < l; i++) {
        for(var j = i + 1; j < l; j++)
        if (arry[i] === arry[j]) j = ++i;
        r.push(arry[i]);
    }
    return r;
}
exports.removeDuplicates = removeDuplicates;

function getLanguageId(path) {
    let vhdlExtensions = [".vhd",".vhdl",".vho",".vht"];
    let vlogExtensions = [".v",".V",".vh",".vl",".sv",".SV"];
    let value = fspath.extname(path).toLowerCase();
    if (vlogExtensions.includes(value)) {
        return "vlog";
    }
    else if (vhdlExtensions.includes(value)) {
        return "vhdl";
    }
    return null;
}
exports.getLanguageId = getLanguageId;