"use strict";

const fs         = require("fs");
const fspath     = require("path");
const vscode     = require("vscode");

const backslash = /\\/g;

function getWaveImagePath (text) {
    let waveImagePath = text.match(/\$dumpfile\s*\(\s*\"(.+){1}\"\s*\);/gi);
    waveImagePath = RegExp.$1;
    if (waveImagePath == undefined) {
        waveImagePath = "";
    }
    return waveImagePath;
}
exports.getWaveImagePath = getWaveImagePath;

/**
     * 更新所有模块下所有模块信息 : 名字 + 绝对路径
     * 
     * @param     HDLparam         匹配的文本
     * @returns   ModuleNameList   由名字 + @ + 绝对路径组成的所有模块信息
*/
function getModuleInfoList (HDLparam) {
    let ModuleNameList = [];
    HDLparam.forEach(unitMoudule => {
        let ModuleInfo = unitMoudule.moduleName + 
                         "  @  " +
                         unitMoudule.modulePath;
        ModuleNameList.push(ModuleInfo);
    });
    return ModuleNameList;
}
exports.getModuleInfoList = getModuleInfoList;

/**
     * 根据模块信息(名字 + 绝对路径)找到对应的模块参数信息
     * 通过模块的名字和所在路径进行精确定位
     * 
     * @param   HDLparam         全局HDL文件参数
     * @param   ModuleInfo       待查的模块信息由(名字 + 绝对路径)组成
     * @returns moduleInfo       输出模块的全部信息
*/
function findModuleFromInfo (HDLparam, ModuleInfo) {
    let moduleInfo = [];
    let info = ModuleInfo.split("  @  ");
    let name = info[0];
    let path = info[1];
    HDLparam.forEach(unitMoudule => {
        if (unitMoudule.moduleName == name && 
            unitMoudule.modulePath.indexOf(path) != -1) {
            moduleInfo.push(unitMoudule);
        }
    });
    return moduleInfo;
}
exports.findModuleFromInfo = findModuleFromInfo;

/**
 * 从所有模块信息(名字 + 绝对路径)中选择需要例化的模块进行返回，用于例化
 * @param {*} HDLparam 全局HDL文件参数
 * @returns            对应模块所有参数
 */
async function selectModuleFromAll (HDLparam) {
    let allModuleInfos = getModuleInfoList(HDLparam);
    const selectModule = await vscode.window.showQuickPick(allModuleInfos);
    if (!selectModule) {
        return null;
    } else {
        var moduleList = [];
        moduleList = findModuleFromInfo(HDLparam, selectModule);
        if (moduleList.length == 0) {
            vscode.window.showErrorMessage("The module was not found !!!");
            return null;
        } else if (moduleList.length > 1) {
            vscode.window.showErrorMessage("Multiple identical modules exist in the same file !!!");
            return null;
        } else {
            return moduleList[0];
        }
    }
}
exports.selectModuleFromAll = selectModuleFromAll;

/**
     * 根据模块名找到对应的模块属性
     * 
     * @param  HDLparam   全局HDL文件参数
     * @returns           所选模块的 property 属性，如果property为undefined则输出全属性
*/
function findModuleFromName (HDLparam, ModuleName, property) {
    let moduleParam = [];
    let len = HDLparam.length;
    for (let index = 0; index < len; index++) {
        const unitMoudule = HDLparam[index];
        if (unitMoudule.moduleName == ModuleName) {
            if (property == undefined) {
                moduleParam.push(unitMoudule);
            } else {
                moduleParam.push(unitMoudule[property]);
            }
        }
    }
    return moduleParam;
}
exports.findModuleFromName = findModuleFromName;

/**
     * 根据模块名找到对应的模块属性
     * 
     * @param  HDLparam   全局HDL文件参数
     * @returns           所选模块的 property 属性，如果property为undefined则输出全属性
*/
function findModuleFromPath (HDLparam, Path, property) {
    let moduleParam = [];
    let len = HDLparam.length;
    for (let index = 0; index < len; index++) {
        const unitMoudule = HDLparam[index];
        if (unitMoudule.modulePath == Path) {
            if (property == undefined) {
                moduleParam.push(unitMoudule);
            } else {
                moduleParam.push(unitMoudule[property]);
            }
        }
    }
    return moduleParam;
}
exports.findModuleFromPath = findModuleFromPath;

/**
 * 从当前文件中选择指定的模块，按照模块名进行选择，返回的是所选模块的所有属性。
 * @param {*} HDLparam 全局HDL文件参数
 * @param {*} doc      当前文档的属性
 * @returns   所选模块的所有属性
 */
async function selectCurrentFileModule (HDLparam, docPath) {
    docPath = docPath.replace(backslash,"\/");
    let selectModule = null;
    let moduleList = findModuleFromPath(HDLparam, docPath);
    if (moduleList.length == 0) {
        vscode.window.showErrorMessage(`There is no module in ${docPath} !!!`);
    }
    else if (moduleList.length == 1) {
        selectModule = moduleList[0];
    }
    else if (moduleList.length > 1) {
        let moduleNameList = [];
        let len = moduleList.length;
        for (let index = 0; index < len; index++) {
            const element = moduleList[index];
            moduleNameList.push(element.moduleName);
        }
        let selectModuleName = await vscode.window.showQuickPick(moduleNameList, {placeHolder:"Which module you want to select?"});
        for (let index = 0; index < len; index++) {
            const element = moduleList[index];
            if (element.moduleName == selectModuleName) {
                selectModule = element;
                break;
            }
        }
    }
    return selectModule;
}
exports.selectCurrentFileModule = selectCurrentFileModule;

/**
     * 判断是否在非法区间
     * 
     * @param  position     位置{startIndex, lastIndex}
     * @param  range        包含非法区间的数组
     * @return 返回是否在非法区间 true : 在; false : 不在
*/
function isIllegalRange (position, range) {
    let isIllegal = false;
    for (let index = 0; index < range.length; index++) {
        const element = range[index];
        if  ( (position.lastIndex <= element.end) && 
              (position.startIndex >= element.start)) {
            isIllegal = true;
            break;
        } else {
            isIllegal = false;
        }
    }
    return isIllegal;
}
exports.isIllegalRange = isIllegalRange;

function getInstmoduleFilePathList(HDLparam, module, instmoduleFilePathList) {
    let len = HDLparam.length;
    for (let i = 0; i < len; i++) {
        const unitModule = HDLparam[i];
        if (unitModule.moduleName == module.name && 
            unitModule.modulePath == module.path) {
            for (let i = 0; i < unitModule.instances.length; i++) {
                const instanceModule = unitModule.instances[i];
                if (instanceModule.instModPath != module.path) {
                    instmoduleFilePathList.push(instanceModule.instModPath);
                }
                getInstmoduleFilePathList(
                    HDLparam, 
                    {name:instanceModule.instModule, path:instanceModule.instModPath}, 
                    instmoduleFilePathList
                );
            }
            break;
        }         
    }
}

function getIncludeFilePathList(HDLparam, module, includeFilePathList) {
    let len = HDLparam.length;
    for (let i = 0; i < len; i++) {
        const unitModule = HDLparam[i];
        if (unitModule.moduleName == module.name && 
            unitModule.modulePath == module.path) {
            let len = unitModule.includes.length;
            // 将相对路径整理成绝对路径
            for (let i = 0; i < len; i++) {
                let pathElement = unitModule.includes[i];
                includeFilePathList.push(pathElement);
            }
            len = unitModule.instances.length;
            // 递归遍历当前模块下的例化模块所包含的include文件    
            for (let i = 0; i < len; i++) {
                const instanceModule = unitModule.instances[i];
                getIncludeFilePathList(
                    HDLparam, 
                    {name:instanceModule.instModule, path:instanceModule.instModPath}, 
                    includeFilePathList
                );
            }
            break;
        }         
    }
}

/**
 * CN: 获取顶层模块所需要的依赖
 * @param {*} HDLparam 全局HDL文件参数
 * @param {*} module   顶层模块的信息 {name, path}
 * @returns 
 */
function getModuleDependence(HDLparam, module) {
    let includeFilePathList = [];
    let instmoduleFilePathList = [];

    getIncludeFilePathList(HDLparam, module, includeFilePathList);
    getInstmoduleFilePathList(HDLparam, module, instmoduleFilePathList);

    includeFilePathList = removeDuplicates(includeFilePathList);
    instmoduleFilePathList = removeDuplicates(instmoduleFilePathList);

    // 从instmodule中去除include同名文件的部分
    let len = includeFilePathList.length;
    for (let i = 0; i < len; i++) {
        let includeFilePathElement = includeFilePathList[i];
        let index = instmoduleFilePathList.indexOf(includeFilePathElement);
        if (index != -1) {
            instmoduleFilePathList.splice(index, 1);
        }
    }

    // 
    return {
        inst:instmoduleFilePathList,
        include:includeFilePathList
    };
}
exports.getModuleDependence = getModuleDependence;

function getTopElement(param, type){
    let TopElementList = [];
    let isTopElement = true;
    
    for (let index = 0; index < param.length; index++) {
        const currentModule = param[index];
        for (let index = 0; index < param.length; index++) {
            const unitModule = param[index];
            for (let index = 0; index < unitModule.instances.length; index++) {
                const unitInstModule = unitModule.instances[index];
                if (unitInstModule.instModule == currentModule.moduleName) {
                    isTopElement = false;
                    break;
                }
            }
            if (!isTopElement) {
                break;
            }
        }
        if (isTopElement) {
            let TopElement = {
                "mode"   : "top",
                "type"   : type,
                "name"   : "",
                "fsPath" : ""
            };
            TopElement.name   = currentModule.moduleName;
            TopElement.fsPath = currentModule.modulePath;
            TopElementList.push(TopElement);
        } else {
            isTopElement = true;
        }
    }
    return TopElementList;
}
exports.getTopElement = getTopElement;

function removeDuplicates(array) {
    let h = {};
    let arr = [];
    for(let i=0;i<array.length;i++){
        if(!h[array[i]]){
            h[array[i]] = true;
            arr.push(array[i]);
        }
    }
    return arr;
    // return Array.from(new Set(array));
}
exports.removeDuplicates = removeDuplicates;

function getLanguageId(path) {
    let vhdlExtensions = [".vhd",".vhdl",".vho",".vht"];
    let vlogExtensions = [".v",".V",".vh",".vl",".sv",".SV"];
    let svlogExtensions = [".sv",".SV"];
    let value = fspath.extname(path).toLowerCase();
    if (vlogExtensions.includes(value)) {
        return "verilog";
    }
    else if (svlogExtensions.includes(value)) {
        return "systemverilog";
    }
    else if (vhdlExtensions.includes(value)) {
        return "vhdl";
    }
    return null;
}
exports.getLanguageId = getLanguageId;