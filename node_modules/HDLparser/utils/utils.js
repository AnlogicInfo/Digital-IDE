"use strict";

const fs     = require("fs");
const vscode = require("vscode");

function getWaveImagePath (text) {
    let waveImagePath = text.match(/\$dumpfile\s*\(\s*\"(.+){1}\"\s*\);/gi);
    waveImagePath = RegExp.$1;
    if (waveImagePath == undefined) {
        waveImagePath = "";
    }
    return waveImagePath;
}
exports.getWaveImagePath = getWaveImagePath;

/**
     * 根据模块信息找到对应的模块信息
     * 
     * @param  HDLparam         匹配的文本
*/
function findModule (HDLparam, ModuleInfo) {
    let moduleInfo = [];
    HDLparam.forEach(unitMoudule => {
        if (unitMoudule.moduleName == ModuleInfo.split("    .")[0] && 
            unitMoudule.modulePath.indexOf(ModuleInfo.split("    .")[1]) != -1) {
            moduleInfo.push(unitMoudule);
        }
    });
    return moduleInfo;
}
exports.findModule = findModule;

/**
     * 根据模块名找到对应的模块信息
     * 
     * @param  HDLparam         匹配的文本
*/
function findModuleFromName (HDLparam, ModuleName) {
    let moduleInfo = [];
    HDLparam.forEach(unitMoudule => {
        if (unitMoudule.moduleName == ModuleName) {
            moduleInfo.push(unitMoudule);
        }
    });
    return moduleInfo;
}
exports.findModuleFromName = findModuleFromName;

async function selectModule (HDLparam, workspacePath) {
    const selectModule = await vscode.window.showQuickPick(refreshModuleInfoList(HDLparam, workspacePath));
    if (!selectModule) {
        return null;
    } else {
        var moduleList = [];
        moduleList = findModule(HDLparam, selectModule);
        if (moduleList.length == 0) {
            vscode.window.showErrorMessage("The module was not found !!!");
            return null;
        } else if (moduleList.length > 1) {
            vscode.window.showErrorMessage("Multiple identical modules exist in the same file !!!");
            return null;
        } else {
            return moduleList[0];
        }
    }
}
exports.selectModule = selectModule;

async function selectCurrentFileModule (HDLparam, doc) {
    if (!doc) {
        return null;
    }
    let moduleNameList = [];
    HDLparam.forEach(element => {
        if (element.modulePath == doc.fileName.replace(/\\/g,"\/")) {
            moduleNameList.push(element.moduleName);
        }
    });
    if (moduleNameList.length > 1) {
        var selectModule = await vscode.window.showQuickPick(moduleNameList);
    } else if (moduleNameList.length == 1) {
        var selectModule = moduleNameList[0];
    } else {
        return null;
    }
    var moduleList = [];
    moduleList = findModuleFromName(HDLparam, selectModule);
    if (moduleList.length == 0) {
        vscode.window.showErrorMessage("The module was not found !!!");
        return null;
    } else if (moduleList.length > 1) {
        vscode.window.showErrorMessage("Multiple identical modules exist in this file !!!");
        return null;
    } else {
        return moduleList[0];
    }
}
exports.selectCurrentFileModule = selectCurrentFileModule;

/**
     * 更新所有模块下所有模块信息 : 名字 + 相对路径
     * 
     * @param  HDLparam         匹配的文本
*/
function refreshModuleInfoList (HDLparam, workspacePath) {
    let ModuleNameList = [];
    HDLparam.forEach(unitMoudule => {
        let ModuleInfo = unitMoudule.moduleName + "    ." +
                         unitMoudule.modulePath.replace(workspacePath,"");
        ModuleNameList.push(ModuleInfo);
    });
    return ModuleNameList;
}
exports.refreshModuleInfoList = refreshModuleInfoList;

/**
     * 更新所有模块下所例化模块的路径
     * 
     * @param  HDLparam         匹配的文本
*/
function refreshInstModulePath (HDLparam) {
    // 遍历所有模块
    HDLparam.forEach(unitMoudule => {
        // 遍历每个模块下的所有例化模块
        unitMoudule.instmodule.forEach(unitInstanceModule => {
            // 从HDLparam中找到每个例化模块的路径
            HDLparam.forEach(element => {
                if (element.moduleName == unitInstanceModule.instModule) {
                    unitInstanceModule.instModPath = element.modulePath;
                }
            }); 
        });
    });
}
exports.refreshInstModulePath = refreshInstModulePath;

/**
     * 从HDL属性数组中去除当前文件中所包含的HDL属性
     * 
     * @param  document     匹配文本所在的文档属性
     * @param  HDLparam     匹配的文本
     * @return 返回新的HDL属性数组
*/
function removeCurrentFileParam (document, HDLparam) {
    let currentFilePath = document.uri._fsPath.replace(/\\/g,"\/");
    let newHDLparam = [];
    HDLparam.forEach(element => {
        if (element.modulePath != currentFilePath) {
            newHDLparam.push(element);
        }
    });
    return newHDLparam;
}
exports.removeCurrentFileParam = removeCurrentFileParam;

/**
     * 判断是否在非法区间
     * 
     * @param  match        匹配的文本
     * @param  range        包含非法区间的数组
     * @param  offset       匹配地址偏移(即匹配的文本在文件中的地址位置)
     * @return 返回是否在非法区间 true : 在; false : 不在
*/
function isIllegalRange (match, range, offset) {
    let isIllegal = false;
    for (let index = 0; index < range.length; index++) {
        const element = range[index];
        if  ( (match.index + offset <= element.end) && 
              (match.index + offset >= element.start)) {
            isIllegal = true;
            break;
        } else {
            isIllegal = false;
        }
    }
    return isIllegal;
}
exports.isIllegalRange = isIllegalRange;

function getTopElement(param, currentTopElement){
    let TopElementList = [];
    let isTopElement = true;
    if (currentTopElement != undefined) {
        TopElementList.push(currentTopElement);
    }
    for (let index = 0; index < param.length; index++) {
        const currentModule = param[index];
        for (let index = 0; index < param.length; index++) {
            const unitModule = param[index];
            for (let index = 0; index < unitModule.instmodule.length; index++) {
                const unitInstModule = unitModule.instmodule[index];
                if (unitInstModule.instModule == currentModule.moduleName) {
                    isTopElement = false;
                    break;
                }
            }
            if (!isTopElement) {
                break;
            }
        }
        if (isTopElement) {
            let TopElement = {
                "name"   : "",
                "type"   : "",
                "fspath" : ""
            };
            TopElement.name   = "";
            TopElement.type   = currentModule.moduleName;
            TopElement.fspath = currentModule.modulePath;
            TopElementList.push(TopElement);
        } else {
            isTopElement = true;
        }
    }
    return TopElementList;
}
exports.getTopElement = getTopElement;

function getChildElement(element, HDLparam){
    let childElementList = [];
    HDLparam.forEach(unitModule => {
        if (unitModule.moduleName == element) {
            unitModule.instmodule.forEach(unitInstModule => {
                let childElement = {
                    "name"   : "",
                    "type"   : "",
                    "fspath" : ""
                };
                childElement.name   = unitInstModule.instName;
                childElement.type   = unitInstModule.instModule;
                childElement.fspath = unitInstModule.instModPath;
                childElementList.push(childElement);
            });
        }
    });
    return childElementList;
}
exports.getChildElement = getChildElement;

function getSrcTopElement(opeParam, HDLparam, currentSrcTopElement) {
    let srcHDLparam       = [];
    let TopElementList    = [];
    let srcTopElementList = [];
    for (let i = 0; i < HDLparam.length; i++) {
        const element = HDLparam[i];
        if (element.modulePath.replace(opeParam.workspacePath,'').indexOf("sim") == -1) {
            srcHDLparam.push(element);
        }
    }
    TopElementList = getTopElement(srcHDLparam, currentSrcTopElement);
    for (let i = 0; i < TopElementList.length; i++) {
        const element = TopElementList[i];
        let path = element.fspath.replace(opeParam.workspacePath,'');
        if (path.indexOf("src") != -1 || path.indexOf("source") != -1 || path.indexOf("bd") != -1) {
            srcTopElementList.push(element);
        }
        if (opeParam.prjInfo == null && path.indexOf("src") == -1 && path.indexOf("source") == -1) {
            srcTopElementList.push(element);
        }
    }
    return srcTopElementList;
}
exports.getSrcTopElement = getSrcTopElement;

function getTbTopElement(opeParam, HDLparam, currentTbTopElement) {
    let TopElementList   = [];
    let tbTopElementList = [];
    TopElementList = getTopElement(HDLparam, currentTbTopElement);
    for (let i = 0; i < TopElementList.length; i++) {
        const element = TopElementList[i];
        let path = element.fspath.replace(opeParam.workspacePath,'');
        if (path.indexOf("sim") != -1) {
            tbTopElementList.push(element);
        }
    }
    return tbTopElementList;
}
exports.getTbTopElement = getTbTopElement;