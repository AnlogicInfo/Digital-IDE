"use strict";

const utils = require("./simParser");

// comment
var l_comment = new RegExp([
    /--.*/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var b_comment = new RegExp([
    /\*[\s\S]*?\*\//
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

/* vhdl parse */
// block
var vhdl_entity = new RegExp([
    /entity\s+(?<name>\w+)\s*is\s*/,
    /(generic\s*\((?<param>[\w\W]+)\))?\s*/,
    /port\s*\((?<port>[\w\W]+)\)\s*/,
    /(?<end>;)\s*/,
    /end entity;/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mgi');

// element
var vhdl_instantiation = new RegExp([
    /(?<name>\w+)/,
    /\s*:\s*/,
    /(?<type>\w+)/,
    /\s+/,
    /(generic\s+map\s*\(.*?\))?\s*/,
    /(port\s+map\s*\(.*?\))\s*/,
    /(?<end>;)/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mgi');
var vhdl_variable = new RegExp([
    /(?<name>\w+)/,
    /\s*:\s*/,
    /(?<type>integer|natural|postive|time)/,
    /\s*/,
    /(:=)?\s*/,
    /(?<init>\S+)?/,
    /\s*(\)|;)/
].map(x => x.source).join(''), 'mgi');
var vhdl_ports = new RegExp([
    /(?<name>\w+)/,
    /\s*:\s*/,
    /(?<type>in|out|inout|buffer)/,
    /\s+/,
    /(signed|unsigned|std_logic|std_logic_vector)\s*/,
    /(?<width>\([0-9]+\s+downto\s+[0-9]+\))?/,
    /\s*(\)|;)/
].map(x => x.source).join(''), 'mgi');

// others
var vhdl_decl_block = [
    vhdl_entity
];
var vhdl_decl_element = [
    vhdl_ports,
    vhdl_variable,
    vhdl_instantiation
];
var comment = [
    l_comment,
    b_comment
];

/**
     * Matches the regex pattern with the document's text. If a match is found, it creates a `HDLSymbol` object.
     * Add the objects to an empty list and return it.
     * 
     * @param document The document in which the command was invoked.
     * @param type     How much the parser will look for, must be "full", "declaration" or "fast"
     * @param offset   How many deep it will traverse the hierarchy
     * @param parent   How many deep it will traverse the hierarchy
     * @return A list of `HDLSymbol` objects or a thenable that resolves to such. The lack of a result can be
     * signaled by returning `undefined`, `null`, or an empty list.
*/
function getFileParam (document, type, offset = 0, parent, HDLparam, HDLSymbol) {
    let text = document.getText();
    let IllegalRange = getCommentRange(text,offset);
    text = delComments(text);

    if (HDLSymbol != undefined) {
        HDLSymbol.symbols = [];
    }
    // Find blocks
    while (1) {
        let match = vhdl_entity.exec(text);
        if (match == null) {
            break;
        }
        else if ( (match.index == 0 && parent != undefined) ||
            utils.isIllegalRange(match,IllegalRange,offset) ) {
            continue;
        }

        if (HDLSymbol != undefined) {
            let symbolInfo = HDLSymbol.setSymbolInformation(
                match, parent, document, offset);
            HDLSymbol.symbols.push(symbolInfo);
        }

        // IllegalRange = IllegalRange.concat(
        //     get_block(
        //         match[0], 
        //         document, 
        //         match.groups.name, 
        //         IllegalRange, 
        //         (match.index + offset),
        //         HDLSymbol));
        let HDLfileparam = {
            "moduleName" : "",
            "modulePath" : "",
            "instmodule" : [],
            "param"      : [],
            "port"       : {
                "inout"  : [],
                "input"  : [],
                "output" : []
            }  
        }
        if ( type == "symbol" ) {            
            HDLfileparam = null            
        }
        get_element(
            match[0], 
            document, 
            match.groups.name, 
            IllegalRange, 
            HDLfileparam, 
            (match.index + offset),
            HDLSymbol);
        if (type!="symbol") {
            HDLfileparam.moduleName = match.groups.name;
            HDLfileparam.modulePath = document.uri._fsPath.replace(/\\/g,"\/");            
            HDLparam.push(HDLfileparam); 
        }
    }

    if (HDLSymbol != undefined) {
        return HDLSymbol.symbols;
    } else {
        return undefined;
    }
}
exports.getFileParam = getFileParam;

/**
     * Matches a block in a file
     * 
     * @param  text         匹配的文本
     * @param  document     匹配文本所在的文档属性
     * @param  parent       根属性
     * @param  IllegalRange 非法区域，该区域内不匹配
     * @param  offset       匹配地址偏移(即匹配的文本在文件中的地址位置)
     * @param  HDLSymbol    符号类，对相关符号进行处理
*/
function get_block (text, document, parent, IllegalRange, offset, HDLSymbol) {
    let blockRange = [];
    if (!text) {
        text = document.getText();
    }
    for (let index = 0; index < vhdl_decl_block.length; index++) {
        const unitBlock = vhdl_decl_block[index];
        while (1) {
            let match = unitBlock.exec(text);
            if (match == null) {
                break;
            }
            else if ((match.index == 0 && parent == undefined) || 
                utils.isIllegalRange(match,IllegalRange,offset)) {
                continue;
            }

            if (HDLSymbol != undefined) {
                let symbolInfo = HDLSymbol.setSymbolInformation(
                    match, parent, document, offset);
                HDLSymbol.symbols.push(symbolInfo);
            }

            let Range = {
                "start"   : 0,
                "end"     : 0
            }
            Range.start = match.index + offset;
            Range.end   = match.index + match[0].length + offset;
            blockRange.push(Range);
            get_element(match[0], document, match.groups.name, IllegalRange, null, Range.start, HDLSymbol);
        }
    }
    return blockRange;
}

/**
     * Matches a single element in a file
     * 
     * @param  text         匹配的文本
     * @param  document     匹配文本所在的文档属性
     * @param  parent       根属性
     * @param  IllegalRange 非法区域，该区域内不匹配
     * @param  HDLfileparam HDL文件属性
     * @param  offset       匹配地址偏移(即匹配的文本在文件中的地址位置)
     * @param  HDLSymbol    符号类，对相关符号进行处理
*/
function get_element (text, document, parent, IllegalRange, HDLfileparam, offset, HDLSymbol) {
    if (!text) {
        text = document.getText();
    }
    for (let index = 0; index < vhdl_decl_element.length; index++) {
        var unitElement = vhdl_decl_element[index];
        while (1) {
            // 匹配每个元素
            let match = unitElement.exec(text);

            // 判断元素是否有效--是否为空 或者 是否在非法范围内
            if (match == null) {
                break;      // 即跳出此类型的匹配，执行下一类型
            }
            else if ((match.index == 0 && parent != undefined) || 
                utils.isIllegalRange(match,IllegalRange,offset)) {
                continue;   // 跳过匹配组中的一个
            }

            // 注册元素标志
            if (HDLSymbol != undefined) {
                if (unitElement == vhdl_ports) {
                    var nameList = match.groups.name.split(",");
                    for (let i = 0; i < nameList.length; i++) {
                        match.groups.name = nameList[i];
                        if (match.groups.name != '') {                                
                            match.groups.name = match.groups.name.replace(/(,|;)/,'');
                            let symbolInfo = HDLSymbol.setSymbolInformation(
                                match, parent, document, offset);
                            HDLSymbol.symbols.push(symbolInfo);
                        }
                    }
                } else {
                    let symbolInfo = HDLSymbol.setSymbolInformation(
                        match, parent, document, offset);
                    HDLSymbol.symbols.push(symbolInfo);
                }
            }
            
            // 获取端口参数信息（用于仿真，生成结构，生成仿真文件）
            if ( HDLfileparam != null ) {
                switch (unitElement) {
                    case vhdl_ports:
                        for (let i = 0; i < nameList.length; i++) {
                            const name = nameList[i];
                            let portProperty = {
                                "portName"  : "",
                                "portWidth" : ""
                            };
                            if (name != '') {                                
                                portProperty.portName = name.replace(/(,|;)/,'');
                                if (match.groups.width == null) {
                                    portProperty.portWidth = " ";
                                } else {
                                    portProperty.portWidth = match.groups.width;
                                }
                                switch (match.groups.type) {
                                    case "inout":
                                        HDLfileparam.port.inout.push(portProperty);
                                        break;
                                    case "in":
                                        HDLfileparam.port.input.push(portProperty);
                                        break;
                                    case "out":
                                        HDLfileparam.port.output.push(portProperty);
                                        break;
                                    default: break;
                                }
                            }
                        }
                        break;
                    case vhdl_variable:
                        if ( match.groups.type == "parameter" ) {
                            let parmProperty = {
                                "paramName"  : "",
                                "paramWidth" : "",
                                "paramInit"  : ""
                            }
                            parmProperty.paramName  = match.groups.name;
                            parmProperty.paramWidth = match.groups.width;
                            parmProperty.paramInit  = match.groups.init;
                            HDLfileparam.param.push(parmProperty);
                        }
                        break;
                    case vhdl_instantiation:
                        let instProperty = {
                            "instModule"  : "",
                            "instModPath" : "",
                            "instName"    : ""
                        };
                        instProperty.instModule = match.groups.type;
                        instProperty.instName   = match.groups.name;
                        HDLfileparam.instmodule.push(instProperty);
                        break;
                    default: break;
                }
            }
        }
    }
}

/**
     * 获取注释所在区间
     * 
     * @param  text         匹配的文本
     * @param  offset       匹配地址偏移(即匹配的文本在文件中的地址位置)
     * @return 返回注释所在区间的数组
*/
function getCommentRange (text, offset) {
    let commentRange = [];
    let regexes =  comment;
    for (let i = 0; i < regexes.length; i++) {
        while (1) {
            let match = regexes[i].exec(text);
            if (match == null) {
                break;
            }
            let Range = {
                "start"   : 0,
                "end"     : 0
            }
            Range.start = match.index + offset;
            Range.end = match.index + match[0].length + offset;
            commentRange.push(Range);
        }
    }
    return commentRange;
}

function delComments(content) {
    let match = content.match(b_comment);
    if (match != null) {
        for (let i = 0; i < match.length; i++) {
            const element = match[i];
            const newElement = element.replace(/\S/g,' ');
            content = content.replace(element,newElement);
        }
    }
    match = content.match(l_comment);
    if (match != null) {
        for (let i = 0; i < match.length; i++) {
            const element = match[i];
            const newElement = element.replace(/\S/g,' ');
            content = content.replace(element,newElement);
        }
    }
    return content;
}