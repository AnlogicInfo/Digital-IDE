"use strict";

const smcat = require("state-machine-cat");

class Parser_fsm_base {
    constructor() {
        super();
    }

    check_empty_states_transitions(states) {
        let check = true;
        for (let i = 0; i < states.length; ++i) {
            if (states[i].transitions.length !== 0) {
                check = false;
            }
        }
        return check;
    }

    check_stm(stm) {
        let check = false;
        let states = stm.states;
        for (let i = 0; i < states.length; ++i) {
            let transitions = states[i].transitions;
            if (transitions.length > 0) {
                return true;
            }
        }
        return check;
    }

    json_to_svg(fsm_json) {
        let stmcat = this.get_smcat(fsm_json);
        let svg;
        try {
            svg = smcat.render(stmcat, { outputType: "svg" });
        }
        // eslint-disable-next-line no-console
        catch (e) { console.log(e); }
        return svg;
    }

    get_smcat(fsm_json) {
        let fsm_states = '';
        let fsm_transitions = '';

        let states = fsm_json.states;
        let state_names = [];
        for (let i = 0; i < states.length; ++i) {
            if (states[i].transitions.length === 0) {
                state_names.push(states[i].name);
            }
        }
        let emptys = [];
        for (let i = 0; i < state_names.length; ++i) {
            let empty = true;
            for (let j = 0; j < states.length; ++j) {
                for (let m = 0; m < states[j].transitions.length; ++m) {
                    if (states[j].transitions[m].destination === state_names[i]) {
                        empty = false;
                    }
                }
            }
            if (empty === true) {
                emptys.push(state_names[i]);
            }
        }

        let gosth = [];
        state_names = [];
        for (let i = 0; i < states.length; ++i) {
            state_names.push(states[i].name);
        }
        for (let j = 0; j < states.length; ++j) {
            for (let m = 0; m < states[j].transitions.length; ++m) {
                if (state_names.includes(states[j].transitions[m].destination) === false) {
                    let element = { 'name': states[j].transitions[m].destination, 'transitions': [] };
                    fsm_json.states.push(element);
                    gosth.push(states[j].transitions[m].destination);
                }
            }
        }
        let num_states = fsm_json.states.length;
        fsm_json.states.forEach(function (i_state, i) {
            let transitions = i_state.transitions;
            let state_name = i_state.name;
            if (emptys.includes(state_name) === true || gosth.includes(state_name) === true) {
                fsm_states += `${state_name} [color="red"]`;
            }
            else {
                fsm_states += `${state_name}`;
            }
            if (i !== num_states - 1) {
                fsm_states += ',';
            }
            else {
                fsm_states += ';\n';
            }
            if (gosth.includes(state_name) !== true) {
                transitions.forEach(function (i_transition, j) {
                    if (gosth.includes(i_transition.destination) === true) {
                        fsm_transitions +=
                            `${state_name} => ${i_transition.destination} [color="red"] : ${i_transition.condition};\n`;
                    }
                    else {
                        fsm_transitions += `${state_name} => ${i_transition.destination} : ${i_transition.condition};\n`;
                    }
                });
            }
        });
        let str_stm = fsm_json.state_variable_name + "{\n" + fsm_states + fsm_transitions + "\n};";
        return str_stm;
    }

    only_unique(value, index, self) {
        return self.indexOf(value) === index;
    }

    get_balance_index(items, startItems, lastItems) {
        if (lastItems.length == 0) {
            return items;
        }
        let times = 0;
        let limitLen = lastItems.length + startItems.length;
        while (lastItems.length && startItems.length) {
            for (let i = 0; i < startItems.length; i++) {
                const startIndexElement = startItems[i].lastIndex;
                // ()() 成对相连的情况 (优先解决从而避免最后一个被包含的问题)
                if (startIndexElement > lastItems[0]) {
                    if (i>=1) {
                        if (i>=2) {
                            startItems[i-1].parent = startItems[i-2].name;
                        }
                        startItems[i-1].lastIndex = lastItems[0];
                        items.push(startItems[i-1]);
                        startItems.splice(i-1,1);
                    }
                    // 如果i为0则第一个右侧无法匹配 解决右侧多余匹配情况
                    lastItems.splice(0,1);
                    break;
                }
                // ((())) 成对嵌套情况 (包括优先解决单个成对情况)
                if (i == startItems.length-1) {
                    if (i>=1) {
                        startItems[i].parent = startItems[i-1].name;
                    }
                    // 解决左侧多余匹配情况
                    if (lastItems.length) {
                        startItems[i].lastIndex = lastItems[0];
                    } else {
                        return items;
                    }
                    items.push(startItems[i]);
                    startItems.splice(i,1);
                    lastItems.splice(0,1);
                    break;
                }
            }
            // 强制退出的保险机制
            times++;
            if (times > limitLen) {
                return items;
            }
        }
        return items;
    }
}
exports.Parser_fsm_base = Parser_fsm_base;