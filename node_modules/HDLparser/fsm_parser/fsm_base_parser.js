"use strict";

const smcat = require("HDLparser/fsm_parser/state-machine-cat");

class Parser_fsm_base extends base_parser.base_parser {
    constructor() {
        super();
    }

    check_empty_states_transitions(states) {
        let check = true;
        for (let i = 0; i < states.length; ++i) {
            if (states[i].transitions.length !== 0) {
                check = false;
            }
        }
        return check;
    }

    check_stm(stm) {
        let check = false;
        let states = stm.states;
        for (let i = 0; i < states.length; ++i) {
            let transitions = states[i].transitions;
            if (transitions.length > 0) {
                return true;
            }
        }
        return check;
    }

    json_to_svg(fsm_json) {
        let stmcat = this.get_smcat(fsm_json);
        let svg;
        try {
            svg = smcat.render(stmcat, { outputType: "svg" });
        }
        // eslint-disable-next-line no-console
        catch (e) { console.log(e); }
        return svg;
    }

    get_smcat(fsm_json) {
        let fsm_states = '';
        let fsm_transitions = '';

        let states = fsm_json.states;
        let state_names = [];
        for (let i = 0; i < states.length; ++i) {
            if (states[i].transitions.length === 0) {
                state_names.push(states[i].name);
            }
        }
        let emptys = [];
        for (let i = 0; i < state_names.length; ++i) {
            let empty = true;
            for (let j = 0; j < states.length; ++j) {
                for (let m = 0; m < states[j].transitions.length; ++m) {
                    if (states[j].transitions[m].destination === state_names[i]) {
                        empty = false;
                    }
                }
            }
            if (empty === true) {
                emptys.push(state_names[i]);
            }
        }

        let gosth = [];
        state_names = [];
        for (let i = 0; i < states.length; ++i) {
            state_names.push(states[i].name);
        }
        for (let j = 0; j < states.length; ++j) {
            for (let m = 0; m < states[j].transitions.length; ++m) {
                if (state_names.includes(states[j].transitions[m].destination) === false) {
                    let element = { 'name': states[j].transitions[m].destination, 'transitions': [] };
                    fsm_json.states.push(element);
                    gosth.push(states[j].transitions[m].destination);
                }
            }
        }
        let num_states = fsm_json.states.length;
        fsm_json.states.forEach(function (i_state, i) {
            let transitions = i_state.transitions;
            let state_name = i_state.name;
            if (emptys.includes(state_name) === true || gosth.includes(state_name) === true) {
                fsm_states += `${state_name} [color="red"]`;
            }
            else {
                fsm_states += `${state_name}`;
            }
            if (i !== num_states - 1) {
                fsm_states += ',';
            }
            else {
                fsm_states += ';\n';
            }
            if (gosth.includes(state_name) !== true) {
                transitions.forEach(function (i_transition, j) {
                    if (gosth.includes(i_transition.destination) === true) {
                        fsm_transitions +=
                            `${state_name} => ${i_transition.destination} [color="red"] : ${i_transition.condition};\n`;
                    }
                    else {
                        fsm_transitions += `${state_name} => ${i_transition.destination} : ${i_transition.condition};\n`;
                    }
                });
            }
        });
        let str_stm = fsm_json.state_variable_name + "{\n" + fsm_states + fsm_transitions + "\n};";
        return str_stm;
    }

    only_unique(value, index, self) {
        return self.indexOf(value) === index;
    }

}

module.exports = {
    Parser_fsm_base: Parser_fsm_base
};