"use strict";

const fsm_base = require('./fsm_base');

var vlog_case_begin = new RegExp([
    /(?<=\s)/,
    /case\s*/,
    /\(\s*(?<name>\w*?)\s*\)/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_case_end = new RegExp([
    /(?<=\s)/,
    /endcase\s/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_state = new RegExp([
    /(?<=\s)/,
    /(?<state>\w*?)\s*?:\s*?/,
    /(?<content>[\w\W]*?)/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

class Paser_fsm_vlog extends fsm_base.Parser_fsm_base {
    constructor() {
        super();
    }
    
    get_svg_sm(code) {
        let process;
        // 获取处理语句块
        let process = [{
            'code': this.get_deep_process(cursor.currentNode()),
            'comments': comments
        }];
        let stm = [];
        let svg = [];
        for (let i = 0; i < process.length; ++i) {
            let states;
            try {
                // 获取处理块的信息得到状态
                states = this.get_process_info(process[i]);
            }
            catch (e) {
                states = undefined;
            }
            if (states !== undefined) {
                for (let j = 0; j < states.length; ++j) {
                    if (this.check_stm(states[j]) === true) {
                        stm.push(states[j]);
                        let svg_tmp = this.json_to_svg(states[j]);
                        let fsm_tmp = {
                            'svg': svg_tmp,
                            'description': states[j].description
                        };
                        svg.push(fsm_tmp);
                    }
                }
            }
        }
        return { 'svg': svg, 'stm': stm };
    }

    get_case(content) {
        let items = [];
        let startItems = [];
        let lastItems  = [];
        while (1) {
            let match = vlog_case_begin.exec(content);
            if (match == null) {
                break;      
            }
            let item = {
                "name": match.groups.name,
                "parent": null,
                "startIndex": match.index,
                "lastIndex" : match.index + match[0].length,
            };
            startItems.push(item);
        }
        if (startItems.length == 0) {
            return items;
        }
        while (1) {
            let match = vlog_case_end.exec(content);
            if (match == null) {
                break;      
            }
            lastItems.push(match.index + match[0].length);
        }
        this.get_balance_index(items, startItems, lastItems);
        for (let index = 0; index < items.length; index++) {
            const itemsElement = items[index];
            if (itemsElement.parent == null) {
                let state_text = content.substring(itemsElement.startIndex, itemsElement.lastIndex);
            }
        }
        return items;
    }

    get_state(content) {
        let items = [];
        while (1) {
            let match = vlog_state.exec(content);
            if (match == null) {
                break;      
            }
            let item = {
                "name": match.groups.name,
                "parent": null,
                "startIndex": match.index,
                "lastIndex" : match.index + match[0].length,
            };
            items.push(item);
        }
        return items;
    }

    get_balance_index(items, startItems, lastItems) {
        if (lastItems.length == 0) {
            return items;
        }
        let times = 0;
        let limitLen = lastItems.length + startItems.length;
        while (lastItems.length && startItems.length) {
            for (let i = 0; i < startItems.length; i++) {
                const startIndexElement = startItems[i].lastIndex;
                // ((())) 成对嵌套情况 (包括优先解决单个成对情况)
                if (i == startItems.length-1) {
                    if (i>=1) {
                        startItems[i].parent = startItems[i-1].name;
                    }
                    // 解决左侧多余匹配情况
                    if (lastItems.length) {
                        startItems[i].lastIndex = lastItems[0];
                    } else {
                        return items;
                    }
                    items.push(startItems[i]);
                    startItems.splice(i,1);
                    lastItems.splice(0,1);
                    break;
                }
                // ()() 成对相连的情况
                if (startIndexElement > lastItems[0]) {
                    if (i>=1) {
                        if (i>=2) {
                            startItems[i-1].parent = startItems[i-2].name;
                        }
                        startItems[i-1].lastIndex = lastItems[0];
                        items.push(startItems[i-1]);
                        startItems.splice(i-1,1);
                    }
                    // 如果i为0则第一个右侧无法匹配 解决右侧多余匹配情况
                    lastItems.splice(0,1);
                    break;
                }
            }
            // 强制退出的保险机制
            times++;
            if (times > limitLen) {
                return items;
            }
        }
        return items;
    }
}

exports.Paser_fsm_vlog = Paser_fsm_vlog;
