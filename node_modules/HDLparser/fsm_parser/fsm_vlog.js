"use strict";

const fsm_base = require('./fsm_base');

var vlog_case_begin = new RegExp([
    /(?<!\w)/,
    /case\s*?/,
    /\(\s*(?<name>\w*?)\s*\)/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_case_end = new RegExp([
    /(?<!\w)/,
    /endcase\s/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_state = new RegExp([
    /(?<!\w)/,
    /(?<state>\w*?)\s*?:\s*?/,
    /(?<content>[\w\W]*?)/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

class Paser_fsm_vlog extends fsm_base.Parser_fsm_base {
    constructor() {
        super();
    }
    
    get_svg_sm(code) {
        let process;
        // 获取处理语句块
        let process = [{
            'code': this.get_deep_process(cursor.currentNode()),
            'comments': comments
        }];
        let stm = [];
        let svg = [];
        for (let i = 0; i < process.length; ++i) {
            let states;
            try {
                // 获取处理块的信息得到状态
                states = this.get_process_info(process[i]);
            }
            catch (e) {
                states = undefined;
            }
            if (states !== undefined) {
                for (let j = 0; j < states.length; ++j) {
                    if (this.check_stm(states[j]) === true) {
                        stm.push(states[j]);
                        let svg_tmp = this.json_to_svg(states[j]);
                        let fsm_tmp = {
                            'svg': svg_tmp,
                            'description': states[j].description
                        };
                        svg.push(fsm_tmp);
                    }
                }
            }
        }
        return { 'svg': svg, 'stm': stm };
    }

    get_case(content) {
        let items = [];
        let startItems = [];
        let lastItems  = [];
        while (1) {
            let match = vlog_case_begin.exec(content);
            if (match == null) {
                break;      
            }
            let item = {
                "name": match.groups.name,
                "parent": null,
                "startIndex": match.index,
                "lastIndex" : match.index + match[0].length,
            };
            startItems.push(item);
        }
        if (startItems.length == 0) {
            return items;
        }
        while (1) {
            let match = vlog_case_end.exec(content);
            if (match == null) {
                break;      
            }
            lastItems.push(match.index + match[0].length);
        }
        this.get_balance_index(items, startItems, lastItems);
        for (let index = 0; index < items.length; index++) {
            const itemsElement = items[index];
            if (itemsElement.parent == null) {
                let state_text = content.substring(itemsElement.startIndex, itemsElement.lastIndex);
            }
        }
        return items;
    }

    get_state(content) {
        let items = [];
        while (1) {
            let match = vlog_state.exec(content);
            if (match == null) {
                break;      
            }
            let item = {
                "name": match.groups.name,
                "parent": null,
                "startIndex": match.index,
                "lastIndex" : match.index + match[0].length,
            };
            items.push(item);
        }
        return items;
    }
}

exports.Paser_fsm_vlog = Paser_fsm_vlog;
