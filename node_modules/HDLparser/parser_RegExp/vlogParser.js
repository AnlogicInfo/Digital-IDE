"use strict";

// comment
var l_comment = new RegExp([
    /\/\/.*/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var b_comment = new RegExp([
    /\/\*[\s\S]*?\*\//
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var comment = [
    l_comment,
    b_comment
]
/* vlog parse */
/////////////////////////block RegExp////////////////////////////////////
var vlog_modules = new RegExp([
    /module\s+/,
    /(?:automatic\s+)?/,
    /(?<name>\w+)/,
    /(?:\s*#\s*\([\w\W]*?\))?/, // <params>
    /(?:\s*\([\W\w]*?\))?/,     // <ports>
    /\s*;/,
    /(?:[\W\w]*?)/,             // <body>
    /endmodule/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_classes = new RegExp([
    /(?<type>class)\s+/,
    /(?<name>\w+)/,
    /(\s+(extends|implements)\s+[\w\W]+?|\s*#\s*\([\w\W]+?\))*?/,
    /\s*;/,
    /(?<body>[\w\W]*?)/,
    /endclass/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_methods = new RegExp([
    /(?<type>(function|task))\s+/,
    /((?<return>\[.+?\])\s+)?/,
    /\b(?<name>\w+)\b\s*/,
    /(?<ports>\([\W\w]*?\))?/,
    /\s*;/,
    /(?<body>[\w\W]*?)/,
    /(?:end(?:function|task))/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_generate_begin = new RegExp([
    /generate\s*/,
    /(?<type>if|for)\s*/,
    /\([\w\W]*?\)\s*/,
    /(begin\s*:\s*(?<name>\w+))?/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_generate_end = new RegExp([
    /endgenerate/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

/////////////////////////element RegExp////////////////////////////////////
var vlog_asserts = new RegExp([
    /(?<=^\s*(?<name>\w+)\s*:\s*)/,
    /(?<type>assert\b)/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_ports = new RegExp([
    /(?<type>input|output|inout)/,
    /(?:\s+\w+)*\s*/,
    /(?<width>\[.+?\])?\s*/,
    /(?<name>(?<=\W)(?:\w+(?:\s*=\s*(?<init>.+))?(?:,\s*)?)+(?=\W))/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_singals = new RegExp([
    /(?<!(input|output|inout)\s*)/,
    /(?<type>reg|wire|logic)/,
    /(?:\s+\w+)*\s*/,
    /(?<width>\[.+?\])?\s*/,
    /(?<name>(?<=\W)(?:\w+(?:\s*=\s*(?<init>.+))?(?:,\s*)?)+(?=\W))/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_processes = new RegExp([
    /(?<type>always|always_ff|always_comb)/,
    /(\s*@\s*(?<event>\([\w\W]*?\)))?\s*/,
    /(begin\s*:\s*(?<name>\w+))?/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_label_begin = new RegExp([
    /begin(\s*:\s*(?<name>\w+))?/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_label_end = new RegExp([
    /end\s/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_instances = new RegExp([
    // /(?:(?<modifier>virtual|static|automatic|rand|randc|pure virtual)\s+)?/,
    /\b(?<type>[:\w]+)\s*/,
    /(?<params>#\s*\(\s*\.[\w\W]*?\))?\s*/,
    /\b(?<name>\w+)?\s*/,
    /(?<ports>\(\s*\.[\w\W]*?\))\s*;/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_constants = new RegExp([
    /(?<type>localparam|bit|int|char|float|integer)/,
    /(?:\s+\w+)*\s*/,
    /(?<width>\[.+?\])?\s*/,
    /(?<name>(?<=\W)(?:\w+(?:\s*=\s*(?<init>.+))?(?:,\s*)?)+(?=\W))/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_parameter = new RegExp([
    /parameter/,
    /(?:\s+\w+)*\s*/,
    /(?<width>\[.+?\])?\s*/,
    /(?<name>(?<=\W)(?:\w+(?:\s*=\s*(?<init>.+))?(?:,\s*)?)+(?=\W))/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

/////////////////////////macro define RegExp////////////////////////////////////
var vlog_typedef = new RegExp([
    /(?<=^\s*)/,
    /(?<type>typedef)\s+/,
    /(?<body>[^;]*)/,
    /(?<name>\b\w+)/,
    /\s*(\[[^;]*?\])*?/,
    /\s*(?<end>;)/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_define = new RegExp([
    /(?<=^\s*)/,
    /`(?<type>define)\s+/,
    /(?<name>\w+)\b/,
    /((?<ports>\([^\n]*\))|\s*?)/,
    /(?<body>([^\n]*\\\n)*([^\n]*))/,
    /(?<!\\)(?=\n)/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

/////////////////////////API////////////////////////////////////
function getFileParam(document, HDLSymbol, HDLparam) {
    try {
        HDLSymbol.symbols = [];
        let text = document.getText();
        text = delComments(text);
        get_modules(text, document, null, HDLparam, HDLSymbol);
        return HDLSymbol.symbols;
    }
    catch (error) {
        console.log(error);
        return null;
    }
}
exports.getFileParam = getFileParam;

/////////////////////////block api////////////////////////////////////
function get_modules(text, document, parent, HDLparam, HDLSymbol) {
    while (1) {
        let match = vlog_modules.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : match.groups.name,
            'type' : "module",
            "startIndex": match.index,
            "lastIndex" : match.index + match[0].length,
        };
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        let content = {"text" : match[0]};
        // get blocks
        get_generates(content, document, item.name, item.startIndex, HDLSymbol);
        get_methods(content, document, item.name, item.startIndex, HDLSymbol);
        
        // get elements
        let structure = get_element(content.text, document, item.name, match.index, HDLSymbol);
        structure.startIndex = item.startIndex;
        structure.lastIndex  = item.lastIndex;
        if (HDLparam != null) {
            HDLparam.push(structure);
        }
        // let oldContent = generate_text;
        // let newContent = generate_text.replace(strRegExp, ' ');
        // content.text = content.text.replace(oldContent,newContent);
    }
}
exports.get_modules = get_modules;

//--------classes block--------//
function get_classes(content, document, parent, offset, HDLSymbol) {
    let items = [];
    let strRegExp = /\S+/g;
    while (1) {
        let match = vlog_classes.exec(content.text);
        if (match == null) {
            break;      
        }
        let item = {
            "name": match.groups.name,
            "type": "generate",
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        // get blocks
        get_methods(match[0], document, item.name, item.startIndex, HDLSymbol);

        // get elements
        get_element(match[0], document, item.name, item.startIndex, HDLSymbol);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        let oldContent = match[0];
        let newContent = match[0].replace(strRegExp, ' ');
        content.text = content.text.replace(oldContent,newContent);
    }
    return items;
}
exports.get_classes = get_classes;

//--------generate block--------//
function get_generates(content, document, parent, offset, HDLSymbol) {
    let items = [];
    let startItems = [];
    let lastItems  = [];
    while (1) {
        let match = vlog_generate_begin.exec(content.text);
        if (match == null) {
            break;      
        }
        if (match.groups.name == null) {
            match.groups.name = "generate-(no name)";
        }
        let item = {
            "name": match.groups.name,
            "type": "generate",
            "parent": parent,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        startItems.push(item);
    }
    while (1) {
        let match = vlog_generate_end.exec(content.text);
        if (match == null) {
            break;      
        }
        lastItems.push(match.index + match[0].length + offset);
    }
    if (lastItems.length == 0) {
        return items;
    }
    get_generates_index(items, startItems, lastItems);
    for (let index = 0; index < items.length; index++) {
        const itemsElement = items[index];
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(itemsElement, itemsElement.parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        let generate_text = content.text.substring(itemsElement.startIndex-offset, itemsElement.lastIndex-offset);
        // get blocks
        get_methods(generate_text, document, itemsElement.name, itemsElement.startIndex, HDLSymbol);
    
        // get elements
        get_element(generate_text, document, itemsElement.name, itemsElement.startIndex, HDLSymbol);
        
        let oldContent = generate_text;
        let newContent = ' '.repeat(generate_text.length);
        content.text = content.text.replace(oldContent,newContent);
    }
    return items;
}
exports.get_generates = get_generates;

function get_generates_index(items, startItems, lastItems) {
    if (startItems.length == 0) {
        return items;
    }
    while (lastItems.length) {
        for (let i = 0; i < startItems.length; i++) {
            const startIndexElement = startItems[i].lastIndex;
            if ((startIndexElement > lastItems[0]) || (1 == startItems.length)) {
                let index = (i == 0) ? 0 : i-1;
                startItems[index].lastIndex = lastItems[0];
                if (index-1 >= 0) {
                    startItems[index].parent = startItems[index-1].name;
                }
                items.push(startItems[index]);
                startItems.splice(index,1);
                lastItems.splice(0,1);
                break;
            }
        }
    }
    return items;
}

//--------method block--------//
function get_methods(content, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vlog_methods.exec(content.text);
        if (match == null) {
            break;      
        }
        let item = {
            "name": match.groups.name,
            "type": match.groups.type,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        get_ports(match[0], document, item.name, item.startIndex, HDLSymbol);
        get_signals(match[0], document, item.name, item.startIndex, HDLSymbol);
        let oldContent = match[0];
        let newContent = ' '.repeat(match[0].length);
        content.text = content.text.replace(oldContent,newContent);
    }
    return items;
}
exports.get_methods = get_methods;

/////////////////////////element api////////////////////////////////////
//--------get element--------//
function get_element(text, document, parent, offset, HDLSymbol) {
    let ports     = get_ports(text, document, parent, offset, HDLSymbol);
    let signals   = get_signals(text, document, parent, offset, HDLSymbol);
    let asserts   = get_asserts(text, document, parent, offset, HDLSymbol);
    let parameter = get_parameter(text, document, parent, offset, HDLSymbol);
    let instances = get_instances(text, document, parent, offset, HDLSymbol);
    let constants = get_constants(text, document, parent, offset, HDLSymbol);
    let processes = get_processes(text, document, parent, offset, HDLSymbol);

    let structure = {};
    structure = {
        "moduleName": parent, // module
        "modulePath": document.fileName.replace(/\\/g, "\/"),
        "ports"     : ports,
        "signals"   : signals,
        "asserts"   : asserts,
        "parameter" : parameter,
        "instances" : instances,
        "constants" : constants,
        "processes" : processes,
        "startIndex": 0,
        "lastIndex" : 0,
    };
    return structure;
}
exports.get_element = get_element;

//--------always process element--------//
function get_processes(text, document, parent, offset, HDLSymbol) {
    let items = [];
    let blankRegExp = /\s/g;
    while (1) {
        let match = vlog_processes.exec(text);
        if (match == null) {
            break;      
        }
        let processName = match.groups.name;
        if (processName == null) {
            if (match.groups.event == null) {
                processName = match.groups.type + "-Unconditional";
            } else {
                processName = match.groups.type + "-" + match.groups.event.replace(blankRegExp, ' ');
            }
        } else {
            if (match.groups.event == null) {
                processName = processName + ":" + "Unconditional";
            } else {
                processName = processName + ":" + match.groups.event.replace(blankRegExp, ' ');
            }
        }
        let item = {
            "name": processName,
            "type": "always",
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
    }
    return items;
}
exports.get_processes = get_processes;

//--------instantiation element--------//
function get_instances(text, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vlog_instances.exec(text);
        if (match == null) {
            break;      
        }
        let paramsContent = (match[2]) == undefined ? '' : match[2];
        let portsContent  = (match[4]) == undefined ? '' : match[4];
        let paramsIndexStart = match.index + offset + match[0].indexOf(paramsContent);
        let paramsIndexEnd   = paramsIndexStart + paramsContent.length;
        let portsIndexStart  = match.index + offset + match[0].indexOf(portsContent);
        let portsIndexEnd    = portsIndexStart  + portsContent.length;
        let item = {
            "name": match.groups.name,
            "type": "instance",
            "instparams": {
                "startIndex": paramsIndexStart,
                "lastIndex" : paramsIndexEnd,
            },
            "instports" : {
                "startIndex": portsIndexStart,
                "lastIndex" : portsIndexEnd,
            },
            "instName": match.groups.name,   // name
            "instModule": match.groups.type, // type
            "instModPath": "",
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
    }
    return items;
}
exports.get_instances = get_instances;

//--------ports element--------//
function get_ports(text, document, parent, offset, HDLSymbol) {
    let items = [];
    let initRegExp = /\s*=\s*(.+)/;
    while (1) {
        let match = vlog_ports.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : "",
            'type' : match.groups.type,
            "portName" : "",
            "portWidth": match.groups.width,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        var nameList = match.groups.name.split(",");
        for (let i = 0; i < nameList.length; i++) {
            if (nameList[i] != '') {                                
                item.name = nameList[i].replace(initRegExp,'');
                item.name = item.name.replace(/\s*/g,'');
                item.portName = item.name;
                items.push(item);
                if (HDLSymbol != null) {
                    let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                    HDLSymbol.symbols.push(symbolInfo);
                }
            }
        }
    }
    return items;
}
exports.get_ports = get_ports;

//--------signal element--------//
function get_signals(text, document, parent, offset, HDLSymbol) {
    let items = [];
    let initRegExp = /\s*=\s*(.+)/;
    while (1) {
        let match = vlog_singals.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : "",
            'type' : match.groups.type,
            'range': match.groups.width,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        var nameList = match.groups.name.split(",");
        for (let i = 0; i < nameList.length; i++) {
            if (nameList[i] != '') {                                
                item.name = nameList[i].replace(initRegExp,'');
                items.push(item);
                if (HDLSymbol != null) {
                    let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                    HDLSymbol.symbols.push(symbolInfo);
                }
            }
        }
    }
    return items;
}
exports.get_signals = get_signals;

//--------param element--------//
function get_parameter(text, document, parent, offset, HDLSymbol) {
    let items = [];
    let initRegExp = /\s*=\s*(.+)/;
    let equRegExp  = /\s*=\s*/;
    let endRexExp  = /\s*(,|;)?/;
    while (1) {
        let match = vlog_parameter.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : "",
            'type' : "parameter",
            "paramName"  : "",
            "paramWidth" : match.groups.width,
            "paramInit"  : "",
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        var nameList = match.groups.name.split(",");
        for (let i = 0; i < nameList.length; i++) {
            if (nameList[i] != '') {                                
                item.name = nameList[i].replace(initRegExp,'');
                item.paramName = item.name;
                item.paramInit = nameList[i].replace(item.name,'');
                item.paramInit = item.paramInit.replace(equRegExp,'');
                item.paramInit = item.paramInit.replace(endRexExp,'');
                items.push(item);
                if (HDLSymbol != null) {
                    let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                    HDLSymbol.symbols.push(symbolInfo);
                }
            }
        }
    }
    return items;
}
exports.get_parameter = get_parameter;

//--------constant element--------//
function get_constants(text, document, parent, offset, HDLSymbol) {
    let items = [];
    let initRegExp = /\s*=\s*(.+)(,|;)/;
    while (1) {
        let match = vlog_constants.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : "",
            'type' : match.groups.type,
            'range': match.groups.width,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        var nameList = match.groups.name.split(",");
        for (let i = 0; i < nameList.length; i++) {
            if (nameList[i] != '') {                                
                item.name = nameList[i].replace(initRegExp,'');
                items.push(item);
                if (HDLSymbol != null) {
                    let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                    HDLSymbol.symbols.push(symbolInfo);
                }
            }
        }
    }
    return items;
}
exports.get_constants = get_constants;

//--------signal element--------//
function get_asserts(text, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vlog_asserts.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : match.groups.name,
            'type' : match.groups.type,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
    }
    return items;
}
exports.get_asserts = get_asserts;

/////////////////////////util api////////////////////////////////////
function delComments(content) {
    let match = content.match(b_comment);
    if (match != null) {
        for (let i = 0; i < match.length; i++) {
            const element = match[i];
            const newElement = ' '.repeat(element.length);
            content = content.replace(element,newElement);
        }
    }
    match = content.match(l_comment);
    if (match != null) {
        for (let i = 0; i < match.length; i++) {
            const element = match[i];
            const newElement = ' '.repeat(element.length);
            content = content.replace(element,newElement);
        }
    }
    return content;
}
exports.delComments = delComments;

/**
     * 获取注释所在区间
     * 
     * @param  text         匹配的文本
     * @param  offset       匹配地址偏移(即匹配的文本在文件中的地址位置)
     * @return 返回注释所在区间的数组
*/
function getCommentRange (text, offset) {
    let commentRange = [];
    let regexes =  comment;
    for (let i = 0; i < regexes.length; i++) {
        while (1) {
            let match = regexes[i].exec(text);
            if (match == null) {
                break;
            }
            let Range = {
                "start"   : 0,
                "end"     : 0
            }
            Range.start = match.index + offset;
            Range.end = match.index + match[0].length + offset;
            commentRange.push(Range);
        }
    }
    return commentRange;
}
exports.getCommentRange = getCommentRange;