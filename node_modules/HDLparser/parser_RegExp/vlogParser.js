"use strict";

const utils = require("../utils/utils");
// comment
var l_comment = new RegExp([
    /\/\/.*/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var b_comment = new RegExp([
    /\/\*[\s\S]*?\*\//
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

/* vlog parse */
// block
var vlog_block = new RegExp([
    "(?<=^\\s*",
    /(?<type>module|program|interface|package|primitive|config|property)\s+/,
    /(?:automatic\s+)?/,
    ")",
    /(?<name>\w+)/,
    /(?<params>\s*#\s*\([\w\W]*?\))?/,
    /(?<ports>\s*\([\W\w]*?\))?/,
    /\s*;/,
    /(?<body>[\W\w]*?)/,
    /(?<end>end\1)/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var vlog_class = new RegExp([
    "(?<=^\\s*(virtual\\s+)?",
    /(?<type>class)\s+/,
    ")",
    /(?<name>\w+)/,
    /(\s+(extends|implements)\s+[\w\W]+?|\s*#\s*\([\w\W]+?\))*?/,
    /\s*;/,
    /(?<body>[\w\W]*?)/,
    /(?<end>endclass)/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var vlog_method = new RegExp([
    "(?<=^\\s*(virtual|local|extern|pure\\s+virtual)?\\s*",
    /(?<type>(function|task))\s+/,
    /((?<return>\[.+?\])\s+)?/,
    ")",
    /\b(?<name>[\w\.]+)\b\s*/,
    /(?<ports>\([\W\w]*?\))?/,
    /\s*;/,
    /(?<body>[\w\W]*?)/,
    /(?<end>end(function|task))/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var vlog_label = new RegExp([
    /\b(?<type>begin)\b/,
    /\s*:\s*/,
    /(?<name>\w+)\s*(?:\/\/.*)?$/,
    // Matches up to 5 nested begin/ends
    // This is the only way to do it with RegExp without balancing groups
    /(?<body>(?:\bbegin\b(?:\bbegin\b(?:\bbegin\b(?:\bbegin\b(?:\bbegin\b[\w\W]+?\bend\b|[\w\W])+?\bend\b|[\w\W])+?\bend\b|[\w\W])+?\bend\b|[\w\W])+?\bend\b|[\w\W])+?)/,
    /\bend\b(\s*:\s*\1)?/
].map(x => x.source).join(''), 'mg');

// element
var vlog_assert = new RegExp([
    /(?<=^\s*(?<name>\w+)\s*:\s*)/,
    /(?<type>assert\b)/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var vlog_instantiation = new RegExp([
    /(?:(?<modifier>virtual|static|automatic|rand|randc|pure virtual)\s+)?/,
    /\b(?<type>[:\w]+)\s*/,
    /(?<params>#\s*\(\s*\.[\w\W]*?\))?\s*/,
    /(\b\w+\s*,\s*)*?/,
    /\b(?<name>\w+)?\s*/,
    /(?:(\(\s*\.[\w\W]*?\)))\s*/,
    /\s*(?<end>;)/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var vlog_variable = new RegExp([
    /(?<!(input|output|inout)\s*)/,
    /(?<type>parameter|localparam|reg|wire|bit|int|char|float|integer)\s*/,
    /((?<!\w)(signed|unsigned))?\s*/,
    /(?<width>\[.+?\])?\s*/,
    /(?<!parameter|localparam|reg|wire|bit|int|char|float|integer|signed|unsigned)/,
    /(?<name>(\w+(,|;)?)+)\s*/,
    /(?<depth>\[.+?\]\s)?\s*/,
    /(=\s*(?<init>.+))?\s*/,
    /(,|\)|;)/
].map(x => x.source).join(''), 'mgi');
var vlog_ports = new RegExp([
    /(?<type>input|output|inout)\s*/,
    /((?<!\w)(wire|reg|logic))?\s*/,
    /((?<!\w)(signed|unsigned))?\s*/,
    /(?<width>\[.+?\])?\s*/,
    /(?<!input|output|inout|wire|reg|logic|signed|unsigned)/,
    /(?<name>(\w+(,|;)?)+)\s*/,
    /(=\s*([0-9]+('?)(b|d|x))?\w+)?\s*/,
    /(,|\)|;)/
].map(x => x.source).join(''), 'mgi');
var vlog_typedef = new RegExp([
    /(?<=^\s*)/,
    /(?<type>typedef)\s+/,
    /(?<body>[^;]*)/,
    /(?<name>\b\w+)/,
    /\s*(\[[^;]*?\])*?/,
    /\s*(?<end>;)/
].map(x => x.source).join(''), 'mg');
var vlog_define = new RegExp([
    /(?<=^\s*)/,
    /`(?<type>define)\s+/,
    /(?<name>\w+)\b/,
    /((?<ports>\([^\n]*\))|\s*?)/,
    /(?<body>([^\n]*\\\n)*([^\n]*))/,
    /(?<!\\)(?=\n)/
].map(x => x.source).join(''), 'mg');

// others
var vlog_decl_block = [
    vlog_class,
    vlog_method,
    vlog_label
];
var vlog_decl_element = [
    vlog_ports,
    vlog_variable,
    vlog_instantiation,
    vlog_assert,
    vlog_typedef,
    vlog_define
];
var comment = [
    l_comment,
    b_comment
];

const ParserLib = require("../utils/factory");
/**
     * Matches the regex pattern with the document's text. If a match is found, it creates a `HDLSymbol` object.
     * Add the objects to an empty list and return it.
     * 
     * @param document The document in which the command was invoked.
     * @param type     How much the parser will look for, must be "full", "declaration" or "fast"
     * @param offset   How many deep it will traverse the hierarchy
     * @param parent   How many deep it will traverse the hierarchy
     * @return A list of `HDLSymbol` objects or a thenable that resolves to such. The lack of a result can be
     * signaled by returning `undefined`, `null`, or an empty list.
*/
function getFileParam (document, type, offset = 0, parent, HDLparam, HDLSymbol) {
    let text = document.getText();
    
    let parser = new ParserLib.ParserFactory;
    parser.getParser("verilog").then((lang_parser)=>{
        let structure = lang_parser.getFileParam(text);
    });

    let IllegalRange = getCommentRange(text,offset);
    text = delComments(text);
    
    if (HDLSymbol != undefined) {
        HDLSymbol.symbols = [];
    }
    // Find blocks
    while (1) {
        let match = vlog_block.exec(text);
        if (match == null) {
            break;
        }
        else if ( (match.index == 0 && parent != undefined) ||
            utils.isIllegalRange(match,IllegalRange,offset) ) {
            continue;
        }

        if (HDLSymbol != undefined) {
            let symbolInfo = HDLSymbol.setSymbolInformationWithRegExp(
                match, parent, document, offset);
            HDLSymbol.symbols.push(symbolInfo);
        }

        IllegalRange = IllegalRange.concat(
            get_block(
                match[0], 
                document, 
                match.groups.name, 
                IllegalRange, 
                (match.index + offset),
                HDLSymbol));
        if (match.groups.type == "module") {
            let HDLfileparam = {
                "moduleName" : "",
                "modulePath" : "",
                "instmodule" : [],
                "param"      : [],
                "port"       : {
                    "inout"  : [],
                    "input"  : [],
                    "output" : []
                }  
            }
            if ( type == "symbol" ) {            
                HDLfileparam = null            
            }
            get_element(
                match[0], 
                document, 
                match.groups.name, 
                IllegalRange, 
                HDLfileparam, 
                (match.index + offset),
                HDLSymbol);
            if (type!="symbol") {
                HDLfileparam.moduleName = match.groups.name;
                HDLfileparam.modulePath = document.uri._fsPath.replace(/\\/g,"\/");            
                HDLparam.push(HDLfileparam); 
            }
        }
    }

    if (HDLSymbol != undefined) {
        return HDLSymbol.symbols;
    } else {
        return undefined;
    }
}
exports.getFileParam = getFileParam;

/**
     * Matches a block in a file
     * 
     * @param  text         匹配的文本
     * @param  document     匹配文本所在的文档属性
     * @param  parent       根属性
     * @param  IllegalRange 非法区域，该区域内不匹配
     * @param  offset       匹配地址偏移(即匹配的文本在文件中的地址位置)
     * @param  HDLSymbol    符号类，对相关符号进行处理
*/
function get_block (text, document, parent, IllegalRange, offset, HDLSymbol) {
    let blockRange = [];
    if (!text) {
        text = document.getText();
    }
    for (let index = 0; index < vlog_decl_block.length; index++) {
        const unitBlock = vlog_decl_block[index];
        while (1) {
            let match = unitBlock.exec(text);
            if (match == null) {
                break;
            }
            else if ((match.index == 0 && parent == undefined) || 
                utils.isIllegalRange(match,IllegalRange,offset)) {
                continue;
            }

            if (HDLSymbol != undefined) {
                let symbolInfo = HDLSymbol.setSymbolInformationWithRegExp(
                    match, parent, document, offset);
                HDLSymbol.symbols.push(symbolInfo);
            }

            let Range = {
                "start"   : 0,
                "end"     : 0
            }
            Range.start = match.index + offset;
            Range.end   = match.index + match[0].length + offset;
            blockRange.push(Range);
            get_element(match[0], document, match.groups.name, IllegalRange, null, Range.start, HDLSymbol);
        }
    }
    return blockRange;
}

/**
     * Matches a single element in a file
     * 
     * @param  text         匹配的文本
     * @param  document     匹配文本所在的文档属性
     * @param  parent       根属性
     * @param  IllegalRange 非法区域，该区域内不匹配
     * @param  HDLfileparam HDL文件属性
     * @param  offset       匹配地址偏移(即匹配的文本在文件中的地址位置)
     * @param  HDLSymbol    符号类，对相关符号进行处理
*/
function get_element (text, document, parent, IllegalRange, HDLfileparam, offset, HDLSymbol) {
    if (!text) {
        text = document.getText();
    }
    for (let index = 0; index < vlog_decl_element.length; index++) {
        var unitElement = vlog_decl_element[index];
        while (1) {
            // 匹配每个元素
            let match = unitElement.exec(text);

            // 判断元素是否有效--是否为空 或者 是否在非法范围内
            if (match == null) {
                break;      // 即跳出此类型的匹配，执行下一类型
            }
            else if ((match.index == 0 && parent != undefined) || 
                utils.isIllegalRange(match,IllegalRange,offset)) {
                continue;   // 跳过匹配组中的一个
            }

            // 注册元素标志
            if (HDLSymbol != undefined) {
                if (unitElement == vlog_ports | unitElement == vlog_variable) {
                    var nameList = match.groups.name.split(",");
                    for (let i = 0; i < nameList.length; i++) {
                        match.groups.name = nameList[i];
                        if (match.groups.name != '') {                                
                            match.groups.name = match.groups.name.replace(/(,|;)/,'');
                            let symbolInfo = HDLSymbol.setSymbolInformationWithRegExp(
                                match, parent, document, offset);
                            HDLSymbol.symbols.push(symbolInfo);
                        }
                    }
                } else {
                    let symbolInfo = HDLSymbol.setSymbolInformationWithRegExp(
                        match, parent, document, offset);
                    HDLSymbol.symbols.push(symbolInfo);
                }
            }
            
            // 获取端口参数信息（用于仿真，生成结构，生成仿真文件）
            if ( HDLfileparam != null ) {
                switch (unitElement) {
                    case vlog_ports:
                        for (let i = 0; i < nameList.length; i++) {
                            const portName = nameList[i];
                            let portProperty = {
                                "portName"  : "",
                                "portWidth" : ""
                            };
                            if (portName != '') {                                
                                portProperty.portName = portName.replace(/(,|;)/,'');
                                if (match.groups.width == null) {
                                    portProperty.portWidth = " ";
                                } else {
                                    portProperty.portWidth = match.groups.width;
                                }
                                switch (match.groups.type) {
                                    case "inout":
                                        HDLfileparam.port.inout.push(portProperty);
                                        break;
                                    case "input":
                                        HDLfileparam.port.input.push(portProperty);
                                        break;
                                    case "output":
                                        HDLfileparam.port.output.push(portProperty);
                                        break;
                                    default: break;
                                }
                            }
                        }
                        break;
                    case vlog_variable:
                        if ( match.groups.type == "parameter" ) {
                            for (let i = 0; i < nameList.length; i++) {
                                const variableName = nameList[i];
                                let parmProperty = {
                                    "paramName"  : "",
                                    "paramWidth" : "",
                                    "paramInit"  : ""
                                }
                                parmProperty.paramName  = variableName.replace(/(,|;)/,'');
                                if (match.groups.width != null) parmProperty.paramWidth = match.groups.width;
                                if (match.groups.init != null)  parmProperty.paramInit  = match.groups.init;
                                HDLfileparam.param.push(parmProperty);
                            }
                        }
                        break;
                    case vlog_instantiation:
                        let instProperty = {
                            "instModule"  : "",
                            "instModPath" : "",
                            "instName"    : ""
                        };
                        instProperty.instModule = match.groups.type;
                        instProperty.instName   = match.groups.name;
                        HDLfileparam.instmodule.push(instProperty);
                        break;
                    default: break;
                }
            }
        }
    }
}

/**
     * 获取注释所在区间
     * 
     * @param  text         匹配的文本
     * @param  offset       匹配地址偏移(即匹配的文本在文件中的地址位置)
     * @return 返回注释所在区间的数组
*/
function getCommentRange (text, offset) {
    let commentRange = [];
    let regexes =  comment;
    for (let i = 0; i < regexes.length; i++) {
        while (1) {
            let match = regexes[i].exec(text);
            if (match == null) {
                break;
            }
            let Range = {
                "start"   : 0,
                "end"     : 0
            }
            Range.start = match.index + offset;
            Range.end = match.index + match[0].length + offset;
            commentRange.push(Range);
        }
    }
    return commentRange;
}
exports.getCommentRange = getCommentRange;

function delComments(content) {
    let match = content.match(b_comment);
    if (match != null) {
        for (let i = 0; i < match.length; i++) {
            const element = match[i];
            const newElement = element.replace(/\S/g,' ');
            content = content.replace(element,newElement);
        }
    }
    match = content.match(l_comment);
    if (match != null) {
        for (let i = 0; i < match.length; i++) {
            const element = match[i];
            const newElement = element.replace(/\S/g,' ');
            content = content.replace(element,newElement);
        }
    }
    return content;
}
exports.delComments = delComments;