"use strict";

// comment
var l_comment = new RegExp([
    /\/\/.*/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var b_comment = new RegExp([
    /\/\*[\s\S]*?\*\//
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var comment = [
    l_comment,
    b_comment
]

/* vlog parse */
/////////////////////////block RegExp////////////////////////////////////
var vlog_modules = new RegExp([
    /module\s+/,
    /(?:automatic\s+)?/,
    /(?<name>\w+)/,
    /(?:\s*#\s*\([\w\W]*?\))?/, // <params>
    /(?:\s*\([\W\w]*?\))?/,     // <ports>
    /\s*;/,
    /(?:[\W\w]*?)/,             // <body>
    /endmodule/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_classes = new RegExp([
    /(?<type>class)\s+/,
    /(?<name>\w+)/,
    /(\s+(extends|implements)\s+[\w\W]+?|\s*#\s*\([\w\W]+?\))*?/,
    /\s*;/,
    /(?<body>[\w\W]*?)/,
    /endclass/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_methods = new RegExp([
    /(?<type>(function|task))\s+/,
    /((?<return>\[.+?\])\s+)?/,
    /\b(?<name>\w+)\b\s*/,
    /(?<ports>\([\W\w]*?\))?/,
    /\s*;/,
    /(?<body>[\w\W]*?)/,
    /(?:end(?:function|task))/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_generate_begin = new RegExp([
    /generate\s*/,
    /(?<type>if|for)\s*/,
    /\([\w\W]*?\)\s*/,
    /(begin\s*:\s*(?<name>\w+))?/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_generate_end = new RegExp([
    /endgenerate/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

/////////////////////////element RegExp////////////////////////////////////
var vlog_asserts = new RegExp([
    /(?<=^\s*(?<name>\w+)\s*:\s*)/,
    /(?<type>assert\b)/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_ports = new RegExp([
    /(?<=\s)/,
    /(?<type>input|output|inout)/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_singals = new RegExp([
    /(?<!(input|output|inout|,)\s*)/,
    /(?<type>(?<=\s)(reg|wire|logic))/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_parameter = new RegExp([
    /(?<=\s)/,
    /parameter/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_constants = new RegExp([
    /(?<=\s)/,
    /(?<type>localparam|int|char|float|integer)/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_processes = new RegExp([
    /(?<type>always|always_ff|always_comb)/,
    /(\s*@\s*(?<event>\([\w\W]*?\)))?\s*/,
    /(begin\s*:\s*(?<name>\w+))?/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_label_begin = new RegExp([
    /begin(\s*:\s*(?<name>\w+))?/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_label_end = new RegExp([
    /end\s/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_instances = new RegExp([
    // /(?:(?<modifier>virtual|static|automatic|rand|randc|pure virtual)\s+)?/,
    /\b(?<type>[:\w]+)\s*/,
    /(#\s*\((?<params>\s*\.[\w\W]*?)\))?\s*/,
    /\b(?<name>\w+)?\s*/,
    /(\((?<ports>\s*\.[\w\W]*?)\))\s*;/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

/////////////////////////macro define RegExp////////////////////////////////////
var vlog_typedef = new RegExp([
    /(?<=^\s*)/,
    /(?<type>typedef)\s+/,
    /(?<body>[^;]*)/,
    /(?<name>\b\w+)/,
    /\s*(\[[^;]*?\])*?/,
    /\s*(?<end>;)/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlog_define = new RegExp([
    /(?<=^\s*)/,
    /`(?<type>define)\s+/,
    /(?<name>\w+)\b/,
    /((?<ports>\([^\n]*\))|\s*?)/,
    /(?<body>([^\n]*\\\n)*([^\n]*))/,
    /(?<!\\)(?=\n)/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vlogRegExp = {
    "module"   : vlog_modules,
    "instance" : vlog_instances,
}
exports.vlogRegExp = vlogRegExp;

/////////////////////////API////////////////////////////////////
function getFileParam(document, HDLSymbol, HDLparam) {
    try {
        HDLSymbol.symbols = [];
        let text = document.getText();
        text = delComments(text);
        get_modules(text, document, null, HDLparam, HDLSymbol);
        return HDLSymbol.symbols;
    }
    catch (error) {
        console.log(error);
        return null;
    }
}
exports.getFileParam = getFileParam;

/////////////////////////block api////////////////////////////////////
function get_modules(text, document, parent, HDLparam, HDLSymbol) {
    while (1) {
        let match = vlog_modules.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : match.groups.name,
            'type' : "module",
            "startIndex": match.index,
            "lastIndex" : match.index + match[0].length,
        };
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        let content = {"text" : match[0]};
        // get blocks
        get_generates(content, document, item.name, item.startIndex, HDLSymbol);
        get_methods(content, document, item.name, item.startIndex, HDLSymbol);
        
        // get elements
        let structure = get_element(content.text, document, item.name, match.index, HDLSymbol);
        structure.startIndex = item.startIndex;
        structure.lastIndex  = item.lastIndex;
        if (HDLparam != null) {
            HDLparam.push(structure);
        }
        // let oldContent = generate_text;
        // let newContent = generate_text.replace(strRegExp, ' ');
        // content.text = content.text.replace(oldContent,newContent);
    }
}
exports.get_modules = get_modules;

//--------classes block--------//
function get_classes(content, document, parent, offset, HDLSymbol) {
    let items = [];
    let strRegExp = /\S+/g;
    while (1) {
        let match = vlog_classes.exec(content.text);
        if (match == null) {
            break;      
        }
        let item = {
            "name": match.groups.name,
            "type": "generate",
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        // get blocks
        get_methods(match[0], document, item.name, item.startIndex, HDLSymbol);

        // get elements
        get_element(match[0], document, item.name, item.startIndex, HDLSymbol);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        let oldContent = match[0];
        let newContent = match[0].replace(strRegExp, ' ');
        content.text = content.text.replace(oldContent,newContent);
    }
    return items;
}
exports.get_classes = get_classes;

//--------generate block--------//
function get_generates(content, document, parent, offset, HDLSymbol) {
    let items = [];
    let startItems = [];
    let lastItems  = [];
    while (1) {
        let match = vlog_generate_begin.exec(content.text);
        if (match == null) {
            break;      
        }
        if (match.groups.name == null) {
            match.groups.name = "generate-(no name)";
        }
        let item = {
            "name": match.groups.name,
            "type": "generate",
            "parent": parent,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        startItems.push(item);
    }
    while (1) {
        let match = vlog_generate_end.exec(content.text);
        if (match == null) {
            break;      
        }
        lastItems.push(match.index + match[0].length + offset);
    }
    if (lastItems.length == 0) {
        return items;
    }
    get_generates_index(items, startItems, lastItems);
    for (let index = 0; index < items.length; index++) {
        const itemsElement = items[index];
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(itemsElement, itemsElement.parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        let generate_text = content.text.substring(itemsElement.startIndex-offset, itemsElement.lastIndex-offset);
        // get blocks
        get_methods(generate_text, document, itemsElement.name, itemsElement.startIndex, HDLSymbol);
    
        // get elements
        get_element(generate_text, document, itemsElement.name, itemsElement.startIndex, HDLSymbol);
        
        let oldContent = generate_text;
        let newContent = ' '.repeat(generate_text.length);
        content.text = content.text.replace(oldContent,newContent);
    }
    return items;
}
exports.get_generates = get_generates;

function get_generates_index(items, startItems, lastItems) {
    if (startItems.length == 0) {
        return items;
    }
    while (lastItems.length) {
        for (let i = 0; i < startItems.length; i++) {
            const startIndexElement = startItems[i].lastIndex;
            if ((startIndexElement > lastItems[0]) || (1 == startItems.length)) {
                let index = (i == 0) ? 0 : i-1;
                startItems[index].lastIndex = lastItems[0];
                if (index-1 >= 0) {
                    startItems[index].parent = startItems[index-1].name;
                }
                items.push(startItems[index]);
                startItems.splice(index,1);
                lastItems.splice(0,1);
                break;
            }
        }
    }
    return items;
}

//--------method block--------//
function get_methods(content, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vlog_methods.exec(content.text);
        if (match == null) {
            break;      
        }
        let item = {
            "name": match.groups.name,
            "type": match.groups.type,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        get_ports(match[0], document, item.name, item.startIndex, HDLSymbol);
        get_signals(match[0], document, item.name, item.startIndex, HDLSymbol);
        let oldContent = match[0];
        let newContent = ' '.repeat(match[0].length);
        content.text = content.text.replace(oldContent,newContent);
    }
    return items;
}
exports.get_methods = get_methods;

/////////////////////////element api////////////////////////////////////
//--------get element--------//
function get_element(text, document, parent, offset, HDLSymbol) {
    let ports     = get_ports(text, document, parent, offset, HDLSymbol);
    let signals   = get_signals(text, document, parent, offset, HDLSymbol);
    let asserts   = get_asserts(text, document, parent, offset, HDLSymbol);
    let parameter = get_parameter(text, document, parent, offset, HDLSymbol);
    let instances = get_instances(text, document, parent, offset, HDLSymbol);
    let constants = get_constants(text, document, parent, offset, HDLSymbol);
    let processes = get_processes(text, document, parent, offset, HDLSymbol);

    let structure = {};
    structure = {
        "moduleName": parent, // module
        "modulePath": document.fileName.replace(/\\/g, "\/"),
        "ports"     : ports,
        "signals"   : signals,
        "asserts"   : asserts,
        "parameter" : parameter,
        "instances" : instances,
        "constants" : constants,
        "processes" : processes,
        "startIndex": 0,
        "lastIndex" : 0,
    };
    return structure;
}
exports.get_element = get_element;

//--------always process element--------//
function get_processes(text, document, parent, offset, HDLSymbol) {
    let items = [];
    let blankRegExp = /\s/g;
    while (1) {
        let match = vlog_processes.exec(text);
        if (match == null) {
            break;      
        }
        let processName = match.groups.name;
        if (processName == null) {
            if (match.groups.event == null) {
                processName = match.groups.type + "-Unconditional";
            } else {
                processName = match.groups.type + "-" + match.groups.event.replace(blankRegExp, ' ');
            }
        } else {
            if (match.groups.event == null) {
                processName = processName + ":" + "Unconditional";
            } else {
                processName = processName + ":" + match.groups.event.replace(blankRegExp, ' ');
            }
        }
        let item = {
            "name": processName,
            "type": "always",
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
    }
    return items;
}
exports.get_processes = get_processes;

//--------instantiation element--------//
function get_instances(text, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vlog_instances.exec(text);
        if (match == null) {
            break;      
        }

        let item = {
            "name": match.groups.name,
            "type": "instance",
            "instparams": {
                "startIndex": -1,
                "lastIndex" : -1,
            },
            "instports" : {
                "startIndex": -1,
                "lastIndex" : -1,
            },
            "instName": match.groups.name,   // name
            "instModule": match.groups.type, // type
            "instModPath": "",
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        if (match.groups.params != null) {
            item.instparams.startIndex = match.index + offset + match[0].indexOf(match.groups.params);
            item.instparams.lastIndex = item.instparams.startIndex + match.groups.params.length;
        }
        if (match.groups.ports != null) {
            item.instports.startIndex = match.index + offset + match[0].indexOf(match.groups.ports);
            item.instports.lastIndex = item.instports.startIndex + match.groups.ports.length;
        }
        
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
    }
    return items;
}
exports.get_instances = get_instances;

//--------ports element--------//
function get_ports(text, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vlog_ports.exec(text);
        if (match == null) {
            break;      
        }
        let portInfo = get_data_info(text, match.index + match[0].length, ["input", "output", "inout"]);
        for (let i = 0; i < portInfo.datas.length; i++) {
            let item = {
                'name' : "",
                'type' : match.groups.type,
                "portName" : "",
                "portWidth": "",
                "startIndex": match.index + offset,
                "lastIndex" : portInfo.last + offset,
            };
            const port = portInfo.datas[i];
            item.portWidth = port.width;
            item.name = port.name;
            item.portName = item.name;
            items.push(item);
            if (HDLSymbol != null) {
                let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                HDLSymbol.symbols.push(symbolInfo);
            }
        }
    }
    return items;
}
exports.get_ports = get_ports;

//--------signal element--------//
function get_signals(text, document, parent, offset, HDLSymbol) {
    let items = [];
    
    while (1) {
        let match = vlog_singals.exec(text);
        if (match == null) {
            break;      
        }
        let signalInfo = get_data_info(text, match.index + match[0].length, ["reg","wire","logic"]);
        for (let i = 0; i < signalInfo.datas.length; i++) {
            let item = {
                'name' : "",
                'type' : match.groups.type,
                'range': "",
                "startIndex": match.index + offset,
                "lastIndex" : signalInfo.last + offset,
            };
            const signal = signalInfo.datas[i];
            item.name  = signal.name;
            item.range = signal.width;
            items.push(item);
            if (HDLSymbol != null) {
                let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                HDLSymbol.symbols.push(symbolInfo);
            }
        }
    }
    return items;
}
exports.get_signals = get_signals;

//--------param element--------//
function get_parameter(text, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vlog_parameter.exec(text);
        if (match == null) {
            break;      
        }
        let paramInfo = get_data_info(text, match.index + match[0].length, ["parameter"]);
        for (let i = 0; i < paramInfo.datas.length; i++) {
            let item = {
                'name' : "",
                'type' : "parameter",
                "paramName"  : "",
                "paramWidth" : "",
                "paramInit"  : "",
                "startIndex": match.index + offset,
                "lastIndex" : paramInfo.last + offset,
            };
            const param = paramInfo.datas[i];
            item.name  = param.name;
            item.paramName  = param.name;
            item.paramInit  = param.init;
            item.paramWidth = param.width;
            items.push(item);
            if (HDLSymbol != null) {
                let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                HDLSymbol.symbols.push(symbolInfo);
            }
        }
    }
    return items;
}
exports.get_parameter = get_parameter;

//--------constant element--------//
function get_constants(text, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vlog_constants.exec(text);
        if (match == null) {
            break;      
        }
        let constantInfo = get_data_info(text, match.index + match[0].length, ["localparam","int","char","float","integer"]);
        for (let i = 0; i < constantInfo.datas.length; i++) {
            let item = {
                'name' : "",
                'type' : match.groups.type,
                'range': "",
                "startIndex": match.index + offset,
                "lastIndex" : constantInfo.last + offset,
            };
            const constant = constantInfo.datas[i];
            item.name  = constant.name;
            item.range = constant.width;
            items.push(item);
            if (HDLSymbol != null) {
                let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                HDLSymbol.symbols.push(symbolInfo);
            }
        }
    }
    return items;
}
exports.get_constants = get_constants;

//--------signal element--------//
function get_asserts(text, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vlog_asserts.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : match.groups.name,
            'type' : match.groups.type,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
    }
    return items;
}
exports.get_asserts = get_asserts;

/////////////////////////util api////////////////////////////////////
function get_data_info(text, offset, key_words) {
    let datas = [];
    let info = {
        "datas" : [],
        "last"  : 0,
    }

    let rightBracket = 0;
    let leftBracket  = 0;

    let index = offset;
    let lastIndex = 0;
    let spaceFlag = false;
    let nameLock  = false;
    let currentType  = "name";

    let currentName  = "";
    let currentInit  = "";
    let currentWidth = "";

    while ((text[index] != ';') && (index <= text.length)) {
        switch (text[index]) {
            case '\0' :
            case '\r' :
            case '\t' :
            case '\v' :
            case '\n' :
            case '\f' :
            case ' '  : 
                spaceFlag = true;
                if (key_words.includes(currentName)) {
                    info.datas = datas;
                    info.last  = lastIndex;
                    return info;
                } 
            break;
            case '[' : 
                currentType = "width";
                if (!nameLock) {
                    currentWidth = currentWidth + text[index];
                }
            break;
            case ']' : 
                if (!nameLock) {
                    currentType = "postwidth"; 
                    currentWidth = currentWidth + text[index];
                }
            break;
            case '=' : 
                currentType = "init"; 
            break;
            case ',' : 
                let data  = {
                    "name"  : "",
                    "init"  : "",
                    "width" : "",
                }
                nameLock   = false;
                lastIndex  = index;
                data.name  = currentName;
                data.init  = currentInit;
                data.width = currentWidth;
                currentName  = "";
                currentInit  = "";
                currentWidth = "";
                currentType  = "name"
                datas.push(data);
            break;
            default: 
                if (text[index] == "(") {
                    leftBracket++;
                }
                else if (text[index] == ")") {
                    rightBracket++;
                    if (rightBracket > leftBracket) {
                        let data  = {
                            "name"  : "",
                            "init"  : "",
                            "width" : "",
                        }
                        lastIndex  = index;
                        data.name  = currentName;
                        data.init  = currentInit;
                        data.width = currentWidth;
                        datas.push(data);
                        info.datas = datas;
                        info.last  = lastIndex;
                        return info;
                    }
                }
                if (currentType == "init") {
                    spaceFlag = false;
                    currentInit = currentInit + text[index];
                }
                else if (currentType == "width") {
                    spaceFlag = true;
                    if (!nameLock) {
                        currentWidth = currentWidth + text[index];
                    }
                }
                else if (currentType == "postwidth") {
                    nameLock    = true;
                    spaceFlag   = false;
                    currentType = "name";
                    currentName = text[index];
                }
                else if (currentType == "name") {
                    if (spaceFlag) {
                        currentName = "";
                    }
                    spaceFlag = false;
                    currentName = currentName + text[index];
                }
            break;
        }
        index = index + 1;
    }
    let data  = {
        "name"  : "",
        "init"  : "",
        "width" : "",
    }
    lastIndex  = index;
    data.name  = currentName;
    data.init  = currentInit;
    data.width = currentWidth;
    datas.push(data);
    info.datas = datas;
    info.last  = lastIndex;
    return info;
}

function delComments(content) {
    let match = content.match(b_comment);
    if (match != null) {
        for (let i = 0; i < match.length; i++) {
            const element = match[i];
            const newElement = ' '.repeat(element.length);
            content = content.replace(element,newElement);
        }
    }
    match = content.match(l_comment);
    if (match != null) {
        for (let i = 0; i < match.length; i++) {
            const element = match[i];
            const newElement = ' '.repeat(element.length);
            content = content.replace(element,newElement);
        }
    }
    return content;
}
exports.delComments = delComments;

/**
     * 获取注释所在区间
     * 
     * @param  text         匹配的文本
     * @param  offset       匹配地址偏移(即匹配的文本在文件中的地址位置)
     * @return 返回注释所在区间的数组
*/
function getCommentRange (text, offset) {
    let commentRange = [];
    let regexes =  comment;
    for (let i = 0; i < regexes.length; i++) {
        while (1) {
            let match = regexes[i].exec(text);
            if (match == null) {
                break;
            }
            let Range = {
                "start"   : 0,
                "end"     : 0
            }
            Range.start = match.index + offset;
            Range.end = match.index + match[0].length + offset;
            commentRange.push(Range);
        }
    }
    return commentRange;
}
exports.getCommentRange = getCommentRange;