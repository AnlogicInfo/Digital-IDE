"use strict";

// comment
var l_comment = new RegExp([
    /--.*/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var b_comment = new RegExp([
    /\*[\s\S]*?\*\//
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

/* vhdl parse */
// block
var vhdl_modules = new RegExp([
    /entity\s+(?<name>\w+?)\s*is\s*/,
    /(generic\s*\((?<param>[\w\W]+?)\)\s*;)?\s*?/,
    /(port\s*\((?<port>[\w\W]+?)\)\s*;)?\s*?/,
    /end/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mgi');

var vhdl_methods = new RegExp([
    /function\s+?/,
    /(?<name>\w+)\s*?/,
    /\([\w\W]+?\)\s*?/,
    /return\s*\w+?\s*?is/,
    /\s*?begin/,
    /(?:[\w\W]*?)/, // <body>
    /end/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vhdl_generates = new RegExp([
    /(?<name>\w+?)/,
    /\s*:\s*/,
    /(?<type>if|for)/,
    /[\w\W]*?/,
    /generate\s*/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

// element
var vhdl_instances = new RegExp([
    /(?<name>\w+?)/,
    /\s*:\s*/,
    /(?<type>\w+?)/,
    /\s+/,
    /(generic?\s*?map\s*?\([\w\W]*?\))?\s*/,
    /(?:port\s+map\s*\([\w\W]*?\))\s*;/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mgi');

var vhdl_processes = new RegExp([
    /(?<name>\w+?)/,
    /\s*:\s*process/,
    /((?<event>\([\w\W]*?\)))?/,
    /(?<body>[\w\W]+?)/,
    /end\s*process\s*;/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vhdl_constants = new RegExp([
    /(?<name>\w+)/,
    /\s*:\s*/,
    /(?<type>integer|natural|postive|time)/,
    /\s*/,
    /(:=)?\s*/,
    /(?<init>\S+)?/,
    /\s*(\)|;)/
].map(x => x.source).join(''), 'mgi');

var vhdl_ports = new RegExp([
    /(?<name>\w+)/,
    /\s*:\s*/,
    /(?<type>in|out|inout|buffer)/,
    /\s+/,
    /(?:(signed|unsigned|std_logic|std_logic_vector)\s*)*?/,
    /(?<width>\([0-9]+\s+downto\s+[0-9]+\))?/,
    /\s*(\)|;)/
].map(x => x.source).join(''), 'mgi');

var vhdl_singals = new RegExp([
    /signal\s*/,
    /(?<name>\w+)/,
    /\s*:\s*/,
    /(?<type>reg|wire|logic)/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');


/////////////////////////API////////////////////////////////////
function getFileParam(document, HDLSymbol, HDLparam) {
    try {
        HDLSymbol.symbols = [];
        let text = document.getText();
        text = delComments(text);
        get_modules(text, document, null, HDLparam, HDLSymbol);
        return HDLSymbol.symbols;
    }
    catch (error) {
        console.log(error);
        return undefined;
    }
}
exports.getFileParam = getFileParam;

/////////////////////////block api////////////////////////////////////
function get_modules(text, document, parent, HDLparam, HDLSymbol) {
    while (1) {
        let match = vhdl_modules.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : match.groups.name,
            'type' : "module",
            "startIndex": match.index,
            "lastIndex" : match.index + match[0].length,
        };
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        let content = {"text" : match[0]};
        // get blocks
        get_generates(content, document, item.name, item.startIndex, HDLSymbol);
        get_methods(content, document, item.name, item.startIndex, HDLSymbol);
        
        // get elements
        let structure = get_element(content.text, document, item.name, match.index, HDLSymbol);
        console.log(structure);
        if (HDLparam != null) {
            HDLparam.push(structure);
        }
    }
}

//--------generate block--------//
function get_generates(content, document, parent, offset, HDLSymbol) {
    let items = [];
    let startItems = [];
    let lastItems  = [];
    while (1) {
        let match = vhdl_generate_begin.exec(content.text);
        if (match == null) {
            break;      
        }
        if (match.groups.name == null) {
            match.groups.name = "generate-(no name)";
        }
        let item = {
            "name": match.groups.name,
            "type": "generate",
            "parent": parent,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        startItems.push(item);
    }
    while (1) {
        let match = vhdl_generate_end.exec(content.text);
        if (match == null) {
            break;      
        }
        lastItems.push(match.index + match[0].length + offset);
    }
    if (lastItems.length == 0) {
        return items;
    }
    get_generates_index(items, startItems, lastItems);
    for (let index = 0; index < items.length; index++) {
        const itemsElement = items[index];
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(itemsElement, itemsElement.parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        let generate_text = content.text.substring(itemsElement.startIndex-offset, itemsElement.lastIndex-offset);
        // get blocks
        get_methods(generate_text, document, itemsElement.name, itemsElement.startIndex, HDLSymbol);
    
        // get elements
        get_element(generate_text, document, itemsElement.name, itemsElement.startIndex, HDLSymbol);
        
        let oldContent = generate_text;
        let newContent = ' '.repeat(generate_text.length);
        content.text = content.text.replace(oldContent,newContent);
    }
    return items;
}

function get_generates_index(items, startItems, lastItems) {
    if (startItems.length == 0) {
        return items;
    }
    while (lastItems.length) {
        for (let i = 0; i < startItems.length; i++) {
            const startIndexElement = startItems[i].lastIndex;
            if ((startIndexElement > lastItems[0]) || (1 == startItems.length)) {
                let index = (i == 0) ? 0 : i-1;
                startItems[index].lastIndex = lastItems[0];
                if (index-1 >= 0) {
                    startItems[index].parent = startItems[index-1].name;
                }
                items.push(startItems[index]);
                startItems.splice(index,1);
                lastItems.splice(0,1);
                break;
            }
        }
    }
    return items;
}

//--------method block--------//
function get_methods(content, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vhdl_methods.exec(content.text);
        if (match == null) {
            break;      
        }
        let item = {
            "name": match.groups.name,
            "type": match.groups.type,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        get_ports(match[0], document, item.name, item.startIndex, HDLSymbol);
        get_signals(match[0], document, item.name, item.startIndex, HDLSymbol);
        let oldContent = match[0];
        let newContent = ' '.repeat(match[0].length);
        content.text = content.text.replace(oldContent,newContent);
    }
    return items;
}

/////////////////////////element api////////////////////////////////////
//--------get element--------//
function get_element(text, document, parent, offset, HDLSymbol) {
    let ports     = get_ports(text, document, parent, offset, HDLSymbol);
    let signals   = get_signals(text, document, parent, offset, HDLSymbol);
    let asserts   = get_asserts(text, document, parent, offset, HDLSymbol);
    let parameter = get_parameter(text, document, parent, offset, HDLSymbol);
    let instances = get_instances(text, document, parent, offset, HDLSymbol);
    let constants = get_constants(text, document, parent, offset, HDLSymbol);
    let processes = get_processes(text, document, parent, offset, HDLSymbol);

    let structure = {};
    structure = {
        "moduleName": parent, // module
        // "modulePath": document.fileName.replace(/\\/g, "\/"),
        "ports"     : ports,
        "signals"   : signals,
        "asserts"   : asserts,
        "parameter" : parameter,
        "instances" : instances,
        "constants" : constants,
        "processes" : processes,
    };
    return structure;
}

//--------always process element--------//
function get_processes(text, document, parent, offset, HDLSymbol) {
    let items = [];
    let blankRegExp = /\s+/g;
    while (1) {
        let match = vhdl_processes.exec(text);
        if (match == null) {
            break;      
        }
        let processName = match.groups.name;
        if (processName == null) {
            if (match.groups.event == null) {
                processName = match.groups.type + "-Unconditional";
            } else {
                processName = match.groups.type + "-" + match.groups.event.replace(blankRegExp, ' ');
            }
        } else {
            if (match.groups.event == null) {
                processName = processName + ":" + "Unconditional";
            } else {
                processName = processName + ":" + match.groups.event.replace(blankRegExp, ' ');
            }
        }
        let item = {
            "name": processName,
            "type": "always",
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
    }
    return items;
}

//--------instantiation element--------//
function get_instances(text, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vhdl_instances.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            "name": match.groups.name,
            "type": "instance",
            "instName": match.groups.name,   // name
            "instModule": match.groups.type, // type
            "instModPath": "",
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
    }
    return items;
}

//--------ports element--------//
function get_ports(text, document, parent, offset, HDLSymbol) {
    let items = [];
    let initRegExp = /\s*=\s*(.+)/;
    while (1) {
        let match = vhdl_ports.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : "",
            'type' : match.groups.type,
            "portName" : "",
            "portWidth": match.groups.width,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        var nameList = match.groups.name.split(",");
        for (let i = 0; i < nameList.length; i++) {
            if (nameList[i] != '') {                                
                item.name = nameList[i].replace(initRegExp,'');
                item.portName = item.name;
                items.push(item);
                if (HDLSymbol != null) {
                    let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                    HDLSymbol.symbols.push(symbolInfo);
                }
            }
        }
    }
    return items;
}

//--------signal element--------//
function get_signals(text, document, parent, offset, HDLSymbol) {
    let items = [];
    let initRegExp = /\s*=\s*(.+)/;
    while (1) {
        let match = vhdl_singals.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : "",
            'type' : match.groups.type,
            'range': match.groups.width,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        var nameList = match.groups.name.split(",");
        for (let i = 0; i < nameList.length; i++) {
            if (nameList[i] != '') {                                
                item.name = nameList[i].replace(initRegExp,'');
                items.push(item);
                if (HDLSymbol != null) {
                    let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                    HDLSymbol.symbols.push(symbolInfo);
                }
            }
        }
    }
    return items;
}

//--------param element--------//
function get_parameter(text, document, parent, offset, HDLSymbol) {
    let items = [];
    let initRegExp = /\s*=\s*(.+)/;
    let equRegExp  = /\s*=\s*/;
    let endRexExp  = /\s*(,|;)?/;
    while (1) {
        let match = vhdl_parameter.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : "",
            'type' : "parameter",
            "paramName"  : "",
            "paramWidth" : match.groups.width,
            "paramInit"  : "",
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        var nameList = match.groups.name.split(",");
        for (let i = 0; i < nameList.length; i++) {
            if (nameList[i] != '') {                                
                item.name = nameList[i].replace(initRegExp,'');
                item.paramName = item.name;
                item.paramInit = nameList[i].replace(item.name,'');
                item.paramInit = item.paramInit.replace(equRegExp,'');
                item.paramInit = item.paramInit.replace(endRexExp,'');
                items.push(item);
                if (HDLSymbol != null) {
                    let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                    HDLSymbol.symbols.push(symbolInfo);
                }
            }
        }
    }
    return items;
}

//--------constant element--------//
function get_constants(text, document, parent, offset, HDLSymbol) {
    let items = [];
    let initRegExp = /\s*=\s*(.+)(,|;)/;
    while (1) {
        let match = vhdl_constants.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : "",
            'type' : match.groups.type,
            'range': match.groups.width,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        var nameList = match.groups.name.split(",");
        for (let i = 0; i < nameList.length; i++) {
            if (nameList[i] != '') {                                
                item.name = nameList[i].replace(initRegExp,'');
                items.push(item);
                if (HDLSymbol != null) {
                    let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                    HDLSymbol.symbols.push(symbolInfo);
                }
            }
        }
    }
    return items;
}

/////////////////////////util api////////////////////////////////////
function delComments(content) {
    let match = content.match(b_comment);
    if (match != null) {
        for (let i = 0; i < match.length; i++) {
            const element = match[i];
            const newElement = ' '.repeat(element.length);
            content = content.replace(element,newElement);
        }
    }
    match = content.match(l_comment);
    if (match != null) {
        for (let i = 0; i < match.length; i++) {
            const element = match[i];
            const newElement = ' '.repeat(element.length);
            content = content.replace(element,newElement);
        }
    }
    return content;
}