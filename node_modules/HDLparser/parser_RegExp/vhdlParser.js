"use strict";

// comment
var l_comment = new RegExp([
    /--.*/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var b_comment = new RegExp([
    /\*[\s\S]*?\*\//
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
var comment = [
    l_comment,
    b_comment
]

var spaceRegExp = /\s*/g;
/* vhdl parse */
// block
var vhdl_modules = new RegExp([
    /entity\s+(?<name>\w+?)\s*is\s*?/,
    /(generic\s*\((?<param>[\w\W]*?)\)\s*;)?\s*?/,
    /(port\s*\((?<port>[\w\W]*?)\)\s*;)?\s*?/,
    /end/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mgi');

var vhdl_methods = new RegExp([
    /function\s+?/,
    /(?<name>\w+)\s*?/,
    /\([\w\W]+?\)\s*?/,
    /return\s*\w+?\s*?is/,
    /\s*?begin/,
    /(?:[\w\W]*?)/, // <body>
    /end/
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vhdl_generate_begin = new RegExp([
    /(?<name>\w+?)/,
    /\s*:\s*/,
    /(?<type>if|for)/,
    /[\w\W]*?/,
    /generate/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vhdl_generate_end = new RegExp([
    /end\s*?generate/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

// element
var vhdl_instances = new RegExp([
    /(?<name>\w+?)/,
    /\s*:\s*/,
    /(?<type>\w+?)\s+/,
    /(?:generic?\s*?map\s*?\((?<params>[\w\W]*?)\))?\s*/,
    /(?:port\s+map\s*\((?<ports>[\w\W]*?)\))\s*;/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mgi');

var vhdl_processes = new RegExp([
    /(?:(?<name>\w+?)\s*:\s*)?/,
    /process/,
    /((?<event>\([\w\W]*?\)))?/,
    /(?<body>[\w\W]+?)/,
    /end\s*process\s*;/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var vhdl_parameter = new RegExp([
    /(?<name>\w+)/,
    /\s*:\s*/,
    /(?<type>integer|natural|postive|time)\s*/,
    /(:=\s*(?<init>.+))?/,
    /\s*?(\)|;)/
].map(x => x.source).join(''), 'mgi');

var vhdl_ports = new RegExp([
    /(?<name>[\w,\s]+)/,
    /\s*:\s*/,
    /(?<type>in|out|inout|buffer)\s+/,
    /(?:\w*\s*)/,
    /(?<width>\([0-9]+\s+downto\s+[0-9]+\))?/,
    /\s*?(\)|;)/
].map(x => x.source).join(''), 'mgi');

var vhdl_singals = new RegExp([
    /signal\s*/,
    /(?<name>[\w,\s]+)/,
    /\s*:\s*/,
    /(?:\w*\s*)/,
    /(?<width>\([0-9]+\s+downto\s+[0-9]+\))?/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');


/////////////////////////API////////////////////////////////////
function getFileParam(document, HDLSymbol, HDLparam) {
    try {
        HDLSymbol.symbols = [];
        let text = document.getText();
        text = delComments(text);
        get_modules(text, document, null, HDLparam, HDLSymbol);
        return HDLSymbol.symbols;
    }
    catch (error) {
        console.log(error);
        return undefined;
    }
}
exports.getFileParam = getFileParam;

/////////////////////////block api////////////////////////////////////
function get_modules(text, document, parent, HDLparam, HDLSymbol) {
    while (1) {
        let match = vhdl_modules.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : match.groups.name,
            'type' : "module",
            "startIndex": match.index,
            "lastIndex" : match.index + match[0].length,
        };
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        let content = {"text" : text};
        // get blocks
        get_generates(content, document, item.name, 0, HDLSymbol);
        get_methods(content, document, item.name, 0, HDLSymbol);
        
        // get elements
        let structure = get_element(content.text, document, item.name, 0, HDLSymbol);
        let ports     = get_ports(match[0], document, item.name, item.startIndex, HDLSymbol);
        let parameter = get_parameter(match[0], document, item.name, item.startIndex, HDLSymbol);
        structure.ports = ports;
        structure.parameter = parameter;
        if (HDLparam != null) {
            HDLparam.push(structure);
        }
    }
}

//--------generate block--------//
function get_generates(content, document, parent, offset, HDLSymbol) {
    let items = [];
    let startItems = [];
    let lastItems  = [];
    while (1) {
        let match = vhdl_generate_begin.exec(content.text);
        if (match == null) {
            break;      
        }
        if (match.groups.name == null) {
            match.groups.name = "generate-(no name)";
        }
        let item = {
            "name": match.groups.name,
            "type": "generate",
            "parent": parent,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        startItems.push(item);
    }
    while (1) {
        let match = vhdl_generate_end.exec(content.text);
        if (match == null) {
            break;      
        }
        lastItems.push(match.index + match[0].length + offset);
    }
    if (lastItems.length == 0) {
        return items;
    }
    get_generates_index(items, startItems, lastItems);
    for (let index = 0; index < items.length; index++) {
        const itemsElement = items[index];
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(itemsElement, itemsElement.parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        let generate_text = content.text.substring(itemsElement.startIndex-offset, itemsElement.lastIndex-offset);
        // get blocks
        get_methods(generate_text, document, itemsElement.name, itemsElement.startIndex, HDLSymbol);
    
        // get elements
        get_element(generate_text, document, itemsElement.name, itemsElement.startIndex, HDLSymbol);
        
        let oldContent = generate_text;
        let newContent = ' '.repeat(generate_text.length);
        content.text = content.text.replace(oldContent,newContent);
    }
    return items;
}

function get_generates_index(items, startItems, lastItems) {
    if (startItems.length == 0) {
        return items;
    }
    while (lastItems.length) {
        for (let i = 0; i < startItems.length; i++) {
            const startIndexElement = startItems[i].lastIndex;
            if ((startIndexElement > lastItems[0]) || (1 == startItems.length)) {
                let index = (i == 0) ? 0 : i-1;
                startItems[index].lastIndex = lastItems[0];
                if (index-1 >= 0) {
                    startItems[index].parent = startItems[index-1].name;
                }
                items.push(startItems[index]);
                startItems.splice(index,1);
                lastItems.splice(0,1);
                break;
            }
        }
    }
    return items;
}

//--------method block--------//
function get_methods(content, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vhdl_methods.exec(content.text);
        if (match == null) {
            break;      
        }
        let item = {
            "name": match.groups.name,
            "type": match.groups.type,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
        get_ports(match[0], document, item.name, item.startIndex, HDLSymbol);
        get_signals(match[0], document, item.name, item.startIndex, HDLSymbol);
        let oldContent = match[0];
        let newContent = ' '.repeat(match[0].length);
        content.text = content.text.replace(oldContent,newContent);
    }
    return items;
}

/////////////////////////element api////////////////////////////////////
//--------get element--------//
function get_element(text, document, parent, offset, HDLSymbol) {
    let signals   = get_signals(text, document, parent, offset, HDLSymbol);
    let instances = get_instances(text, document, parent, offset, HDLSymbol);
    let processes = get_processes(text, document, parent, offset, HDLSymbol);

    let structure = {};
    structure = {
        "moduleName": parent, // module
        "modulePath": document.fileName.replace(/\\/g, "\/"),
        "ports"     : null,
        "signals"   : signals,
        "parameter" : null,
        "instances" : instances,
        "processes" : processes,
    };
    return structure;
}

//--------always process element--------//
function get_processes(text, document, parent, offset, HDLSymbol) {
    let items = [];
    let blankRegExp = /\s+/g;
    while (1) {
        let match = vhdl_processes.exec(text);
        if (match == null) {
            break;      
        }
        let processName = match.groups.name;
        if (processName == null) {
            if (match.groups.event == null) {
                processName = "processe" + "-Unconditional";
            } else {
                processName = "processe" + "-" + match.groups.event.replace(blankRegExp, ' ');
            }
        } else {
            if (match.groups.event == null) {
                processName = processName + ":" + "Unconditional";
            } else {
                processName = processName + ":" + match.groups.event.replace(blankRegExp, ' ');
            }
        }
        let item = {
            "name": processName,
            "type": "processe",
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
    }
    return items;
}

//--------instantiation element--------//
function get_instances(text, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vhdl_instances.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            "name": match.groups.name,
            "type": "instance",
            "instparams": {
                "startIndex": -1,
                "lastIndex" : -1,
            },
            "instports" : {
                "startIndex": -1,
                "lastIndex" : -1,
            },
            "instName": match.groups.name,   // name
            "instModule": match.groups.type, // type
            "instModPath": "",
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        if (match.groups.params != null) {
            item.instparams.startIndex = match.index + offset + match[0].indexOf(match.groups.params);
            item.instparams.lastIndex = item.instparams.startIndex + match.groups.params.length;
        }
        if (match.groups.ports != null) {
            item.instports.startIndex = match.index + offset + match[0].indexOf(match.groups.ports);
            item.instports.lastIndex = item.instports.startIndex + match.groups.ports.length;
        }
        items.push(item);
        if (HDLSymbol != null) {
            let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
            HDLSymbol.symbols.push(symbolInfo);
        }
    }
    return items;
}
exports.get_instances = get_instances;

//--------ports element--------//
function get_ports(text, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vhdl_ports.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : "",
            'type' : (match.groups.type == "buffer") ? "buffer" : (match.groups.type + "put"),
            "portName"  : "",
            "portWidth" : (match.groups.width == undefined) ? "" : match.groups.width,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        var nameList = match.groups.name.split(",");
        for (let i = 0; i < nameList.length; i++) {
            if (nameList[i] != '') {                                
                item.name = nameList[i].replace(spaceRegExp,'');
                item.portName = item.name;
                items.push(item);
                if (HDLSymbol != null) {
                    let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                    HDLSymbol.symbols.push(symbolInfo);
                }
            }
        }
    }
    return items;
}

//--------signal element--------//
function get_signals(text, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vhdl_singals.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : "",
            'type' : "logic",
            'range': (match.groups.width == undefined) ? "" : match.groups.width,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        var nameList = match.groups.name.split(",");
        for (let i = 0; i < nameList.length; i++) {
            if (nameList[i] != '') {                                
                item.name = nameList[i].replace(spaceRegExp,'');
                items.push(item);
                if (HDLSymbol != null) {
                    let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                    HDLSymbol.symbols.push(symbolInfo);
                }
            }
        }
    }
    return items;
}

//--------param element--------//
function get_parameter(text, document, parent, offset, HDLSymbol) {
    let items = [];
    while (1) {
        let match = vhdl_parameter.exec(text);
        if (match == null) {
            break;      
        }
        let item = {
            'name' : "",
            'type' : "parameter",
            "paramName"  : "",
            "paramWidth" : (match.groups.width == undefined) ? "" : match.groups.width,
            "paramInit"  : (match.groups.init == undefined)  ? "" : match.groups.init,
            "startIndex": match.index + offset,
            "lastIndex" : match.index + match[0].length + offset,
        };
        var nameList = match.groups.name.split(",");
        for (let i = 0; i < nameList.length; i++) {
            if (nameList[i] != '') {                                
                item.name = nameList[i].replace(spaceRegExp,'');
                item.paramName = item.name;
                items.push(item);
                if (HDLSymbol != null) {
                    let symbolInfo = HDLSymbol.setSymbolInformation(item, parent, document);
                    HDLSymbol.symbols.push(symbolInfo);
                }
            }
        }
    }
    return items;
}

/////////////////////////util api////////////////////////////////////
function delComments(content) {
    let match = content.match(b_comment);
    if (match != null) {
        for (let i = 0; i < match.length; i++) {
            const element = match[i];
            const newElement = ' '.repeat(element.length);
            content = content.replace(element,newElement);
        }
    }
    match = content.match(l_comment);
    if (match != null) {
        for (let i = 0; i < match.length; i++) {
            const element = match[i];
            const newElement = ' '.repeat(element.length);
            content = content.replace(element,newElement);
        }
    }
    return content;
}

/**
     * 获取注释所在区间
     * 
     * @param  text         匹配的文本
     * @param  offset       匹配地址偏移(即匹配的文本在文件中的地址位置)
     * @return 返回注释所在区间的数组
*/
function getCommentRange (text, offset) {
    let commentRange = [];
    let regexes =  comment;
    for (let i = 0; i < regexes.length; i++) {
        while (1) {
            let match = regexes[i].exec(text);
            if (match == null) {
                break;
            }
            let Range = {
                "start"   : 0,
                "end"     : 0
            }
            Range.start = match.index + offset;
            Range.end = match.index + match[0].length + offset;
            commentRange.push(Range);
        }
    }
    return commentRange;
}
exports.getCommentRange = getCommentRange;